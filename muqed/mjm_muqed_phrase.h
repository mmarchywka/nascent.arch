#ifndef MJM_MUQED_PHRASE_H__
#define MJM_MUQED_PHRASE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_collections.h"
#include "mjm_file_finder.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Nov  5 10:43:39 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_muqed_phrase   
// g++  -Wall -std=gnu++11 -DTEST_MJM_MUQED_PHRASE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_muqed_phrase.h  -lpthread -lreadline

template <class Tr>
class mjm_muqed_phrase 
{
 typedef mjm_muqed_phrase Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;
typedef  Ragged::Line Line ;
typedef  Ragged::Line Words ;
typedef std::vector<IdxTy> Ref;
typedef std::map<StrTy, StrTy> PropertiesMap;
typedef std::map<StrTy, int > AdMap;
typedef mjm_file_finder<Tr> FileFinder;
public:
typedef FileFinder file_finder_type;
mjm_muqed_phrase() {Init(); }
~mjm_muqed_phrase() {}
enum { BAD=~0};
void clear() { Clear(); } 
Words & adj() { return m_words; } 
AdMap & admap() { return m_admap; } 
const AdMap & admap()const { return m_admap; } 
IdxTy words() const { return m_words.size(); } 
IdxTy add_word(const StrTy & w, const IdxTy loc) { return AddWord(w,loc); } 
template <class Tps > 
void organize_adjectives(Tps & ps ) { OrganizeAdjectives(ps,prop(),a1(),a2()); } 
PropertiesMap & prop() { return m_prop;}
const PropertiesMap & prop() const  { return m_prop;}
Words & a1() { return m_a1;}
Words & a2() { return m_a2;}
const file_finder_type * finder() const { return m_pfinder;} 
file_finder_type * finder() { return m_pfinder;} 
void  finder(file_finder_type * p )  { m_pfinder=p ;} 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
IdxTy AddWord(const StrTy & w, const IdxTy loc) 
{ 

IdxTy rc=0; 
m_words.push_back(w);
m_locs.push_back(loc); 
m_admap[w]=loc; // this is dumb no dups etc 
return rc; 

}  // AddWord 
template <class Tps, class Tprop>
void OrganizeAdjectives(Tps & ps,  Tprop & p,  Words &  a1,Words &  a2)
{
const Words & adj=m_words; // adjectives;
int  posof=BAD;
// TODO which is better? lol 
//#define NLOOP(x) if (a ==QUOTE(x))  {++i; if (i<sz) p[QUOTE(x)]=adj[i];  } 
#define NLOOP(x) if (a ==QUOTE(x))  {++i; if (i<sz) m_prop[a]=adj[i];  } 
MM_SZ_LOOP(i,adj,sz)  {
const StrTy & a=adj[i];
//MM_ERR(" organizing "<<MMPR2(i,adj[i]))
//if (a.length()==0) continue; // avoid checks later
const char * ap= a.c_str();
if (ap[0]==0) continue; // probably not useful 
if ( a=="of") {
if (posof!=BAD)
file_finder_type * m_pfinder;{
// TODO this i is wrong for user examination 
Ss ss; ss<<" multiple \"of\" "<<MMPR2(posof,m_locs[i]);
//rc.add_error(a,i,ss);
ps.add_error(a,m_locs[i],ss);
} // posof!=BAD
 posof=i;
 } // of 

//else if (a=="density") { ++i; if (i<sz) {  rho=adj[i];   rc.property("density",rho); } }
else NLOOP(density)
else NLOOP(UPC)
else NLOOP(expand)
else NLOOP(dmel)
else NLOOP(note)
else if (ap[0]=='!')  // new kw-syntax 
{ i+=1; if (i<sz) p[StrTy(ap+1)]=adj[i];   }
else if (a=="PROPERTY")  // new kw-syntax 
{ i+=2; if (i<sz) p[adj[i-1]]=adj[i];   }
else {  if (posof==BAD) a1.push_back(a); else a2.push_back(a); } 

} // i 


} // organize_adjectives

#undef NLOOP

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
StrTy Dump(const IdxTy flags =0 ) const
{ Ss ss;
{  MM_SZ_LOOP(i,m_words,sz) { ss<<MMPR(m_words[i])<<" "; }  }
{ MM_SZ_LOOP(i,m_a1,sz) { ss<<MMPR(m_a1[i])<<" "; }  }
{ MM_SZ_LOOP(i,m_a2,sz) { ss<<MMPR(m_a2[i])<<" "; }  }
MM_LOOP(ii,m_admap) { ss<<" admap "<<(*ii).first<<" "<<(*ii).second; } 
return ss.str();
} // Dump
void Init()
{
m_pfinder=0;
}
void Clear()
{
m_words.clear();
m_locs.clear();
m_admap.clear();
m_prop.clear();
m_a1.clear();
m_a2.clear();
} // Clear
// MEMBERS members 
Words m_words;
Ref m_locs;
AdMap m_admap;
PropertiesMap m_prop;
Words m_a1,m_a2;
file_finder_type * m_pfinder;
}; // mjm_muqed_phrase

//////////////////////////////////////////////

template <class Tr>
class mjm_muqed_phrase_map : public std::map<typename Tr::StrTy, mjm_muqed_phrase< Tr > >  
{
 typedef mjm_muqed_phrase_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_muqed_phrase< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_muqed_phrase_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_muqed_phrase_map




////////////////////////////////////////////
#ifdef  TEST_MJM_MUQED_PHRASE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_muqed_phrase <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MUQED_PHRASE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_muqed_phrase<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MUQED_PHRASE_H__ 
