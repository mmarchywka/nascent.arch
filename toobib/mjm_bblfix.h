#ifndef MJM_BBLFIX_H__
#define MJM_BBLFIX_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_bibtex_entry.h"
#include "mjm_bibitem_entry.h"
#include "mjm_latex_aux_parse.h"
#include "mjm_latex_bbl_writer.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Mon Feb 14 10:26:19 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bblfix   
// g++  -Wall -std=gnu++11 -DTEST_MJM_BBLFIX -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bblfix.h  -lpthread -lreadline
// g++  -Wall -std=gnu++11 -DTEST_MJM_BBLFIX -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bblfix.h -o mjm_bblfix.out  -lpthread -lreadline
/*

A typical bbl file entry. Entries can be extracted from the aux file
and produced similarly without the bst file. 

\bibitem{MitochondriaContributeNADPHLeopoldAdlerChunhe2014}
Leopold Adler, Chunhe Chen, and Yiannis Koutalos.
\newblock Mitochondria contribute to nadph generation in mouse rod
  photoreceptors *.
\newblock {\em Journal of Biological Chemistry}, 289:1519--1528, 01 2014.
\newblock URL: \url{https://www.jbc.org/article/S0021-9258(20)33629-2/pdf},
  \href {http://dx.doi.org/10.1074/jbc.M113.511295}
  {\path{doi:10.1074/jbc.M113.511295}}.





*/


template <class Tr>
class mjm_bblfix 
{
 typedef mjm_bblfix Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_blob<Tr>  Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;



 typedef  mjm_bibitem_entry<Tr> BibItem;
 typedef mjm_bibitem_entry_map<Tr> BibItemMap;
 typedef mjm_latex_aux_parse<Tr> LatexAux;
typedef typename LatexAux::find_vector_type AuxFind;

typedef mjm_latex_bbl_writer<Tr> BblWriter;


public:
mjm_bblfix() {}
~mjm_bblfix() {}
Myt & set_proj_name(const StrTy & x) { m_proj_name=x; return *this; }
Myt & set_proj_dir(const StrTy & x) { m_proj_dir=x; return *this; }
IdxTy load_proj(const StrTy & dir, const StrTy & nm, const IdxTy flags=0)
{ return LoadProj(dir,nm,flags); }
IdxTy load_bbl(const StrTy & fn , const IdxTy flags) 
{ return m_bim.load(FixPath(fn),flags) ;} 
IdxTy make_bbl(const IdxTy flags) { return MakeBbl(flags); } 
IdxTy modify_bbl_urls(const StrTy & s , const IdxTy flags) 
{ return m_bim.modify_urls(s,flags) ;} 
IdxTy save_bbl(const StrTy & fn , const IdxTy flags) 
{ 
MM_MSG(" need to run lualatex TWICE for citation updates and verify save.")
Blob b; b=m_bim.dump(0); b.save(FixPath(fn)); return b.load(FixPath(fn))!=0; } 
IdxTy load_bib(const StrTy & fn , const IdxTy flags) 
{ m_bem.parse(FixPath(fn),flags) ; return m_bem.size(); } 

IdxTy check_bbl(const IdxTy flags) 
{ return CheckBbl(flags); }
IdxTy check_bem(const IdxTy flags) 
{ return CheckBem(flags); }


/*
if (cmd=="dump") { MM_ERR(x.dump(atoi(cip.p1.c_str()))) }
else if (cmd=="load") { x.load(cip.p1,0); }
else if (cmd=="mod") { x.modify_urls(cip.p1,0); }
else if (cmd=="parse") { x.parse(atoi(cip.p1.c_str())); }

*/

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR4( m_proj_name, m_proj_dir, m_bim.size(), m_bem.size());
ss<<MMPR2(m_req_files.size(),m_req_files.dump());
return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

StrTy FixPath(const StrTy & fn, const IdxTy flags=0)
{
const IdxTy l=fn.length();
const char * p=fn.c_str();
// ./ needs to have the proj dir.. 
if (*p!='/') return m_proj_dir+"/"+fn;
return fn;
} // FixPath

IdxTy LoadProj(const StrTy & dir, const StrTy & nm, const IdxTy flags )
{
set_proj_dir(dir);
set_proj_name(nm);
// if there is a required files file, load that. 
// shoudl load using key-value pair loader with just one key 
m_req_files.load(FixPath(m_proj_name+".required_files"));
// find the bib files it used, load those 
MM_LOOP(ii,m_req_files)
{
if ((*ii).size()!=2) continue;
const StrTy & fn =(*ii)[1];
const IdxTy len=fn.length();
if (len<4) continue;
if (strncmp(fn.c_str()+len-4,".bib",4)) continue; 
MM_ERR("loading bib "<<MMPR((FixPath(fn))));
m_bem.parse(FixPath(fn));

} // ii 
// get the bbl file

m_bim.load(FixPath(m_proj_name+".bbl"),0);
m_bim.parse(0);
m_aux.load(FixPath(m_proj_name+".aux"),0);
//AuxFind fv=m_aux.find("bibcite",0);
//2023-01-14 this is getting the orde wrong, right now
// use the sort order from whatever created bbl so that
// refs are right. 
// leave  as-is need to run lualatex twice it seven says
// the  regfs may have  change 
AuxFind fv=m_aux.find("citation",0);
MM_LOOP(ii,fv) { MM_ERR(MMPR((*ii))) } 
CheckAux(fv,0);
return 0; 

} // LoadProj

IdxTy CheckAux(const AuxFind & af, const IdxTy flags) 
{
MM_LOOP(ii,af)
{

const auto  * p =m_bem[(*ii)];
const IdxTy sz=m_bem.size((*ii));
if (p) MM_ERR(MMPR3((*ii),sz,(*p).size()))
else  MM_ERR("missing "<<MMPR2((*ii),sz))


} // ii 
return 0; 
} // CheckAux

IdxTy MakeBbl(const IdxTy flags) 
{
m_bim=BibItemMap();
// first see if the bibcites are already there... 
//AuxFind fvcites=m_aux.find("bibcite",0);

// 2023-01-14 the order etc here is wrong
// need to use the bbl file or \\bibcite NOT citation 
// leave as-s run  lualatex twice seems to say refs are wrong
//
AuxFind fv=m_aux.find("citation",0);
Ss ss;
ss<<"\\begin{thebibliography}{10}"<<CRLF;
typedef typename BblWriter::bib_result BibRes;
std::vector<BibRes> brs;
BblWriter bbw;
std::map<StrTy,int> already;
MM_LOOP(ii,fv)
{
if (already.find((*ii))!=already.end()) continue;
++already[*ii];
const auto  * p =m_bem[(*ii)];
const IdxTy sz=m_bem.size((*ii));
if (p) MM_ERR(MMPR3((*ii),sz,(*p).size()))
else  MM_ERR("missing "<<MMPR2((*ii),sz))
BibRes br(ss);
if (p) { BibEntry bex=*p; bex.make_keys_uniform();   bbw.make(br,bex);  }
else bbw.make(br,BibEntry()); 
brs.push_back(br);
} // ii 
ss<<"\\end{thebibliography}"<<CRLF;
m_bim.load(ss,0);
m_bim.parse(0);
return 0; 
} // MakeBbl

IdxTy CheckBbl(const IdxTy flags) 
{
const IdxTy n=m_bim.size();
for(IdxTy i=0; i<n; ++i)
{
const StrTy name= m_bim[i].bibitem();
const IdxTy sz=m_bem.size(name);
const auto  * p =m_bem[name];
if (p) MM_ERR(MMPR3(name,sz,(*p).size()))
else  MM_ERR("missing "<<MMPR2(name,sz))

} // i 
return 0; 
} // CheckBbl

int  BadChars(Ss & ss, const StrTy & x, const IdxTy flags=0)
{
const bool wr=false;
const char * p= x.c_str();
const IdxTy len=x.length();
IdxTy cnt=0; 
int  net=0; 
for(IdxTy i=0; i<len; ++i)
{
const char c=p[i];
if (c=='{'){ ++net; ++cnt; if( wr)  ss<<" bad left in "<<MMPR(x); } 
if (c=='}'){--net;  ++cnt; if (wr) ss<<" bad right in "<<MMPR(x); } 

} // i 

return net; 
}

IdxTy CheckBem(const IdxTy flags)
{
Ss ss;
const IdxTy sz=m_bem.entries();
for(IdxTy i=0; i<sz; ++i)
{
const auto & be=m_bem[i];
const StrTy & nm=be.name();
const StrTy & ty=be.type();
// check name and type
if ( BadChars(ss,nm,flags) ) ss<<MMPR(nm)<<CRLF;
if ( BadChars(ss,ty,flags) ) ss<<MMPR2(nm,ty)<<CRLF;
//BadChars(ss,ty,flags);
MM_LOOP(ii,be.map())
{
// check key too
if ( BadChars(ss,(*ii).first,flags) ) ss<<(*ii).first<<CRLF;

MM_LOOP(jj,(*ii).second)
{
if ( BadChars(ss,(*jj),flags) ) ss<<MMPR2(nm,(*jj))<<CRLF;

} // jj 
} // ii 

} // i 
MM_ERR(MMPR(ss.str()))

return 0;
} // CheckBem




// MEMBERS
StrTy m_proj_name, m_proj_dir;
BibItemMap m_bim;
BibEntryMap m_bem;
Ragged m_req_files;
LatexAux m_aux;
}; // mjm_bblfix

//////////////////////////////////////////////

template <class Tr>
class mjm_bblfix_map : public std::map<typename Tr::StrTy, mjm_bblfix< Tr > >  
{
 typedef mjm_bblfix_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bblfix< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bblfix_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bblfix_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BBLFIX
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_bblfix <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BBLFIX "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bblfix<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

//IdxTy modify_bbl_urls(const StrTy & s , const IdxTy flags) 
//IdxTy save_bbl(const StrTy & fn , const IdxTy flags) 

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load_proj(cip.p1,cip.p2,1); }
else if (cmd=="modify") { x.modify_bbl_urls(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="save") { x.save_bbl(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="make") { x.make_bbl(atoi(cip.p1.c_str())); }
else if (cmd=="check") { x.check_bbl(atoi(cip.p1.c_str())); }
else if (cmd=="checkbem") { x.check_bem(atoi(cip.p1.c_str())); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BBLFIX_H__ 
