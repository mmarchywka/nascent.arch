#ifndef MJM_BIBITEM_ENTRY_H__
#define MJM_BIBITEM_ENTRY_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include "mjm_hier_two.h"
#include "mjm_bibtex_fields.h"
#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_cpp_regex.h"
#include "mjm_wovdb.h"
#include "mjm_blob.h"
#include "mjm_strings.h"
#include "mjm_collections.h"
#include "mjm_pawnoff.h"
#include "mjm_ext_things.h"

#include "mjm_assemble_putative_bibtex.h"
//#include "mjm_try_n_get.h"
#include "mjm_doi_scrape.h"
#include "mjm_scrape_xform.h"
#include "mjm_bibtex_entry.h"
#include "mjm_hierarchial_kvp.h"
//#include "mjm_bomtex_json.h"
//#include "mjm_jats_xml.h"
#include "mjm_wovdb.h"
#include "mjm_misc_parse.h"
#include "mjm_idiosyncratic_source_locator.h"

#include <map>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <cstdio>
                                                             

// Sun Feb 13 17:58:59 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bibitem_entry   
// g++  -Wall -std=gnu++11 -DTEST_MJM_BIBITEM_ENTRY -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bibitem_entry.h  -lpthread -lreadline

template <class Tr>
class mjm_bibitem_entry 
{
 typedef mjm_bibitem_entry Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef mjm_assemble_putative_bibtex<Tr> Finisher;
typedef typename Finisher::return_code Frc;
typedef typename Finisher::assem_opt Ao;
typedef mjm_ext_things<Tr> Ext;

typedef mjm_var_parse<Tr> ParseTable;
typedef typename ParseTable::Iv Iv;

typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;

typedef mjm_hierarchial_kvp<Tr> HierKvp;
typedef mjm_hier_two<Tr> HierUtil;

typedef mjm_strings StrUtil;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;
typedef mjm_bibtex_fields<Tr> Fields;





public:
mjm_bibitem_entry() {}
~mjm_bibitem_entry() {}
const StrTy bibitem() const { return m_bibitem; }
IdxTy parse( const Ragged & s, const IdxTy first, const IdxTy end, const IdxTy flags)
 { return  Parse(  s,first,  end,  flags);
}
IdxTy modify_urls(  const StrTy s, const IdxTy flags)
 { return  ModifyUrls(  s, flags);
}

void  dump( Ss & ss, const IdxTy flags=0) {  Dump(ss,flags); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; 
return Dump(ss,flags); }
 
void  Dump( Ss & ss, const IdxTy flags=0)  // { return Dump(ss,flags); }
{
if (Bit(flags,1)) { ss<<bibitem(); return ; } 
MM_LOOP(ii,m_r)
{
MM_LOOP(jj,(*ii)) { ss<<(*jj); } 
ss<<CRLF;
} // ii 

}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

// exact string broken into units by the 
// Ragged parser.. 
/*
1336|  |116|(|38|)|:|19126|-|-|19135|,| |2019|.
1337|\|newblock| |URL|:| |\|url|{|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|}|,| |\|href
1338|  |{|http|:|/|/|arxiv|.|org|/|abs|/|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|.|full|.|pdf|}
1339|  |{|\|path|{|arXiv|:|https|:|/|/|www|.|pnas|.|org|/|content|/|116|/|38|/|19126|.|full|.|pdf|}|}|,| |\|href
1340|  |{|http|:|/|/|dx|.|doi|.|org|/|10|.|1073|/|pnas|.|1909604116|}
1341|  |{|\|path|{|doi|:|10|.|1073|/|pnas|.|1909604116|}|}|.
1342
*/

IdxTy ModifyUrls(  const StrTy s, const IdxTy flags)
{
enum { FOUND=0, LEFT=1, QUERY=2, FRAG=3, ADDED=4 };
IdxTy state=0;
Ragged sr;
StrTy prior="";
Ragged::Line temp;
MM_LOOP(ii,m_r)
{
Ragged::Line nl;
MM_LOOP(jj,(*ii)) { 
const StrTy & urlq=(*jj);
StrTy lc=StrUtil::fancy_to_lower(urlq);
//const char * lcp=lc.c_str();
MM_ERR(MMPR3(urlq,state,prior))
if (Bit(state,LEFT)&&(urlq!="}"))
{

if (lc=="#"){ state|=(1<<FRAG);
// meaning there is also no query... 
if (!Bit(state,ADDED))
{
state|=(1<<ADDED);
temp.push_back("?");
temp.push_back(s);
}
else if (temp.size()) if (temp.back()=="&") temp.pop_back(); // speculative ampersand... 
}

// add in front... easier than finding the end.. 
prior=urlq;
temp.push_back(urlq);
if (lc=="?"){
 state|=(1<<QUERY);
 state|=(1<<ADDED);
temp.push_back(s);
// this is speculative... 
temp.push_back("&");
}
continue;
} // LEFT 
else if (Bit(state,FOUND)&&(lc=="{")) {state|=(1<<LEFT); } 
else if (lc=="}") {
// end if there was anything...
if (state)
{
if (!Bit(state,ADDED))
{
state|=(1<<ADDED);
temp.push_back("?");
temp.push_back(s);
}
else if (temp.size()) if (temp.back()=="&") temp.pop_back(); // speculative ampersand... 
MM_LOOP(kk,temp) { nl.push_back(*kk); }
temp.clear();
state=0;
}
}
else if ((prior=="\\")&&((lc=="href")||(lc=="url"))) 
{ state|=(1<<FOUND); } // url start 

prior=urlq;
nl.push_back(urlq);
}  // jj 
// want to preserve blank lines but not add any... 
sr.add(nl);
} // ii 

if (temp.size())
{ MM_ERR(" stuff remains in temp "<<MMPR(temp.size())) }

m_r=sr;
return 0;
}
IdxTy Parse( const Ragged & s, const IdxTy first, const IdxTy end, const IdxTy flags)
 {IdxTy rc=0;
StrTy prior="";
IdxTy state=0;
enum { START=1, ITEM=2} ;
bool have_item=false;
for(IdxTy i=first; i<end; ++i)
{
if (!have_item)
{
MM_LOOP(ii,s[i])
{
if (Bit(state,ITEM))
{
if ((*ii)=="}") { state=0; have_item=true; break; } 
else m_bibitem+=(*ii);
}
else if (Bit(state,START)&&((*ii)=="{")) { state|=(1<<ITEM); }
else if (( (*ii)=="bibitem") &&(prior=="\\"))  state|=(1<<START);

prior=(*ii);
}
} // have_item

m_r.add(s[i]);
}
 return  rc;
}

// MEMBERS
Ragged m_r;
StrTy m_bibitem;

}; // mjm_bibitem_entry

//////////////////////////////////////////////

template <class Tr>
class mjm_bibitem_entry_map : public std::map<typename Tr::StrTy, mjm_bibitem_entry< Tr > >  
{
 typedef mjm_bibitem_entry_map Myt;
 typedef mjm_bibitem_entry<Tr>  Ent;
typedef typename std::map<typename Tr::StrTy, mjm_bibitem_entry< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef mjm_assemble_putative_bibtex<Tr> Finisher;
typedef typename Finisher::return_code Frc;
typedef typename Finisher::assem_opt Ao;
typedef mjm_ext_things<Tr> Ext;

typedef mjm_var_parse<Tr> ParseTable;
typedef typename ParseTable::Iv Iv;

typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibMap;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;

typedef mjm_hierarchial_kvp<Tr> HierKvp;
typedef mjm_hier_two<Tr> HierUtil;

typedef mjm_strings StrUtil;

typedef mjm_idiosyncratic_source_locator<Tr> IdioRL;
typedef mjm_bibtex_fields<Tr> Fields;







public:
mjm_bibitem_entry_map() {}
const Ent & operator[](const IdxTy n) const { return m_vec[n]; }
Ent & operator[](const IdxTy n) { return m_vec[n]; }
const IdxTy load(const StrTy & fn, const IdxTy flags) { return Load(fn,flags); }
const IdxTy load(Ss & ss, const IdxTy flags) { return Load(ss,flags); }

IdxTy parse( const IdxTy flags) { return Parse( m_r, 0, m_r.size(),flags); }

IdxTy modify_urls(  const StrTy s, const IdxTy flags)
{ return ModifyUrls(s,flags); } 
IdxTy size() const { return Super::size()+m_vec.size(); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
if (Bit(flags,0)) ss<<m_r.dump(flags);
//m_r.dump(ss,flags);
MM_LOOP(ii,m_vec)
{
//ss<<(*ii).dump(flags);
(*ii).dump(ss,flags);
ss<<CRLF;

}

MM_LOOP(ii,(*this))
{
//ss<<(*ii).first<<CRLF;
//ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 
}

private:
IdxTy Parse( const Ragged & s, const IdxTy first, const IdxTy end, const IdxTy flags)
{
IdxTy rc=0;
const IdxTy sz=s.size();
const IdxTy fini=(sz>=end)?end:sz;
if (fini<=first) return ~0; 
int  st=~0;
for(IdxTy i=first; i<fini; ++i)
{
const Ragged::Line & l=s[i];
IdxTy tnw=0;
MM_LOOP(ii,l) {  if ((*ii).c_str()[0]!=' ' ) ++tnw; } 
if (tnw==0)
{
if ( st!= ~0 ) { 
Ent x;
x.parse(s,st,i,flags);
m_vec.push_back(x);
st=~0; 
} // st
continue; 
} // blank line
if (st== ~0 ) st=i;


} // i
if ( st!= ~0 ) { 
Ent x;
x.parse(s,st,fini,flags);
m_vec.push_back(x);
st=~0; 
} // st
MM_ERR(MMPR(m_vec.size()))

return rc; } // Parse


const IdxTy Load(const StrTy & fn, const IdxTy flags) 
{ 
IdxTy rc=0;
m_r.splitter(8);
m_r.load(fn,1);
MM_ERR(MMPR(m_r.size()))
return rc; 
} // Load

const IdxTy Load(Ss & ss, const IdxTy flags) 
{ 
IdxTy rc=0;
m_r.splitter(8);
m_r.load(ss,1);
MM_ERR(MMPR(m_r.size()))
return rc; 
} // Load




IdxTy ModifyUrls(  const StrTy s, const IdxTy flags)
{
IdxTy rc=0;
MM_LOOP(ii,m_vec)
{
rc|=(*ii).modify_urls(s,flags); 
} // ii 

return rc;
} // ModifyUrls
// MAP MEMBERS

Ragged m_r;
typedef std::vector<Ent> Vec;

Vec m_vec;


}; // mjm_bibitem_entry_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIBITEM_ENTRY
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_bibitem_entry <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIBITEM_ENTRY "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
//typedef mjm_bibitem_entry<Tr>  Myt;
typedef mjm_bibitem_entry_map<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump(atoi(cip.p1.c_str()))) }
else if (cmd=="load") { x.load(cip.p1,0); }
else if (cmd=="mod") { x.modify_urls(cip.p1,0); }
else if (cmd=="parse") { x.parse(atoi(cip.p1.c_str())); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIBITEM_ENTRY_H__ 
