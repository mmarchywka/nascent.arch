#ifndef MJM_COLUMN_PLOT_H__
#define MJM_COLUMN_PLOT_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


#include "mjm_collections.h"
#include "mjm_tokenized_collections.h"
#include "mjm_block_matrix.h"

// plot(df$V1,df$V2,col=as.character(df$V3),pch=10)

// Fri Apr  1 12:45:59 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_column_plot   
// g++  -Wall -std=gnu++11 -DTEST_MJM_COLUMN_PLOT -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_column_plot.h  -o mjm_column_plot.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_column_plot("mjm_column_plot"
, "  ");

template <class Tr>
class mjm_column_plot 
{
 typedef mjm_column_plot Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
typedef mjm_block_matrix<D>  MyBlock;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line; 
typedef std::map<StrTy, Ragged> RaggedMap;
class _colors
{
public:
_colors() { Init(); } 
void val(const StrTy & v)
{
//auto ii=m_map.find(v);
++m_cnt[v]; 
} //val
const StrTy color(const StrTy & c) 
{

if (m_map.find(c)==m_map.end())
{
const IdxTy sz=m_map.size();
m_map[c]=m_list[sz%m_list.size()];
MM_ERR(" COLORING "<<MMPR2(c,m_map[c]))
}
const StrTy x=m_map[c];

if (x=="") return "black";

return x;
}
void Init()
{
m_list.push_back("black");
m_list.push_back("\"#00ff00\"");
m_list.push_back("\"#ff0000\"");
m_list.push_back("\"#0000ff\"");
m_list.push_back("\"#ff00ff\"");
//m_list.push_back("\"#ffff00\"");

} // Init

std::map<StrTy, StrTy> m_map;
std::map<StrTy, IdxTy> m_cnt;
std::vector<StrTy> m_list;
};
typedef _colors Colors;
class _val_scan
{

typedef std::map<D,IdxTy> H;
public:
_val_scan() { Init(); } 
IdxTy val(const StrTy & v)
{
D vf=atof(v.c_str());
//++m_map[atof(v.c_str())];
++m_map[vf];
return 0;
}
const D & sum() const { return m_sum; } 
const D & h() const { return m_h; } 
void calc()
{ calc_h();
}
void calc_h()
{
if (m_n) return; 
MM_LOOP(ii,m_map)
{
//const D v=atof((*ii).first.c_str());
const D v=((*ii).first);
const IdxTy n=(*ii).second;
m_sum+=n*v;
m_n+=n;
} // ii 
const D scale=1.0/log(2);
MM_LOOP(ii,m_map)
{
//const D v=atof((*ii).first.c_str());
const D v=((*ii).first);
const IdxTy n=(*ii).second;
const D p=v/m_sum; // doh D(n)/D(m_n);
if (p>0) if (n>0)  m_h-=D(n)*p*log(p)*scale;

} // ii 


} // calc_h


IdxTy non_zed(D & min, D & max) const
{
const _val_scan & vs=*this; 
auto ir=(vs.m_map.rbegin());
if (ir!=vs.m_map.rend()) max=(*ir).first;
auto ii=(vs.m_map.begin());
while (ii!=vs.m_map.end())
{
if ((*ii).first!=0) {min=(*ii).first; break; } 
++ii;
} //ii 
return 0; 
}  // non_zed

void Init()
{
m_h=0;
m_sum=0;
m_n=0;
} 

H m_map;
D m_h,m_sum;
IdxTy m_n=0;

}; // _val_scan
typedef _val_scan val_scan;

class _plot_params
{
public:
_plot_params() { Init(); }
StrTy dump() const
{
Ss ss;  ss<<MMPR4( m_colx,m_coly,m_colc,m_xx)<<MMPR(m_xy);
return ss.str(); 
}
void Init()
{

 m_colx=m_coly=m_colc=m_xx=m_xy=~0;
m_nkeys=0;
}
IdxTy m_colx,m_coly,m_colc, m_xx,m_xy,m_nkeys;

}; // _plot_params

typedef _plot_params plot_params;



public:
typedef plot_params plot_params_type;
mjm_column_plot() {}
~mjm_column_plot() {}

// plot(df$V1,df$V2,col=as.character(df$V3),pch=10)


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
IdxTy r_plot(Ragged & d, const Ragged & r, const plot_params_type & pp, const IdxTy flags)
{
return  Rplot(d,r,pp,flags); 
}
IdxTy r_stat(Ragged & d, const Ragged & r, const IdxTy nvals, const IdxTy flags)
{ return  Rstat(d,r,nvals,flags); }
IdxTy r_stuff(Ragged & d, const Ragged & r, const IdxTy nvals, const IdxTy flags)
{ return  Rstuff(d,r,nvals,flags); }




private:
StrTy XfColors(const StrTy & y, Colors & c, const IdxTy  flags)
{

return  c.color(y);
} // Colors 
StrTy Xform(const StrTy & y, const IdxTy xform, const val_scan & vs)
{
const D cf=1.0/log(10);
if (xform==0) return y;
if (xform==2)
{
D vd=atof(y.c_str());
const D p=vd/vs.sum();
if (p==0) return "0"; 
const D he=-p*log(p)/vs.h()/log(2);
Ss ss; ss<<he; return ss.str();
} //xform ==2

if (xform ==1)
{
D min=0;
D max=0;
vs.non_zed(min,max);
/*
auto ir=(vs.m_map.rbegin());
if (ir!=vs.m_map.rend()) max=(*ir).first;
auto ii=(vs.m_map.begin());
while (ii!=vs.m_map.end())
{
if ((*ii).first!=0) {min=(*ii).first; break; } 
++ii;
} //ii 
*/

if (min==0) return y;
const D rat=max/min;
// log(min) -(.1*(log(max)-log(min))) =>  min *(min/max)^.1 
D vd=atof(y.c_str());
//if (vd==0) vd=min/10;
// faster to do this in the log domain doh 
if (vd==0) vd=min*pow(min/max,.1);
//const D lvd=log(vd)/log(10);
const D lvd=cf*log(vd);
Ss ss; ss<<lvd; return ss.str();
}
return y; 
} // xform 


IdxTy Rplot(Ragged & d, const Ragged & r, const plot_params_type & pp, const IdxTy flags)
{
const bool diff_over_sum=Bit(flags,0);
const bool remove_nulls=Bit(flags,1);
MM_ERR(MMPR2(diff_over_sum,remove_nulls))
IdxTy colx=pp.m_colx;
IdxTy coly=pp.m_coly;
IdxTy colc=pp.m_colc;
IdxTy xformx=pp.m_xx;
IdxTy xformy=pp.m_xy;
Colors cc;
val_scan vx,vy;
MM_LOOP(ii,r) {cc.val((*ii)[colc]);  vx.val((*ii)[colx]); vy.val((*ii)[coly]); } 
vx.calc();
vy.calc();

MM_SZ_LOOP(i,r,szr)
{
const Line & l=r[i];
const IdxTy sz=l.size();

Line dl;
// plot(df$V1,df$V2,col=as.character(df$V3),pch=10)
// making this the log f- up the diff lol.... 
//const StrTy xo=l[colx];
StrTy x=l[colx]; //  Xform(l[colx],xformx,vx);
StrTy y= l[coly]; //Xform(l[coly],xformy,vy);
const D xd=atof(x.c_str());
const D yd=atof(y.c_str());
if (xd==0) if (yd==0) if (remove_nulls) continue; 
if (diff_over_sum)
{
//const D xd=atof(xo.c_str());
const D d=xd+yd;
// not real consistent but ok 
if (d!=0)
{
const D yn=(xd-yd)/(d);
Ss ss; ss<<yn;
y=ss.str();}
else { 
if (xd==0) { y="0";}
else  MM_ERR( " bad xform "<<MMPR4(i,x,y,d))

}
}
//const StrTy xo=l[colx];
// note that the vx and vy are done on unxformed inputs... doh 
 x= Xform(x,xformx,vx);
 y= Xform(y,xformy,vy);

const StrTy colkey=XfColors( l[colc],cc,0);
dl.push_back(x);
dl.push_back(y);
dl.push_back(colkey);
// plotting symbol??? 
dl.push_back(StrTy("10"));
// may as well get whole line... 
//for(IdxTy j=0; j<pp.m_nkeys; ++j) dl.push_back(l[j]); 
for(IdxTy j=0; j<sz; ++j) dl.push_back(l[j]); 
d.add(dl);

} // i 

return 0;

} // Rplot

IdxTy Rstat(Ragged & d, const Ragged & r, const IdxTy nvals, const IdxTy flags)
{

if (true) return Rcum(d,r,nvals,flags);

std::vector<val_scan>  vv;
std::vector<D>  sums;
std::vector<D>  breaks;
IdxTy nsamples=0; 
IdxTy nbins=20;
for(IdxTy i=0; i<nvals; ++i) {sums.push_back(0);   vv.push_back(val_scan());  }
for(IdxTy i=0; i<nbins; ++i) {breaks.push_back(D(i+1)/D(nbins+1));   }
MM_ERR(" loop 1 "<<MMPR2(nvals,nbins))
MM_LOOP(ii,r) {
const IdxTy len=(*ii).size();
if ( len<=nvals) { MM_ERR(" may due "<<MMPR2(len,nvals)) } 
for(IdxTy i=0; i<nvals; ++i)  {vv[i].val((*ii)[len-nvals+i]);  } 
++nsamples; 
} 
MyBlock m(nbins,nvals);
for(IdxTy i=0; i<nvals; ++i) 
{
D sum=0;
IdxTy bin=0;
IdxTy samples=0;
MM_LOOP(ii,vv[i].m_map)
{
samples+=(*ii).second;
sum+=(*ii).first*D((*ii).second);
if (sum>=breaks[bin]){ 
//MM_ERR( MMPR4(sum,(*ii).first,bin,i)) ;  
//m(bin,i)=(*ii).first; ++bin ; if (bin>=nbins) break;  } 
m(bin,i)=samples; ++bin ; if (bin>=nbins) break;  } 
} // ii 
}  // i 
for(IdxTy i=0; i<nbins; ++i) 
{
Line l;
Ss ss; ss<<breaks[i];
l.push_back(ss.str());
for(IdxTy j=0; j<nvals; ++j) 
{
Ss ss; ss<<m(i,j);
l.push_back(ss.str());
} // j
d.add(l);
} // i 

return 0;
} // Rstat

class col_comp
{

public:
col_comp(): r(0),k(~0) {}
col_comp(const Ragged & pr, const IdxTy col): r(&pr),k(col) {}
int operator()(const IdxTy i, const IdxTy j) { return atof((*r)[i][k].c_str())<atof((*r)[j][k].c_str()); } 
const Ragged * r;
IdxTy k;
}; // col_comp

IdxTy Rstuff(Ragged & d, const Ragged & r, const IdxTy nvals, const IdxTy flags)
{
typedef std::vector<D>  Dv; //  sums;
Dv sums,totals;
for(IdxTy i=0; i<nvals; ++i){  sums.push_back(0); totals.push_back(0); } 
D scale= -1.0/log(2);
IdxTy nsamples=r.size();
if (nsamples==0) return 0;
for(IdxTy i=0; i<nsamples; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if ( len<=nvals) { MM_ERR(" may due "<<MMPR2(len,nvals)) } 
const IdxTy off=len-nvals; 
for(IdxTy j=0; j<nvals; ++j)  { totals[j]+=atof(l[off+j].c_str()); } // j 
} // i 

for(IdxTy j=0; j<nvals; ++j)  { MM_ERR(MMPR2(j,totals[j])); } // j 
for(IdxTy i=0; i<nsamples; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if ( len<=nvals) { MM_ERR(" may due "<<MMPR2(len,nvals)) } 
const IdxTy off=len-nvals; 
for(IdxTy j=0; j<nvals; ++j)  { 
D v=atof(l[off+j].c_str()); 
if (totals[j]!=0) v=v/totals[j]; 
if (v!=0) sums[j]+=v*scale*log(v);
} // j 
} // i 
Line dl;
dl.push_back(" Entropy");
for(IdxTy i=0; i<nvals; ++i){ Ss ss; ss<<sums[i];  dl.push_back(ss.str());  } 

d.add(dl);


return 0;
} // Rstuff


IdxTy Rcum(Ragged & d, const Ragged & r, const IdxTy nvals, const IdxTy flags)
{
//std::vector<val_scan>  vv;
Colors cc;
IdxTy nsamples=r.size();
if (nsamples==0) return 0;
typedef std::vector<IdxTy> Iv;
const IdxTy lenzed=r[0].size();
const IdxTy oofzed=lenzed-nvals;
IdxTy colc=1;
typedef std::vector<D>  Dv; //  sums;
std::vector< Iv > ords;
std::vector< Dv > sums;
for(IdxTy i=0; i<nvals; ++i) {
ords.push_back(std::vector<IdxTy> ());
Iv & x=ords.back();
for(IdxTy j=0; j<nsamples; ++j) { x.push_back(j); } 
col_comp ccomp(r,oofzed+i);
std::sort(x.begin(),x.end(),ccomp);
// the vector contains the ordering, but each line needs
// its ordinal AFTER traversing for integrations.... 
Dv y;
D old=0;
for(IdxTy j=0; j<nsamples; ++j) { y.push_back(0); } 
for(IdxTy j=0; j<nsamples; ++j) {
D s2=atof(r[x[j]][oofzed+i].c_str())+old;  
y[x[j]]=s2; //y.push_back(s2); 
old=s2; } 

sums.push_back(y);
Iv swap=x;
for(IdxTy j=0; j<nsamples; ++j) { swap[x[j]]=j; ; } 
x=swap;

//sums.push_back(0);    
} // i 
IdxTy j=0;
MM_LOOP(ii,r) {
const Line & l=(*ii);
const IdxTy len=(*ii).size();
if ( len<=nvals) { MM_ERR(" may due "<<MMPR2(len,nvals)) } 
const IdxTy off=len-nvals; 
for(IdxTy i=0; i<nvals; ++i)  {
//sums[i]+=atof(l[off+i].c_str());
} 
Line dl;
//for(IdxTy i=0; i<off; ++i)  { dl.push_back(l[i]); }
for(IdxTy i=0; i<len; ++i)  { dl.push_back(l[i]); }
//for(IdxTy i=0; i<nvals; ++i)  { Ss ss; ss<<sums[i]; dl.push_back(ss.str()); } 
for(IdxTy i=0; i<nvals; ++i)  {Ss ss; ss<<sums[i][j]; dl.push_back(ss.str()); }
for(IdxTy i=0; i<nvals; ++i)  {
D v=atof(l[off+i].c_str());
 Ss ss; if ( v!=0) ss<<(ords[i][j]+1); else ss<<0;  dl.push_back(ss.str()); 
} 
const StrTy colkey=XfColors( l[colc],cc,0);
dl.push_back(colkey);
d.add(dl);
++j; 
} // ii  

return 0;
} // Rcum


bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// MEMBERS



}; // mjm_column_plot

//////////////////////////////////////////////

template <class Tr>
class mjm_column_plot_map : public std::map<typename Tr::StrTy, mjm_column_plot< Tr > >  
{
 typedef mjm_column_plot_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_column_plot< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_column_plot_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_column_plot_map




////////////////////////////////////////////
#ifdef  TEST_MJM_COLUMN_PLOT
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_column_plot <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_COLUMN_PLOT "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_column_plot<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_COLUMN_PLOT_H__ 
