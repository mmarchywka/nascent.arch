#ifndef MJM_BIOM_TO_RAG_H__
#define MJM_BIOM_TO_RAG_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <../mjsonu/mjsonu.h>

#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// g++  -Wall -std=gnu++11 -DTEST_MJM_BIOM_TO_RAG -I. -I../../mjm/hlib -I../../mjm/num -I ../../pkg/include  -gdwarf-3 -O0 -Wno-unused-variable  -x c++ mjm_biom_to_rag.h  -o mjm_biom_to_rag.out -lpthread -lreadline


// Fri Jul 29 14:17:18 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_biom_to_rag   
// g++  -Wall -std=gnu++11 -DTEST_MJM_BIOM_TO_RAG -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_biom_to_rag.h  -o mjm_biom_to_rag.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_biom_to_rag("mjm_biom_to_rag"
, "  ");

template <class Tr>
class mjm_biom_to_rag 
{
 typedef mjm_biom_to_rag Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;
typedef mjm_wovdb<Tr,StrTy> Tdb;
//typedef mjm_hier_two<Tr> HierUtil;
typedef mjm_mjsonu JsonTy;





public:
mjm_biom_to_rag() {}
~mjm_biom_to_rag() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }

IdxTy load_ragged(Ragged & r, const StrTy & fn, const IdxTy  flags) const
{
//MM_MSG(" using integrated json for xref may not work doh ")
typedef mjm_mjsonu JsonTy;
JsonTy json;
std::ifstream is(fn);
auto pr=json.dirty_parse(is,0);
//Ragged & rn=pr.res;
 r=pr.res;
//MM_ERR(r.dump())
return 0;
}

/*

mjm_biom_to_rag.h85 0|GLOBAL|1||2|id|=|None
1|GLOBAL|1||2|format|=|Biological Observation Matrix 1.0.0
2|GLOBAL|1||2|format_url|=|http://biom-format.org
3|GLOBAL|1||2|generated_by|=|QIIME 1.9.1
4|GLOBAL|1||2|date|=|2022-06-28T20:53:38.891659
5|GLOBAL|1||2|matrix_element_type|=|float
6|GLOBAL|1||2|shape|3|shape|=|77
7|GLOBAL|1||2|shape|3|shape|=|1
8|GLOBAL|1||2|type|=|OTU table
9|GLOBAL|1||2|matrix_type|=|sparse
10|GLOBAL|1||2|data|4||5|data|=|0
11|GLOBAL|1||2|data|4||5|data|=|0
12|GLOBAL|1||2|data|4||5|data|=|4862
13|GLOBAL|1||2|data|4||6|data|=|1
14|GLOBAL|1||2|data|4||6|data|=|0
15|GLOBAL|1||2|data|4||6|data|=|3920
16|GLOBAL|1||2|data|4||7|data|=|2
17|GLOBAL|1||2|data|4||7|data|=|0
18|GLOBAL|1||2|data|4||7|data|=|3833

239|GLOBAL|1||2|data|4||81|data|=|0
240|GLOBAL|1||2|data|4||81|data|=|12
241|GLOBAL|1||2|rows|82||83|id|=|seq1
242|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|k__Bacteria
243|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|p__Firmicutes
244|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|c__Clostridia
245|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|o__Clostridiales
246|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|f__NA
247|GLOBAL|1||2|rows|82||83|metadata|84|taxonomy|85|taxonomy|=|g__NA
marchywka@happy:/home/documents/cpp/proj/zymo$ 

*/
// this is an F, the irst entry is a sequence number that can be
// arbitrary F 
IdxTy parse_to_ragged_af(Ragged & d, const Ragged & r,  const IdxTy  flags) const
{
const IdxTy ssz=r.size();
StrTy fk="";
IdxTy rc=0;
IdxTy pc=0;
Ragged::Line dl;
for(IdxTy i=0; i<ssz; ++i)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
{StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(MMPR3(i,len,w)) } 
if (len<6)
{
StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(MMPR3(i,len,w))
continue;
}// len
const bool data_line=((len>7)&&(l[len-3]=="data")&& (l[len-7]=="data"));
const bool id_line=((l[len-3]=="id")&&(l[4]=="rows"));
const bool row_line=((len>7)&&(l[4]=="rows"));
if (i==0) if (id_line) continue; 

const StrTy fkc=row_line?l[7]:l[len-4];
MM_ERR(MMPR(id_line)<<MMPR4(data_line,row_line,fkc,fk))
if (data_line)
{
if (fkc!=fk) {  if (dl.size()) d.push_back(dl); dl.clear(); fk=fkc;}
dl.push_back(l[len-1]);
continue;
} // data_line
if (row_line||id_line)
{
MM_ERR(MMPR2(fk,fkc)<<MMPR3(i,dl.size(),pc)) 
if (fkc!=fk) {
if (dl.size()) {  d.push_back(dl); dl.clear();} // transition 
 else  ++pc;   // don't do this first time.. 

fk=fkc;}
d[pc].push_back(l[len-1]);
{
StrTy w; MM_LOOP(jj,d[pc]) { w+=" "+(*jj); } 
MM_ERR(" growing  "<<MMPR3(pc,d[pc].size(),w))


}
continue;
} // row_line
StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(" nothing line "<<MMPR(w))

} // i 

return 0;
}// parse_to_ragged_af
IdxTy parse_to_ragged(Ragged & d, const Ragged & r,  const IdxTy  flags) const
{
std::vector< std::vector<StrTy> >  dfick,seqfick;
const IdxTy ssz=r.size();
StrTy fk="";
IdxTy rc=0;
IdxTy pc=0;
Ragged::Line dl,shtss;
for(IdxTy i=0; i<ssz; ++i)
{
const Ragged::Line & l=r[i];
const IdxTy len=l.size();
{StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(MMPR3(i,len,w)) } 
if (len<6)
{
StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(MMPR3(i,len,w))
continue;
}// len
const bool data_line=((len>7)&&(l[len-3]=="data")&& (l[len-7]=="data"));
const bool id_line=((l[len-3]=="id")&&(l[4]=="rows"));
const bool row_line=((len>7)&&(l[4]=="rows"));
if (i==0) if (id_line) continue; 

const StrTy fkc=row_line?l[7]:l[len-4];
MM_ERR(MMPR(id_line)<<MMPR4(data_line,row_line,fkc,fk))
if (data_line)
{
if (fkc!=fk) {  if (dl.size()) dfick.push_back(dl); dl.clear(); fk=fkc;}
dl.push_back(l[len-1]);
continue;
} // data_line
if (row_line||id_line)
{
MM_ERR(MMPR2(fk,fkc)<<MMPR3(i,dl.size(),pc)) 
if (fkc!=fk) {
if (dl.size()) {  dfick.push_back(dl); dl.clear();} // transition 
 else{  ++pc;   // don't do this first time.. 
if (shtss.size()) seqfick.push_back(shtss);
shtss.clear();
}
fk=fkc;}
shtss.push_back(l[len-1]);
{
//StrTy w; MM_LOOP(jj,d[pc]) { w+=" "+(*jj); } 
//MM_ERR(" growing  "<<MMPR3(pc,d[pc].size(),w))


}
continue;
} // row_line
StrTy w; MM_LOOP(jj,l) { w+=" "+(*jj); } 
MM_ERR(" nothing line "<<MMPR(w))

} // i 
if (shtss.size()) seqfick.push_back(shtss);
MM_LOOP(ii,dfick)
{
Ragged::Line ass;
const IdxTy ns=atoi((*ii)[0].c_str());
MM_LOOP(jj,(*ii)) ass.push_back(*jj);
MM_LOOP(jj,seqfick[ns]) ass.push_back(*jj);
d.push_back(ass);

} // ii

return 0;
}// parse_to_ragged





private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// MEMBERS



}; // mjm_biom_to_rag

//////////////////////////////////////////////

template <class Tr>
class mjm_biom_to_rag_map : public std::map<typename Tr::StrTy, mjm_biom_to_rag< Tr > >  
{
 typedef mjm_biom_to_rag_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_biom_to_rag< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_biom_to_rag_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_biom_to_rag_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BIOM_TO_RAG
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_biom_to_rag <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BIOM_TO_RAG "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_biom_to_rag<Tr>  Myt;
//Myt x(argc,args);
Myt x;
typedef mjm_ragged_table Ragged;
Ragged r,s,d;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") {
r.clear();
 x.load_ragged(r,cip.p1,atoi(cip.p2.c_str())); 
MM_MSG(r.dump());
} // load 
//else if (cmd=="clear") { x.clear(); }
else if (cmd=="b2r") {
r.clear();
d.clear();
 x.load_ragged(r,cip.p1,atoi(cip.p2.c_str())); 
//IdxTy parse_to_ragged(Ragged & d, const Ragged & r,  const IdxTy  flags) const
x.parse_to_ragged(d,r,0);
MM_MSG(d.dump());
std::ofstream ofs(cip.wif(3));
ofs<<d.dump_ssv();
}// b2r

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BIOM_TO_RAG_H__ 
