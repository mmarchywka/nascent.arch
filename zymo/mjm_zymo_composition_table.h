#ifndef MJM_ZYMO_COMPOSITION_TABLE_H__
#define MJM_ZYMO_COMPOSITION_TABLE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_wovdb.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_choices_abbrv.h"
#include "mjm_indexed_ragged.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Feb 24 14:52:09 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_zymo_composition_table   
// g++  -Wall -std=gnu++11 -DTEST_MJM_ZYMO_COMPOSITION_TABLE -I. -I../../mjm/hlib -I../../mjm/num -I../toobib  -gdwarf-3 -O0  -x c++ mjm_zymo_composition_table.h  -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_zymo_composition_table("mjm_zymo_composition_table"
, "Zymo Research composition table reader    ");

template <class Tr>
class mjm_zymo_composition_table 
{
 typedef mjm_zymo_composition_table Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef mjm_choices_abbrv<Tr> Abbrv;

typedef mjm_indexed_ragged<Tr> Annotation;

public:
mjm_zymo_composition_table() {}
~mjm_zymo_composition_table() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }

IdxTy sync_notes(const IdxTy flags=0)
{
std::vector<StrTy> nn;
nn.push_back("k");
nn.push_back("p");
nn.push_back("c");
nn.push_back("o");
nn.push_back("f");
nn.push_back("g");
nn.push_back("s");
m_notes.load(m_r,nn,2); 
return 0;
}
IdxTy load_notes(const StrTy& fn, const IdxTy flags)
{
const bool include_class= (Bit(flags,0));
// load(const StrTy fn, const Names& nidx, const IdxTy flags)
typedef std::vector<StrTy> GS;
GS gs; 

if (include_class) gs.push_back("class");
gs.push_back("genus"); gs.push_back("species");
m_notes.load(fn,gs,flags);
MM_ERR(MMPR(m_notes.size()))
return 0;
}
IdxTy merge(const Myt& that, const IdxTy flags)
{ return  m_notes.merge(that.m_notes,flags); } 
IdxTy load(const StrTy& fn, const IdxTy flags)
 { return  Load( fn,  flags); } 
IdxTy save(const StrTy& fn, const StrTy & loofn,const IdxTy flags)
 { return  Save( fn, loofn,  flags); } 
IdxTy save_gs(const StrTy& fn,const IdxTy flags)
 { return  SaveGS( fn,   flags); } 
IdxTy save_ssv(const StrTy& fn,const IdxTy flags=0)
{
std::ofstream f(fn);
f<<m_r.dump_ssv();
return 0; 
}
IdxTy save_notes_ssv(const StrTy& fn,const IdxTy flags=0)
{
std::ofstream f(fn);
f<<m_notes.dump_ssv();
return 0; 
}



private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; ss<<m_r.dump(flags);  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
IdxTy SaveGS(const StrTy &  fn, const IdxTy flags=0)
{ 
const bool include_values=Bit(flags,0);
const bool include_class=Bit(flags,1);
std::ofstream os(fn);
MM_LOOP(ii,m_r)
{
const IdxTy len=(*ii).size();
if (include_class ) os<<(*ii)[2]<<" ";
os<<(*ii)[5]<<" "<<(*ii)[6];
if (include_values){  for(IdxTy i=7; i<len; ++i) os<<" "<<(*ii)[i]; } 
os<<CRLF;

}

return 0; 
} // SaveGS
IdxTy Save(const StrTy &  fn, const StrTy & loofn,const IdxTy flags=0)
{
Ragged::latex_out_options loo;
loo.load(loofn);
loo.m_max=45;
loo.m_pad_size=6;
Blob b;
b=m_r.dump_latex(256,loo);
b.save(fn);
return 0;
} // Save
template <class Ty> 
IdxTy SameLevel(const Ty & a, const Ty & b )
{
IdxTy i=0;
const IdxTy sza=a.size();
const IdxTy szb=b.size();
const IdxTy sz=(sza<szb)?sza:szb;
while (i<sz)
{
if (a[i]!=b[i]) return i;
++i;
}  
return i; 
} // SameLevel


typedef std::map<IdxTy,char>  Htax;
IdxTy LoadOnly(Ragged & s, const StrTy &  fn, Htax & htax, IdxTy & nlevels, IdxTy & nvalues,const IdxTy flags=0)
{
const bool keep_zed=Bit(flags,0);
Ragged r;
std::ifstream fk(fn);
r.load_lines(fk);
MM_ERR(MMPR2(fn,r.size()))
for(IdxTy i=0; i<r.size(); ++i)
{
Line lf;
char clast=';';
if (r[i].size()==0) continue; 
const StrTy & l=r[i][0];
char ppc[l.length()+1];
for(IdxTy j=0; j<l.length(); ++j) ppc[j]=l.c_str()[j];
ppc[l.length()]=0;
char * p =&ppc[0];
if (*p=='#') continue;
while (*p) { 
// assume even if tsv that leading white can be space.. 
while ((*p==' ')||(*p=='\t')) ++p;
const char * pstart=p;
//MM_ERR("WTF "<< MMPR3(lf.size(),pstart,int(*pstart)))
if ((*pstart)==0) break; 
//while ((*p!=' ')&&(*p!='\t')&&(*p!=0)&&(*p!=';')) ++p;
// its  tab sep with included spaces for  sthi 
while ((*p!='\t')&&(*p!='\t')&&(*p!=0)&&(*p!=';')) ++p;
char cc=*p;
*p=0;
if (cc!=';') if (clast==';') nlevels=lf.size();
if (clast!=';')
{
Ss ss;
const double v=100.0*atof(pstart);
//if (v!=0 ) ss<<std::scientific<<std::setprecision(3)<<v; // atof(pstart);
if (v!=0 ) ss<<std::defaultfloat<<std::setprecision(3)<<v; // atof(pstart);
else if (keep_zed) ss<<v;
lf.push_back(ss.str());
}
//MM_ERR(MMPR3(lf.size(),pstart,int(*pstart)))
else if (pstart!=p)
{
const IdxTy ls=strlen(pstart);
if (ls>3) if ((*pstart)==htax[lf.size()]) if (*(pstart+1)=='_') if (*(pstart+2)=='_') pstart+=3;
 lf.push_back(pstart);
}
*p=cc;
clast=cc;
if ( *p) ++p;
}  // while p 
s.push_back(lf); 

} // i
return 0;
} // LoadOnly

IdxTy Load(const StrTy &  fn, const IdxTy flags=0)
{
const bool use_abbreviations=Bit(flags,0);
const bool hier=Bit(flags,1);
const bool use_headers=!Bit(flags,2);
const bool load_only=Bit(flags,3);
const bool include_class=Bit(flags,4);
MM_ERR(MMPR4(fn, use_abbreviations, hier,use_headers)<<MMPR2(load_only,include_class))
Htax htax;
IdxTy ps=0;
htax[ps++]='k';
htax[ps++]='p';
htax[ps++]='c';
htax[ps++]='o';
htax[ps++]='f';
htax[ps++]='g';
htax[ps++]='s';
Ragged::Line redund;
IdxTy nlevels=0;
IdxTy nvalues=0;
Ragged r,s;
LoadOnly(r,fn,htax,nlevels,nvalues,load_only?1:0);
MM_ERR(" done loading "<<MMPR(r.size()))
if (load_only ) {
//if (use_abbreviations)  Abbreviate(r,htax.size()-1,2);
if (use_abbreviations)  Abbreviate(r,htax.size()-1,0);
 m_r=r; return 0; 
} // load_only

for(IdxTy i=0; i<r.size(); ++i)
{
Line lf=r[i];;

if (s.size()==0)
{
if (use_headers){
if (hier)
{
Line lhdr; // =lf;
IdxTy hmax=5;
IdxTy hi=0;
MM_LOOP(ii,htax) 
{ Ss ss; ss<<(*ii).second;  lhdr.push_back(ss.str());
++hi;
if (hi>=hmax) break; 
}
s.add(lhdr);
lhdr.clear();
lhdr.push_back(StrTy());
hi=0;
MM_LOOP(ii,htax) { 
++hi;
if (hi<=hmax) continue; 
Ss ss; ss<<(*ii).second;  lhdr.push_back(ss.str());
}
for(IdxTy k=htax.size(); k<lf.size(); ++k ) { Ss ss; ss<<"sample "<<(k-htax.size()) ;  lhdr.push_back(ss.str());}
s.add(lhdr);


} else { // hier
Line lhdr=lf;
MM_LOOP(ii,htax) { Ss ss; ss<<(*ii).second;  lhdr[(*ii).first]=ss.str();}
for(IdxTy k=htax.size(); k<lf.size(); ++k ) { Ss ss; ss<<"sample "<<(k-htax.size()) ;  lhdr[k]=ss.str();}
s.add(lhdr);
} // hier

} // use_headers
} // size==0


MM_ERR(MMPR4(lf.size(),nvalues,nlevels,lf.size()-nvalues))
//for(int  j=0; j<int (lf.size()-nvalues); ++j)
for(int  j=0; j<= int (nlevels); ++j)
{
const IdxTy sz=lf[j].length();
char c[6*sz+1];
const char * cs=lf[j].c_str();
memcpy(c,lf[j].c_str(),sz+1);
for(IdxTy k=0; k<sz; ++k){  if (c[k]=='-') c[k]=' '; } 
IdxTy pc=0;
while (*cs) { 
if (*cs=='-')
{  const char * cd=" \\par "; 
while (*cd){ c[pc]=*cd; ++pc; ++cd;       } 
}
else{ c[pc]=*cs; ++pc;}
++cs;
} // cs
c[pc]=0;

//MM_ERR("WTF"<<MMPR3(lf[j],c,sz))
lf[j]=StrTy(c);

} // j 
if (hier)
{
IdxTy hleve=SameLevel(redund,lf);
if (hleve<5) // add a new hier line 
{
Ragged::Line xx;
//for(IdxTy k=5; k<lf.size(); ++k) xx.push_back(lf[k]);
//redund.clear();
for(IdxTy k=0; k<5; ++k){  xx.push_back(lf[k]); }
redund=xx;
s.add(xx);
} // same
Ragged::Line xx;
xx.push_back(StrTy());
for(IdxTy k=5; k<lf.size(); ++k) xx.push_back(lf[k]);

const StrTy classs=redund[2];
const StrTy genus=xx[1];
const StrTy species=xx[2];
Annotate(xx,classs,genus,species,flags);
s.add(HighlightGS(xx,1));

} // hier 
else
{
const StrTy classs=lf[2];
const StrTy genus=lf[5];
const StrTy species=lf[6];
Annotate(lf,classs,genus,species,flags);

 s.add(HighlightGS(lf,0));
}

} /// i 
//if ( !hier) s.hdrs(1);
if (use_headers)  s.hdrs(hier?2:1);
if (use_abbreviations) if (nlevels>2) Abbreviate(s,nlevels-1);
//MM_ERR(s.dump_latex())
MM_ERR(" loaded "<<MMPR(s.size()))


m_r=s;
return 0; 
} // Load
IdxTy Annotate(Ragged::Line & l, const StrTy & classs,const StrTy & g, const StrTy & s, const IdxTy flags )
{
const bool include_class=Bit(flags,4 );
MM_ERR("WTF "<<MMPR4(include_class,classs,g,s))
StrTy x="";
// species could be of the form x-y which has been changed
// to x \\par y ... 
const IdxTy len=s.length();
char c[len+2];
memcpy(c,s.c_str(),len);
c[len]=0;
 char * cp=c;
 char * s0=cp;
bool done=false;
while (true)
{
if (*cp==0) done=true;
if (*cp==' ' ) *cp=0;
if (*cp==0) { 
MM_ERR( " looking up "<<MMPR4(include_class,classs,g,s0))
auto ns=include_class?m_notes.find(classs,g,s0,0):m_notes.find(g,s0,0);
MM_LOOP(ii,ns) x=x+(*ii);
if (done) break;
s0=cp+1;
}
++cp;
} // while 

if (x.length()) l.push_back(x);

return 0;
} // Annotate

Ragged::Line  HighlightGS(Ragged::Line & l, const IdxTy flags)
{
MM_SZ_LOOP(i,l,sz)
{
bool h=(flags==0) && ((i==5)||(i==6)) ;
h|=(flags==1) && ((i==1)||(i==2)) ;

if (h) l[i]="\\bf{"+l[i]+"}";

} // i 

return l;
} // HighlightGS
IdxTy Abbreviate(Ragged & s,const IdxTy nlevels, const IdxTy flags=0)
{
const bool adapt_len=Bit(flags,0);
const bool bare_min=Bit(flags,1);
Abbrv ab;
const IdxTy sz=s.size();
const IdxTy lenminzed=5; // lenminzed;
IdxTy lenmin=lenminzed;
for(IdxTy i=0; i<nlevels; ++i)
{
if (adapt_len)
{
lenmin=4; // lenminzed;
if ( i==0) lenmin=2;

}
if (bare_min) lenmin=1;
std::map<StrTy, StrTy> m;
std::vector<StrTy> list;
for(IdxTy j=s.hdrs(); j<sz; ++j)
{
if ( s[j].size()<=i) continue;
list.push_back(s[j][i]);
} // j 
ab.abbreviate(m,list,lenmin,0);

for(IdxTy j=s.hdrs(); j<sz; ++j)
{
if ( s[j].size()<=i) continue;
if (m.find(s[j][i])!=m.end()) s[j][i]=m[s[j][i]];
} // j 

MM_LOOP(ii,m){ MM_ERR(" xlate "<<MMPR4(i,m.size(),(*ii).first,(*ii).second))}

} // i 
return 0;
} // Abbrv

// MEMBERS
Ragged m_r;
Annotation m_notes;

}; // mjm_zymo_composition_table

//////////////////////////////////////////////

template <class Tr>
class mjm_zymo_composition_table_map : public std::map<typename Tr::StrTy, mjm_zymo_composition_table< Tr > >  
{
 typedef mjm_zymo_composition_table_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_zymo_composition_table< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_zymo_composition_table_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_zymo_composition_table_map




////////////////////////////////////////////
#ifdef  TEST_MJM_ZYMO_COMPOSITION_TABLE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_zymo_composition_table <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_ZYMO_COMPOSITION_TABLE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_zymo_composition_table<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="load_notes") { x.load_notes(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="save") { x.save(cip.p1,cip.p2,0); }
else if (cmd=="save_gs") { x.save_gs(cip.p1,atoi(cip.p2.c_str())); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_ZYMO_COMPOSITION_TABLE_H__ 
