#ifndef MJM_RAG_REDUCE_H__
#define MJM_RAG_REDUCE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_wovdb.h"
#include "mjm_strings.h"
#include "mjm_loo_parsing.h"




#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Jul 30 07:40:01 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_rag_reduce   
// g++  -Wall -std=gnu++11 -DTEST_MJM_RAG_REDUCE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_rag_reduce.h  -o mjm_rag_reduce.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_rag_reduce("mjm_rag_reduce"
, "  ");

template <class Tr>
class mjm_rag_reduce 
{
 typedef mjm_rag_reduce Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef Ragged::Word Word;
typedef mjm_ragged_cursor RaggedCursor;
typedef mjm_wovdb<Tr,StrTy> Tdb;

typedef mjm_loo_parsing<Tr> Loo;

/*
biom expands to serial, sample, counts, OTU 
need to merge... 
4 0 4565 seq6 k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Po
rphyromonadaceae g__Porphyromonas s__cangingivalis
5 1 3673 seq7 k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Po
rphyromonadaceae g__Porphyromonas s__gulae
6 1 3435 seq8 k__Bacteria p__Firmicutes c__Clostridia o__Clostridiales f__Lachno
spiraceae g__Lachnoclostridium s__sp32345
*/

class _reduce_params
{
public:
typedef std::vector<StrTy> OpS;
typedef std::vector<IdxTy> OpD;
typedef std::vector<IdxTy> ColVec;
//list each line that has key in OpS 
typedef std::map<OpS,OpD> Didx;
_reduce_params() {}
_reduce_params(const StrTy & s ) {Init(s);}

void Init(const StrTy & s ) {
enum { K=0, S=1};
IdxTy vector=K;
OpS opr;
OpD opd;
Ragged t;
t.load_params(7,0," ");
Ss ss(s); 
t.load(ss,true);
MM_LOOP(ii,t)
{
MM_LOOP(jj,(*ii))
{
MM_ERR(MMPR((*jj)))
const StrTy & k=(*jj);
const char * cs=k.c_str();
char * cp=0;
IdxTy n=strtol(cs,&cp,0);
if (cp!=cs) if (cp!=0) { opd.push_back(n); continue;  }
opr.push_back(k);
 } // jj 
} // ii
OpD range;
while ( opr.size())
{
const StrTy v=opr.back();
opr.pop_back();
// change to a hypehn for normal people? 
//if (v==":")
if (v=="-")
{
const IdxTy e=opd.back(); opd.pop_back();
const IdxTy s=opd.back(); opd.pop_back();
for(IdxTy i=s; i<=e; ++i) range.push_back(i); 
continue;
} // colon
if (v==",")
{

} // comma
if (v=="K") { 
if (range.size()==0) { if (opd.size()) { range.push_back(opd.back()); opd.pop_back();} else MM_ERR("no range ") } 
MM_LOOP(ii,range) { m_key.push_back(*ii); } range.clear(); continue; }  
if (v=="S") {
if (range.size()==0) { if (opd.size()) { range.push_back(opd.back()); opd.pop_back();} else MM_ERR("no range ") } 

 MM_LOOP(ii,range) { m_sum.push_back(*ii); } range.clear(); continue; }  
}// opr
if ( opd.size())
{
MM_ERR(" operands left "<<MMPR(opd.size()))
Ss ss;
Loo::Dump(ss, StrTy("opd"),opd,0);
Loo::Dump(ss, StrTy("opr"),opr,0);

} 
MM_ERR(MMPR(dump()))
} // Init
StrTy dump()
{
Ss ss;
Loo::Dump(ss, StrTy("sum"),m_sum,0);
Loo::Dump(ss, StrTy("key"),m_key,0);
return ss.str();
}

ColVec m_sum, m_key;

}; // _reduce_params


typedef _reduce_params ReduceParam;
public:
mjm_rag_reduce() {}
~mjm_rag_reduce() {}
IdxTy reduce(Ragged & d, const Ragged & s, const StrTy & rps, const IdxTy flags)
{ return reduce(d,s,ReduceParam(rps),flags); } 
IdxTy reduce(Ragged & d, const Ragged & s, const ReduceParam & rp, const IdxTy flags)
{ return Reduce(d,s,rp,flags);
}
IdxTy merge(Ragged &d, const Ragged & o1, const Ragged & o2, const IdxTy flags)
{ return Merge(d,o1,o2,flags); }
template<class Ty>
IdxTy merge(Ragged &d, const Ty & olist, const IdxTy flags)
{ return Merge(d,olist,flags); }


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// The summed format is like
// sum of sequences, sample, counts, OTU 
// 42 0 110 k__Bacteria p__Firmicutes c__Erysipelotrichia o__Er
// reduced may have sample number and other crap in differing locations
// should ahve param for this... 
// return count vector OTU vector 
class _merge_info
{
public:
_merge_info(): kstart(0),ccol(0),scol(0) {}
IdxTy kstart,ccol,scol;
}; // _merge_info
typedef _merge_info MergeInfo;

IdxTy Merge(Ragged &d, const Ragged & o1, const Ragged & o2, const IdxTy flags)
{
typedef typename ReduceParam::Didx Didx;
Didx didx;

const IdxTy kstart1=3;
const IdxTy kstart2=3;
const IdxTy ccol1=0;
const IdxTy ccol2=0;
const IdxTy scol1=2;
const IdxTy scol2=2;

//18133 530 0 k__Bacteria p__Fusobacteria c__Fusobacteriia o__Fusobacteriales f__Fusobacteriaceae g__Fusobacterium
//6590 1 0 k__Bacteria p__Firmicutes c__Clostridia o__Clostridiales f__Clostridiaceae g__Clostridium

const IdxTy ns1=SampleCount(o1,scol1,0);
const IdxTy ns2=SampleCount(o2,scol2,0);
const IdxTy ns=ns1+ns2;
MM_ERR(MMPR2(o1.size(),o2.size()))
MM_ERR(MMPR3(ns1,ns2,ns))
MergeInfo mi;
mi.kstart=kstart1;
mi.ccol=ccol1;
mi.scol=scol1;

MergeOne(d,o1,didx,ns,0,mi,0);

mi.kstart=kstart2;
mi.ccol=ccol2;
mi.scol=scol2;
MergeOne(d,o2,didx,ns,ns1,mi,0);

/*
MM_LOOP(ii,o1)
{
Line key; // dest(dsz);
const Line & l=(*ii);
const IdxTy len=l.size();
for(IdxTy i=kstart1; i<len; ++i) { key.push_back(l[i]); }
Line dest(ns+key.size());
typename ReduceParam::OpD&  im=didx[key];
if (im.size()==0) { im.push_back(d.size()); MM_SZ_LOOP(i,key,ksz) dest[ns+i]=key[i];  d.push_back(dest);} 
const IdxTy sample=strtol(l[scol1].c_str(),0,0);
const IdxTy dcount=strtol(l[ccol1].c_str(),0,0);
StrTy & v=l[sample];
const IdxTy ccount=strtol(v.c_str(),0,0);
Ss ss; ss<<(ccount+dcount); v=ss.str();
} // ii 
*/
return 0;
} // Merge 

template<class Ty>
IdxTy Merge(Ragged &d, const Ty & olist, const IdxTy flags)
{ 
const bool add_headers=Bit(flags,2);
typedef typename ReduceParam::Didx Didx;
Didx didx;

const IdxTy kstart1=3;
const IdxTy kstart2=3;
const IdxTy ccol1=0;
const IdxTy ccol2=0;
const IdxTy scol1=2;
const IdxTy scol2=2;
if (add_headers) d.push_back(Line());
std::vector<IdxTy> samples;
MM_LOOP(ii,olist) samples.push_back(SampleCount(*ii,scol1,0));  
IdxTy ns=0; MM_LOOP(ii,samples) ns+=(*ii); 
// this needs to know how many keys for the header... 
MergeInfo mi;
mi.kstart=kstart1;
mi.ccol=ccol1;
mi.scol=scol1;
IdxTy mmks=0;
IdxTy offset=0;
auto oo=olist.begin();
MM_LOOP(ii,samples)
{
IdxTy mks=MergeOne(d,(*oo),didx,ns,offset,mi,0);
if ( mks>mmks) mmks=mks;
MM_ERR(MMPR2(offset,(*ii)))
offset+=(*ii);
++oo;
} // ii
if (add_headers)
{
Line  l;//  =d[0];
IdxTy j=0;
auto jj=olist.begin();
MM_LOOP(ii,samples)
{
Ss ss; ss<<(*jj).name()<<"-"<<j; const StrTy base=ss.str();
const IdxTy n=(*ii);
for(IdxTy i=0; i<n; ++i)
	{ Ss ss; ss<<"Run "<<base<<"/"<<i; l.push_back(ss.str()); } // i 
++j;
++jj;
} // ii 
for(IdxTy i=0; i<mmks; ++i)
{
Ss ss; ss<<"key "<<i ; const StrTy base=ss.str();
l.push_back(ss.str()); 
} // i 

d[0]=l;
} // add_headers

return 0;
} // Merge 3 param 


template <class Td> 
IdxTy MergeOne(Ragged &d, const Ragged & o1, Td & didx, const IdxTy ns, const IdxTy noff, const MergeInfo & mi,   const IdxTy flags)
{
IdxTy maxkey=0;
MM_LOOP(ii,o1)
{
Line key; // dest(dsz);
const Line & l=(*ii);
const IdxTy len=l.size();
for(IdxTy i=mi.kstart; i<len; ++i) { key.push_back(l[i]); }
Line dest(ns+key.size());
typename ReduceParam::OpD&  im=didx[key];
if (im.size()==0) { im.push_back(d.size()); 
for(IdxTy i=0; i<ns; ++i) dest[i]="0"; 
MM_SZ_LOOP(i,key,ksz) dest[ns+i]=key[i];  
// onlyu check on new keys..
if (ksz>maxkey) maxkey=ksz;
d.push_back(dest);} 
const IdxTy sample=strtol(l[mi.scol].c_str(),0,0);
const IdxTy dcount=strtol(l[mi.ccol].c_str(),0,0);
const StrTy v=d[im[0]][sample+noff];
const IdxTy ccount=strtol(v.c_str(),0,0);
MM_ERR(MMPR(noff)<<MMPR4(sample,dcount,v,ccount))
Ss ss; ss<<(ccount+dcount); 
d[im[0]][sample+noff]=ss.str();
} // ii 

return maxkey;
} // MergeOne

IdxTy SampleCount(const Ragged & r, const IdxTy col, const IdxTy flags)
{
// use signed hopefully make gt work lol. 
int n=-1;
const IdxTy rsz=r.size();
// want to unroll the first iter to avoid if i==0 but let
// compiler do that lol 
if (rsz==0) return 0;

for(IdxTy i=0; i<rsz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (col>=len)
{
Ss ss; MM_LOOP(ii,l){ ss<<(*ii)<<" "; }
MM_ERR(" too short "<<MMPR4(col,len,i, ss.str()))
continue;
}
const int  v=strtol(l[col].c_str(),0,0);
if (v>n) n=v;
} // i 
return n+1;
} // MaxColVal


IdxTy Reduce(Ragged & d, const Ragged & s, const ReduceParam & rp, const IdxTy flags)
{
typedef typename ReduceParam::ColVec Cv;
typedef typename ReduceParam::Didx Didx;
const  Cv & keys=rp.m_key;
const  Cv & sums=rp.m_sum;
Didx didx;
const IdxTy dsz=keys.size()+sums.size();
MM_LOOP(ii,s)
{
const Line & l=(*ii);
Line key,dest(dsz);
/*
keys can be short
101	99 1 285 seq101 None
   102	100 1 268 seq102 k__Bacteria p__Firmicutes c__Clostridia o__Clostridiale
s f__Lachnospiraceae g__NA s__sp33422
   103	
*/


MM_LOOP(jj,keys) {if ((*jj)<l.size())  key.push_back(l[*jj]); } 
typename ReduceParam::OpD&  im=didx[key];
if (im.size()==0)
{
im.push_back(d.size());
MM_SZ_LOOP(ix,keys,kdz) {if ( keys[ix]<l.size())  dest[sums.size()+ix]=l[keys[ix]]; } 
d.push_back(dest);
}
Line & lt=d[im[0]];
IdxTy ik=0;
MM_LOOP(jj,sums) // first few ones.. 
{
Ss ss;
D f=atof(l[(*jj)].c_str())+atof(lt[ik].c_str());
ss<<f;
lt[ik]=ss.str();
++ik;
} // jj  

} // ii 


return 0; 
} // Reduce
// MEMBERS



}; // mjm_rag_reduce

//////////////////////////////////////////////

template <class Tr>
class mjm_rag_reduce_map : public std::map<typename Tr::StrTy, mjm_rag_reduce< Tr > >  
{
 typedef mjm_rag_reduce_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_rag_reduce< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_rag_reduce_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_rag_reduce_map




////////////////////////////////////////////
#ifdef  TEST_MJM_RAG_REDUCE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_rag_reduce <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_RAG_REDUCE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_rag_reduce<Tr>  Myt;
//Myt x(argc,args);
Myt x;
typedef mjm_ragged_table Ragged;
//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump())  continue; }
if (cmd=="reduce") { 
Ragged d,s;
s.load(cip.p2);
IdxTy rc=x.reduce(d,s,cip.wif(3),0);
MM_ERR(d.dump())
std::ofstream ofs(cip.p1);
ofs<<d.dump_ssv();

} // reduce 
if (cmd=="merge") { 
Ragged d,s,t;
s.load(cip.p2);
t.load(cip.wif(3));
IdxTy rc=x.merge(d,s,t,0);
MM_ERR(d.dump())
std::ofstream ofs(cip.p1);
ofs<<d.dump_ssv();

} // reduce 


//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_RAG_REDUCE_H__ 
