#ifndef MJM_CURSING_VIEWER_H__
#define MJM_CURSING_VIEWER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_2d_states.h"



////////////////////////////////////////////
#ifdef  TEST_MJM_CURSING_VIEWER
#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
#endif

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <string.h>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <ncurses.h>


// Thu May 30 15:39:12 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_cursing_viewer   
// g++ -std=gnu++11 -DTEST_MJM_CURSING_VIEWER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_cursing_viewer.h  -lpthread -lreadline -lncurses

//https://stackoverflow.com/questions/1022957/getting-terminal-width-in-c

// SIGWINCH is called when the window is resized.
void handle_winch(int sig){
  signal(SIGWINCH, SIG_IGN);

  // Reinitialize the window to update data structures.
  endwin();
  initscr();
  refresh();
  clear();

  char tmp[128];
  sprintf(tmp, "%dx%d", COLS, LINES);

  // Approximate the center
  int x = COLS / 2 - strlen(tmp) / 2;
  int y = LINES / 2 - 1;

  mvaddstr(y, x, tmp);
  refresh();

  signal(SIGWINCH, handle_winch);
}





template <class Tr>
class mjm_cursing_viewer 
{
 typedef mjm_cursing_viewer Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
enum { BAD=~0 } ; 

class screen_string_xlate
{
typedef screen_string_xlate Myt;
public:
static IdxTy bad()  { return ~0; } 
screen_string_xlate(): m_x(bad()),m_y(bad()),m_pos(bad()),m_valid(0) {}
screen_string_xlate(const IdxTy x, const IdxTy y, const IdxTy p ): m_x(x),m_y(y),m_pos(p),m_valid(1) {}
IdxTy pos() const { return m_pos; } 
IdxTy x() const { return m_x; } 
IdxTy y() const { return m_y; } 
bool valid() const { return m_valid!=0; }
private:
IdxTy m_x,m_y;
IdxTy m_pos;
IdxTy m_valid;
}; // screen_string_xlate

class ss_xlate_collection
{

typedef  ss_xlate_collection Myt;

typedef  screen_string_xlate Rec;
// this makes two copies of the record should use pointers etc. 
// screen is finite size, use 2D array 
typedef std::vector< Rec> FIdx;
typedef std::vector<  std::vector< Rec> > RIdx;
typedef mjm_2d_states<Tr,IdxTy> ScreenPos;



public:
ss_xlate_collection() : m_rs(BAD) {}

static IdxTy bad() { return BAD; } 
IdxTy get(const IdxTy x, const IdxTy y)const  {  return Get(x,y); }
//IdxTy get(const IdxTy pos) {  return Get(pos); }
IdxTy get(IdxTy&  x, IdxTy& y, const IdxTy p)const  {  return Get(x,y,p); }
IdxTy set(const IdxTy x, const IdxTy y, const IdxTy p) {  return Set(x,y,p); }
void clear() { m_f.clear(); m_r.clear(); m_rs.clear(); } 
private:
//IdxTy Get(const IdxTy pos) {  
//IdxTy xypos=BAD;
//return xypos; 
//}
IdxTy Get(IdxTy&  x, IdxTy& y, const IdxTy p)const  {  
if (p>=m_f.size()) return BAD;
const Rec & r=m_f[p];
x=r.x();
y=r.y();
return r.valid()?0:BAD ;
}


IdxTy Get(const IdxTy x, const IdxTy y)const  {  

if (true) { return m_rs.state(x,y); } 
IdxTy pos=BAD;
if (x>=m_r.size()) return pos;
const auto&  v=m_r[x];
if (y>=v.size()) return pos;
pos=v[y].pos();
return pos; 


}
// this does not work well for very long strings but can fix later
// could use a map or offset. 
IdxTy Set(const IdxTy x, const IdxTy y, const IdxTy p) {  
const IdxTy szf=m_f.size();
//if (szf<=p){ const IdxTy mask=(1<<10)-1;  m_f.resize( (szf+mask+1)&(~mask));  } 
Ensure(m_f,p,10);
// reverse should just use an x-y arrady
m_f[p]=Rec(x,y,p);

Ensure(m_r,x,7);
Ensure(m_r[x],y,7);

m_r[x][y]=Rec(x,y,p);
m_rs.state(p,x,y);
return 0; 
}
template <class Tv> void Ensure(Tv & v, const IdxTy p, const IdxTy mask=(8) )
{
const IdxTy sz=v.size();
if (sz>p) return; 
const IdxTy mm=1<<mask;
const IdxTy m=(mm)-1;  
v.resize( (sz+mm)&(~m));  } 


FIdx m_f;
RIdx m_r;
ScreenPos m_rs;

}; // ss_xlate_collection

typedef ss_xlate_collection PosTab;

public:
mjm_cursing_viewer() {}
~mjm_cursing_viewer() {}

void display(IsTy & is, const IdxTy flags=0) { Display(is,flags); } 
int  display_and_curse(const StrTy  & s, const IdxTy xi, int & cx, int & cy, const IdxTy flags=0) { return DisplayAndCurse(s,xi,cx,cy,flags); } 

int cursing_pos_tab(IdxTy & ch, IdxTy & pos, int & cx, int & cy,const IdxTy flags ){ return  CursingPosTab( ch,  pos,cx,cy,flags); } 

// return a cursor for string log s 
IdxTy cursor_pos(IdxTy &  x, IdxTy  & y, const IdxTy p)const  { return m_postab.get(x,y,p); } 



int comb(const int ac, const int rc) { return (ac<<16)|rc; } 
int maskrc(const int cc) { return cc&((1<<16)-1); } 
int maskac(const int cc) { return cc>>16; } 



StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// https://github.com/tony/NCURSES-Programming-HOWTO-examples/blob/master/08-attributes/main.c
/* pager functionality by Joseph Spainhour" <spainhou@bellsouth.net> */
//#include <ncurses.h>
//#include <stdlib.h>
int Display(IsTy & is, const IdxTy flags)
{ 
  int ch, prev, row, col;
  prev = EOF;
  FILE *fp;
  int y, x;

  initscr();				/* Start curses mode */
  getmaxyx(stdscr, row, col);		/* find the boundaries of the screeen */
  while(is.good()&&!is.eof() )	/* read the file till we reach the end */
  {
  ch = 255&is.get();/* read the file till we reach the end */
    getyx(stdscr, y, x);		/* get the current curser position */
    if(y == (row - 1))			/* are we are at the end of the screen */
    {
      printw("<-Press Any Key->");	/* tell the user to press a key */
      getch();
      clear();				/* clear the screen */
      move(0, 0);			/* start at the beginning of the screen */
    }
    if(prev == '/' && ch == '*')    	/* If it is / and * then only
                                     	 * switch bold on */    
    {
      attron(A_BOLD);			/* cut bold on */
      getyx(stdscr, y, x);		/* get the current curser position */
      move(y, x - 1);			/* back up one space */
      printw("%c%c", '/', ch); 		/* The actual printing is done here */
    }
    else
      printw("%c", (char)ch);
    refresh();
    if(prev == '*' && ch == '/')
      attroff(A_BOLD);        		/* Switch it off once we got *
                                 	 * and then / */
    prev = ch;
  }
  endwin();                       	/* End curses mode */
//  fclose(fp);
  return 0;
}
// display the string and maintain a string to screen table
int DisplayAndCurse(const StrTy & s, const IdxTy xi, int & cx, int & cy, const IdxTy flags)
{
  m_postab.clear();
  int ch,  row, col;
  int y, x;
// there is something wrong with the alt_display putting in blanks I thought was nucrses fck 
endwin();
  initscr();	
clear();
    refresh();
cbreak(); noecho();
clear();
    refresh();
 int i=xi;			/* Start curses mode */
  getmaxyx(stdscr, row, col);		/* find the boundaries of the screeen */
clear();
move(0,0);
    refresh();
	const IdxTy sz=s.length();
	const char * p=s.c_str();
//  while(is.good()&&!is.eof() )	/* read the file till we reach the end */
 for(; i<sz; ++i)
  {
  ch = p[i];/* read the file till we reach the end */
    getyx(stdscr, y, x);		/* get the current curser position */
    bool done=((y == (row - 1))&&((ch=='\n')||(x==(col-1))));
//      printw("<-Press Any Key->");	/* tell the user to press a key */
//      getch();
//      clear();				/* clear the screen */
//      move(0, 0);			/* start at the beginning of the screen */
	m_postab.set(x,y,i);
      printw("%c", (char)ch);
if (done) break;
  }
    refresh();
//      getyx(stdscr, y, x);		/* get the current curser position */
//move(0,0);
    getyx(stdscr, cy, cx);		/* get the current curser position */
    refresh();
//  endwin();                       	/* End curses mode */
return i;
}
// return key pressed in ch at input string location  pos 
int MoveD(const int dx, const int dy, const int w, const int h)
{
int v=0; 
int x,y;
    getyx(stdscr, y, x);		/* get the current curser position */
x=x+dx;
if (x>=w) {v|=1;  y=y+x/w; x=x%w; }
if (x<0) { v|=2; x=0; }  
y=y+dy;
if ( y>=h) { v|=4;  y=h-1; }
if ( y<0) { v|=8;  y=0; }
move(y,x);
return v;
} 
int CursingPosTab(IdxTy & ch, IdxTy & pos, int & cx, int & cy,const IdxTy flags)
{
int x,y;
    refresh();
  int row, col;
  getmaxyx(stdscr, row, col);		/* find the boundaries of the screeen */
move(cy,cx);
int rc=0;
int ac=0;
while (true)
{
ch=getch();
    getyx(stdscr, y, x);		/* get the current curser position */
switch (ch)
{
case 'h':
case KEY_LEFT: {ac=1;  rc=MoveD(-1,0,col,row); break; } 
case 'l':
case KEY_RIGHT: { ac=2;  rc=MoveD(1,0,col,row); break; } 
case 'k':
case KEY_UP: { ac=3; rc=MoveD(0,-1,col,row); break; } 
case 'j':
case KEY_DOWN: { ac=4;  rc=MoveD(0,1,col,row); break; } 

default:{ ac=5; endwin();  pos=m_postab.get(x,y); return comb(ac,rc); } 
} // switch 
refresh();
// putting this lower make up cursing hang sometimes. 
// if (rc!=0) break;
// this puts in stale values then  if the abv break executres
    getyx(stdscr, cy, cx);		/* get the current curser position */
if (rc!=0) break;
// for now punt each move 
if (true) break;
} // while 
pos=m_postab.get(x,y);
return comb(ac,rc); 
}


StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }


PosTab m_postab;


}; // mjm_cursing_viewer

//////////////////////////////////////////////

template <class Tr>
class mjm_cursing_viewer_map : public std::map<typename Tr::StrTy, mjm_cursing_viewer< Tr > >  
{
 typedef mjm_cursing_viewer_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_cursing_viewer< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_cursing_viewer_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_cursing_viewer_map




////////////////////////////////////////////
#ifdef  TEST_MJM_CURSING_VIEWER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;

void screen_on()
{

initscr();
  // COLS/LINES are now set
  signal(SIGWINCH, handle_winch);
}

void screen_off()
{
  endwin();
}

int main(int argc,char **args)
{
typedef mjm_cursing_viewer<Tr>  Myt;
//Myt x(argc,args);
Myt x;


//  while(getch() != 27){ }

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="on") { screen_on();  }
if (cmd=="off") { screen_off();  }
if (cmd=="disp") { std::ifstream is(cip.p1);    x.display(is);  }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_CURSING_VIEWER_H__ 
