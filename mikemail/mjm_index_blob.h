#ifndef MJM_INDEX_BLOB_H__
#define MJM_INDEX_BLOB_H__


#include "mjm_thread_util.h"

// for default traits
#include "mjm_globals.h"

// added for dumping output in string form even when bin 
// casuing include loops due to commandinterpretter in color_tablr
//#include "mjm_misc_parse.h"


// Wed May  8 19:08:39 EDT 2019
// generated by -classhdr mjm_read_buffer  
// really just a place for concatenating strings but
// expanded for double buffering input

class mjm_index_blob_traits
{
public: 
typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream OsTy;
 typedef std::ofstream Ofs;

}; 

//template <class Tr=mjm_index_blob_traits, class _Ch=char>
template <class Tr=mjm_index_blob_traits, class Td=char>
class mjm_index_blob 
{
 typedef mjm_index_blob Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
//typedef char Ch;
//typedef _Ch Ch;
typedef Td * Tdata;
typedef Td * Ch;
//typedef mjm_misc_parse<Tr> CharLut;

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
enum { MAP_MU=0 , MU_SZ};

enum { DEFAULT_BUFFER_LN2=14};

public:
mjm_index_blob() {Init();}
mjm_index_blob(const IdxTy pad) {Init(); Pad(pad); }
mjm_index_blob(const IdxTy pad, const IdxTy blocks) {Init(); Pad(pad); Expand(blocks*(m_mask+1)); }


//Ch * m_ptr;
//IdxTy m_size,  // total buffer size
//m_inc,  // apparently never used 
//m_pc,  // current write position 
//m_pad,m_mask; // allocation round up 
private:
mjm_index_blob(const Myt & x) {}
Myt & operator=(const Myt & x) {}
public:

~mjm_index_blob() {Release();}
//void load(const StrTy & fn) { Load(fn); } 
void pad(const IdxTy pad, const IdxTy blocks) { Pad(pad); Expand(blocks*(m_mask+1)); }
void clear() { m_pc=0; m_mark.clear(); } 
const IdxTy &  size() const { return m_pc; }  // actually length, used chars 
const IdxTy  space() const  { return m_size-m_pc; } 
const IdxTy  alloc() const  { return m_size; } 
void release()  {LetGo(); } //  Release(); } 
Ch * buf() { return m_ptr; } 
Ch * next() { return m_ptr+m_pc; } 
//void appended(const IdxTy n ) { m_pc+=n; } 
//void append(const Ch _c) { Ch c[2]; c[0]=_c; c[1]=0; Append(c,1); }
// TODO there is no assurance this has an eos 0 or even allocated
// space at this point, not pushing valid string start? 
// put next available location on the mark stack 
void mark_pc() { m_mark.push_back(m_pc); }
// begin a new string with c
//void mark_append(const Ch _c) { m_mark.push_back(m_pc);append(_c); }
// terminate the prior string and start a new one marked on the stack 
//void new_append(const Ch _c) { append(Ch(0)); m_mark.push_back(m_pc);append(_c); }
// append the char to old string, terminate and mark for a new one. 
//void append_new(const Ch _c) {append(_c);  append(Ch(0)); m_mark.push_back(m_pc); }
//void cap() {append(Ch(0));   }
// terminate current string point to a new one. 
//void start_new() {append(Ch(0));   m_mark.push_back(m_pc); }
//void cap() {append(Ch(0));   }
//void append(const StrTy & s) { Append(s.c_str(),s.length()); }
//void mark_append(const StrTy & s) { m_mark.push_back(m_pc);append(s); }
//void new_append(const StrTy & s) {append(Ch(0));  m_mark.push_back(m_pc);append(s); }
// get the most recent string and remove it from the buffer
//StrTy mark_string() { return MarkString(); } 

//void mark() { m_mark.push_back(m_pc); } 
Ch * ptr() { return m_ptr; } 
//void append(const char *  c) { Append(c,strlen(c)); }
void append(const Ch *  c) { Append(c,1); }
//void push_string(const char *  c) {mark();  Append(c,strlen(c)+1); }
//void push_string(const char *  c,const IdxTy sz) {mark();  Append(c,sz);cap(); }
//void append(const char *  c, const IdxTy sz ) { Append(c,sz); }
// this makes the contents into a string for extraction  although
// after all of that should just let caller do StrTy(pt()) lol
// although ctor sthould stupidly be elided.. 
//StrTy string() { m_ptr[m_pc]=0; return StrTy(m_ptr); }
// the first string is not supposed to be marked but
// that may makemore sense , I guess if the first one in m_mark
// is zero that means something and otherwise a null first
// string would have a zero written 
//StrTy string(const IdxTy i ) {if (i==0) return StrTy(m_ptr);  return StrTy(m_ptr+m_mark[i-1]); } 
//StrTy string_sane(const IdxTy i ) {  return StrTy(m_ptr+m_mark[i]); } 
//const Ch *  operator[](const IdxTy i ) {  return (m_ptr+m_mark[i]); } 
const Ch *  operator[](const IdxTy i ) {  return (m_ptr+i); } 
//StrTy last_string( ) {  return string(strings()); } 
//StrTy next_last_string( ) {  return string(strings()-1); } 

//IdxTy strings() { return m_mark.size(); } 
//IdxTy string_count() { return m_mark.size(); } 
//void minimize() { Minimize(); } 
// this needs to use lut printing... 
/*
StrTy dump_char(IdxTy n=0)
{
Ss ss;
const IdxTy max=((n>0)&&(n<m_pc))?n:m_pc;
for(IdxTy i=0; i<n; ++i)
{
const char c=m_ptr[i];
if (c==0) ss<<"\\0";
else ss<<c;

}
return ss.str();
}
*/

private:


mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

void Init()
{
m_ptr=0;
m_pc=0;
m_size=0;
Pad(DEFAULT_BUFFER_LN2);
// there is no string here yet. 
//m_mark.push_back(0); // should subclass to keep this lightweight 
m_mutex_vector = MutexVector(MU_SZ);
}
void Pad(const IdxTy lpad)
{
m_pad=lpad; // 14;
m_mask=(1<<m_pad)-1;

}
#if 0 
StrTy MarkString()
{
// taking a series of these removes from the last mark
// to the prior mark or end. Adding again will append and be taken
// with full buffer or previous mark . 
IdxTy back=m_mark.back();
Ch * b=m_ptr+back;
m_ptr[m_pc]=0;
StrTy x= StrTy(b);
*b=0; // doh added star- TODO FIXME anyone else used this behavior???
m_pc=back+1; // doh overwrite the zero then 
m_mark.pop_back();
return x;

}

void Load(const StrTy & fn) {
std::ifstream f(fn.c_str()); 
// this is really a mask though.. 
const IdxTy psz=m_mask+1;
char p[psz];
while (f.good()&&!f.eof())
{
//IdxTy len= 
f.read(p,psz);
IdxTy len= f.gcount(); // read(p,psz);

Append(p,len);
}

 } 
void Append(const Ch * c, const IdxTy len)
{
IdxTy tgt=m_pc+len+1;
Expand(tgt);
memcpy(m_ptr+m_pc,c,len);
m_pc+=len;
}
#endif
void Append(const Ch * c, const IdxTy len)
{
IdxTy tgt=m_pc+len+1;
Expand(tgt);
memcpy(m_ptr+m_pc,c,len);
m_pc+=len;
}

void Expand(const IdxTy sz)
{
if (sz<=m_size) return;
const IdxTy M=m_mask; // (1<<10)-1;
const IdxTy szx= (sz+M)&(~M); 
if (szx<sz) { MM_ERR(" logic error "<<MMPR2(szx,sz))} 
//else  { MM_ERR(" normal expand  "<<MMPR2(szx,sz))} 
Ch * x= new Ch[szx];
if (m_size!=0)
{
memcpy(x,m_ptr,m_pc);
delete [] m_ptr;
}
m_ptr=x;
m_size=szx;
}
void Minimize()
{
Release(); // should return to our memallocer

}
void Release()
{
delete m_ptr; 
LetGo();
//m_ptr=0;
//m_ptr=0; m_pc=0; m_size=0;
}

void LetGo()
{
m_ptr=0;
m_pc=0;
m_size=0;
}


Ch * m_ptr;
IdxTy m_size,  // total buffer size
m_inc,  // apparently never used 
m_pc,  // current write position 
m_pad,m_mask; // allocation round up 
// subsclass to keep base lightweight

std::vector<IdxTy> m_mark;

}; // mjm_read_buffer

#endif // MJM_READ_BUFFER_H__ 
