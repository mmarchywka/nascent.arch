#ifndef MJM_DIET_DIARY_FORM_H__
#define MJM_DIET_DIARY_FORM_H__

#include "mjm_globals.h"
#include "mjm_generic_recipe.h"
#include "mjm_compiled_noun.h"
#include "mjm_thread_util.h"
#include "mjm_ragged_forms.h"
#include "mjm_snacks_accumulator.h"
#include "mjm_constrained_file.h"
#include "mjm_unit_crap.h"
// faster than calling date in bash doh 
#include "mjm_calendar.h"
#include "mjm_diary_parse_state.h"
#include "mjm_muqed_phrase.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Tue Jul 28 18:46:13 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_diet_diary_form   

// g++ -std=gnu++11 -DTEST_MJM_DIET_DIARY_FORM -I. -I../../mjm/hlib -I../../mjm/num -I../muqed_util  -gdwarf-3 -O0  -x c++ mjm_diet_diary_form.h  -lpthread -lreadline -lboost_filesystem -lboost_system



// g++ -std=gnu++11 -DTEST_MJM_DIET_DIARY_FORM -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_diet_diary_form.h  -lpthread -lreadline -lboost_filesystem -lboost_system

// g++ -std=gnu++11 -DTEST_MJM_DIET_DIARY_FORM -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_diet_diary_form.h  -lpthread -lreadline

template <class Tr>
class mjm_diet_diary_form  : public mjm_ragged_forms<Tr> 
{
 typedef mjm_diet_diary_form Myt;
typedef  mjm_ragged_forms<Tr>  Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// why the fck wont' these inherit fck 
typedef typename Super::Ragged Ragged;
typedef typename Ragged::Line Line;
typedef StrTy Word;
typedef std::vector<Word> Words;
typedef std::map<StrTy, IdxTy> DictTy;
typedef typename Super::CharClass CharClass; 
typedef mjm_constrained_file<Tr> BackingFile;
//ZZZZBackingFile m_file;
typedef typename CharClass::read_buffer Rb;

typedef mjm_unit_crap<Tr> Units;
typedef typename Units::qty_dim Qdim;
typedef std::map<StrTy, int > ModMap;

//typedef compiled_noun Cnoun;
typedef mjm_compiled_noun<Tr> Cnoun;
typedef mjm_diary_parse_error<Tr> parse_error;
//typedef std::vector<Cnoun> CnounVec;
typedef std::vector<Cnoun> Cnouns; 
//typedef std::map<StrTy, Cnouns> CnounMap;
typedef mjm_compiled_noun_collection<Tr> CnounMap;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_generic_recipe<Tr> Recipe;
typedef mjm_generic_recipe_map<Tr> Recipes;

typedef mjm_muqed_phrase<Tr> Phrase;
typedef typename Phrase::file_finder_type Finder;


public:
#define MACRONOUNS QUOTE(MACRONOUN)
// need an "eaten vs served percentage and prepared ahead of time?
enum { IGNORE,LPAREN,RPAREN,RESERVED,NOUN,TIME,DATE,MACRO,MACROMOD,NAME,AMPERSAND,BSLASH, BAD=Super::BAD};
enum { MACRONOUN=0};
//MM_ERR("class "<<MMPR3(w,c,class_enumval(c)))
enum { MACROMASK=CharClass::UC|CharClass::DIGIT, DIGIT=CharClass::DIGIT};
enum { LC=CharClass::LC};
enum { UC=CharClass::UC};


typedef ::parse_settings<Tr> parse_settings;
typedef parse_settings PO;


//typedef parse_state PS;
typedef mjm_diary_parse_state<Tr>  parse_state; // temp kluge
typedef mjm_diary_parse_state<Tr>  PS;

typedef typename Cnoun::evaluation  Eval;
typedef std::vector<Eval> Explosion ; // ystack;

mjm_diet_diary_form() {Init();}
~mjm_diet_diary_form() {}

//m_form_fn=fn; Load(Super::m_form,m_form_fn);
//StrTy m_form_fn, m_nouns_fn,m_reserveds_fn;
//Ragged m_reserveds, m_nouns,m_macros;
void clear_form() { Super::m_form.clear(); } 
//void set_root(const StrTy & fn){Super::m_file.root_path(fn); }
void set_root(const StrTy & fn){Super::use_dir(fn); }
//void set_file(const StrTy & fn){Super::m_file.rel_path(fn); }
void set_file(const StrTy & fn){Super::set_file(fn); }
const StrTy & full()const {return Super::full(); }
void mkpath(const StrTy & fn){Super::mkpath(fn); }
void load_form() { Super::load(); }
void save_form() { Super::save(); }
void load_form(const StrTy & fn){m_form_fn=fn; Super::Load(Super::m_form,fn,0); }
void load_form(IsTy & is){m_form_fn=""; Super::load(is,0); }
void load_nouns(const StrTy & fn){m_nouns_fn=fn; Super::Load(m_nouns,fn,0); }
void load_units(const StrTy & fn)
{m_units_fn=fn; m_units.fn(fn); m_units.load(); m_units.parse(); }
void load_recipes(const StrTy & fn){m_recipes_fn=fn; Super::Load(m_recipes,fn,0); }
void load_ignores(const StrTy & fn){m_ignores_fn=fn; Super::Load(m_ignores,fn,0); }
void load_reserveds(const StrTy & fn){m_reserveds_fn=fn; Super::Load(m_reserveds,fn,0); }
void load_finder(const StrTy & fn){m_find_fn=fn; Super::Load(m_finds,fn,0); }
// this re-creates all indexes as multiple files can be loaded
// and with indexed groups the pointers cam be invalid
// may need to fix this for DB or swapping/backed
// word lists. 
void index() { Index(); } 
typename CnounMap::MissingMap  missing() const { return m_cnouns.missing(); } 
void set_expansion(const StrTy & e, const IdxTy s) 
{ m_expand_type=e; m_expand_state=s;
MM_ERR(MMPR4(e,s,m_expand_type,m_expand_state))
  } 

void parse_week(PS& ps, PO & po) { 
ps.finder(&m_finder);
const StrTy s=Super::m_hand.lexi_days(StrTy("7 days ago"));
const StrTy e=Super::m_hand.today();
po.dates(s,e);
index();  Parse(ps,po); 
}
void parse(PS& ps, PO & po) {
ps.finder(&m_finder);

 index();  Parse(ps,po); }

IdxTy replace_date(const StrTy & text, const IdxTy flags)
{ return  ReplaceDate(text,  flags); } 



void blank(PS& ps, PO & po) {
ps.finder(&m_finder);

 index();  BlankForm(ps,po); }
Ragged * blank( const IdxTy flags=0) 
{
const bool preserve=Bit(flags,0);
const IdxTy pf=preserve?(1<<PO::PRESERVE):0;
PO po((1<<PO::BLANK)|pf); 
PS ps; 
ps.finder(&m_finder);
//ps.debug_os=&std::cerr;  
parse(ps,po);
MM_ERR(" returning from blank")
Ragged * b=ps.blank;
ps.keep_blank();
return b;
} // blank
/*
{PO po(1<<PO::BLANK); Myt::parse_state ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}
0

*/

StrTy dump(const IdxTy flags=0) { return Dump(flags); }

StrTy dump_nouns(const IdxTy flags=0) { Ss ss; m_cnouns.dump(ss,flags); return ss.str();  }
// now count and index groups in noun collection for verification etc

private:
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; 

ss<<MMPR4(m_form_fn, m_nouns_fn,m_recipes_fn,m_reserveds_fn); 
ss<<MMPR(m_ignores_fn);
ss<<MMPR4(Super::m_form.size(), m_reserveds.size(), m_nouns.size() ,m_recipes.size()) ;
ss<<MMPR4(m_macros.size(),m_ignores.size(), m_dnouns.size(), m_dreserveds.size()); 
//ss<<MMPR4(m_dmacros.size(),m_drecipes.size(),m_dates.size(),m_dignores.size());
ss<<MMPR4(m_dmacros.size(),m_crecipes.size(),m_dates.size(),m_dignores.size());
ss<<MMPR2( m_cnouns.size(), m_mask_name);
ss<<MMPR2(m_units_fn, m_units.size()); 

 return ss.str(); 
}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//cpputil -enumc class_enumval
StrTy class_enumval(const IdxTy c)
{
switch (c)
{
case IGNORE : { return "IGNORE"; }
case RPAREN : { return "RPAREN"; }
case LPAREN : { return "LPAREN"; }
case RESERVED : { return "RESERVED"; }
case NOUN : { return "NOUN"; }
case TIME : { return "TIME"; }
case DATE : { return "DATE"; }
case MACRO : { return "MACRO"; }
case MACROMOD : { return "MACROMOD"; }
case NAME : { return "NAME"; }
case AMPERSAND : { return "AMPERSAND"; }
case BSLASH : { return "BSLASH"; }
case BAD : { return "BAD"; }
default : MM_ERR(" class_enumval bad enum value "<<MMPR(c))
} // switch 
return StrTy("bad_enum_value");
} // class_enumval 

IdxTy ReplaceDate(const StrTy & text, const IdxTy flags)
{
Super nt;
Ss ss; ss<<text;
nt.load(ss,3);
Ragged & src=Super::form(nt);
Ragged & r=Super::m_form;
const IdxTy szs=r.size();
const IdxTy ilim=(szs-1); 
std::vector<IdxTy> dnv;
IdxTy i=ilim; // (szs-1); 
const IdxTy date=WalkBackDates(dnv,i,r,szs);
MM_ERR(" found date "<<MMPR3(i,szs,dnv.size()))
const IdxTy ilast=i;
const IdxTy ssz=src.size();
for(IdxTy j=0; j<ssz; ++j)
{
const Line& _l=src[j];
if ( _l.size()==0) continue;
IdxTy ldate=CachingSerialLut(_l[0]);
if ((ldate==0)||(ldate==date))
{ ++i; if ( i<szs) r[i]=_l; else r.add(_l);  } // if 
else MM_ERR(" will not include line with "<<MMPR(_l[0]))
} // i 

// can delete but may be some benefit to this. 
while (int(i)<int(ilim)) { ++i; Line &  _l=r[i]; _l.clear(); } // while i 

return 0; 
} // ReplaceDate

// TODO hazard, synchronize... 
// AND moved to the pawnoff handler as this is a common
// issue there 
IdxTy CachingSerialLut(const StrTy & s)
{
MM_ONCE(" hazard ",)
static std::map<StrTy,IdxTy> m;
auto ii=m.find(s);
if (ii!=m.end()) return (*ii).second; 
//IdxTy dn= atoi(Super::m_hand.serial_days(l[0]).c_str());
IdxTy dn= atoi(Super::m_hand.serial_days(s).c_str());
m[s]=dn;
return dn;


}// CachingSerialLut
template <class Ty> 
IdxTy WalkBackDates(Ty &dnv,IdxTy & i,Ragged & r,const IdxTy szs)
{
IdxTy date=0;
// find all lines for most recent date 
while ( true)
{
if (i>=szs) break;
const Line & l=r[i];
if(l.size()==0) { dnv.push_back(0); --i;  continue; } 
//IdxTy dn= atoi(Super::m_hand.serial_days(l[0]).c_str());
IdxTy dn=CachingSerialLut(l[0]);
dnv.push_back(dn);
if (date==0) date=dn;
if (dn!=0) if (date!=dn) break;
--i;
} // true 
return date; 
} // WalkBackDates

void BlankForm( PS & ps, PO & po)
{
ps.finder(&m_finder);
const bool include_latex=true;
const bool preserve=po.preserve();
//bool SameIfdDate(const StrTy & x, const StrTy & known)
Ragged & r=(ps.markup!=0)?(*ps.markup): Super::m_form;
if (ps.blank==0) ps.blank= new Ragged();
Ragged & d=*ps.blank;
Ragged last;
const IdxTy szs=r.size();
const StrTy today=Super::m_hand.today();
//IdxTy date=0;
const IdxTy ilim=(szs-1); 
std::vector<IdxTy> dnv;
IdxTy i=ilim; // (szs-1); 
const IdxTy date=WalkBackDates(dnv,i,r,szs);
#if 0 
#endif
MM_ERR(" found date "<<MMPR3(i,szs,dnv.size()))
// the -1 was supposed to be cool but doh
while (int(i)<int(ilim))
{
++i;
const Line &  _l=r[i];
if (preserve) { d.add(_l); continue; } 
Line l;
MM_LOOP(jj,_l){ if ((*jj)!="(") if ((*jj)!=")") l.push_back(*jj); } 
const IdxTy szl=l.size();
MM_ERR(" adding "<<MMPR2(i,szl))
if (szl==0) continue; // just drop the line 
// make a copy 
const IdxTy dline=dnv[ilim-i];
if (dline==0)  {d.add(l); continue; } 
IdxTy pc=1;
Line lnew;
lnew.push_back(today);
if (pc>=szl) { if (include_latex) {lnew.push_back("&");
lnew.push_back("\\"); d.add(lnew); continue; } }
bool latex= (l[pc]=="&"); 
if(latex==include_latex) lnew.push_back(l[pc]);
else if(latex) lnew.push_back("&");
lnew.push_back("(");
++pc;
while (pc<szl)
{
if (l[pc]=="\\") break;
lnew.push_back(l[pc]);
++pc;
}
lnew.push_back(")");
if (include_latex) lnew.push_back("\\\\");
d.add(lnew);
}
MM_ERR(" done blank ")
} //blank 
typedef std::vector<StrTy> MacSplit;
IdxTy MacroModSplit(MacSplit & v, MacSplit & vplus,const StrTy & w)
{
Rb r(w);
char * p=r.ptr();
bool minus=true;
char * ps=p;
while (*p)
{
if (*p=='-') 
{*p=0; 
if (p!=ps) { if ( minus) v.push_back(StrTy(ps)); else  vplus.push_back(StrTy(ps));} 
ps=p+1; minus=true; }
if (*p=='+') 
{*p=0; 
if (p!=ps) { if ( minus) v.push_back(StrTy(ps)); else  vplus.push_back(StrTy(ps)); }  
ps=p+1; minus=!true; }
++p;
} // p 
if (p!=ps) 
{ if ( minus) v.push_back(StrTy(ps)); else  vplus.push_back(StrTy(ps)); }  


return 0;
} // MacroModSplit

// multiple adjectives need to be var1, var2, ... qty
// which may conflict with multiplication of multiple coefs. 
IdxTy ParseMacro( IdxTy& j, const StrTy & _w, const Line & l, PS & ps, PO & po)
{
// this supports an old syntax needs to eb replaced with vars
MacSplit vminus,vplus;
MacroModSplit(vminus,vplus,_w);
const IdxTy vminussz=vminus.size();
const IdxTy vplussz=vplus.size();
const bool odified= ((vminussz!=1) ||(vplussz!=0));
if (vplussz!=0) { MM_ERR(" have addition from "<<MMPR(_w)) } 
if (vminussz<1) { return 0; }
const StrTy & w=vminus[0]; 
// normally this is word 2 with ampersand or word 1 without
// this it is a definition although now allow kewyrod "RECIPE"
// to precede.
if (ps.have_macro_def(w,m_dmacros))
{ // either save the def or we are expanding it and this is the
// name of the macro on first occurence...  
if (ps.expanding()) { ps.have_name(w);   } // expanding
else { 
if (odified) // ((vminussz!=1) ||(vplussz!=0))
{
MM_ERR(" macrto def has plus or minus "<<MMPR(_w))
}
// if true, this should be a defintion, put into dmacros
// this only has the latest one,
m_dmacros[w]=m_macros.size();
// on expansion, the most recent one will be found and checked for
// too-old
MM_ERR(" adding macro def "<<MMPR2(l[0],l[1]))
m_macros.add(l);
m_leftovers[l[0]].add(l);
if (m_leftovers.size()>30) { m_leftovers.erase(m_leftovers.begin()); }

return 1 ; // nothing to do although macro should be validadated
 } // not expanding 
} // have_macro_def
else // if not a def and a def is found, take adjectives and expand the macro
{
const Line * lmp=0;
////////////////////////////////////////
// 2021-08-12 first check for a date for leftovers now doh
bool found= false;
auto & ax=ps.m_phrase.adj();
bool found_date_adj=false;
for(IdxTy id=1; id<ax.size(); ++id)
{
if (ax[id]=="date" )
{
const StrTy leftover=ax[id-1];
// first remove junk for parser...
auto axnew=ax;
axnew.clear();
MM_ERR(" NEW FEATURE removing a leftovr date for "<<MMPR2(leftover, w))
for(IdxTy id2=0; id2<ax.size(); ++id2)
{
if (id2!=id) if (id2!=(id-1)) axnew.push_back(ax[id2]);
} // id2
ax=axnew;
// now try to find it
auto jj=m_leftovers.find(leftover);
if (jj==m_leftovers.end())
{
Ss ss;
ss<<" no leftover macro def dates "<<MMPR3(leftover,w,l[0]);
ps.add_error(w,j,ss.str().c_str());
} // not found  in leftowvers
else
{
// make sure there is a def for that day 
// this does not fcking work for the fcking Ragged...
for(IdxTy fck=0; fck<(*jj).second.size(); ++fck)
//auto kk=(*jj).find(w);
//if (kk!=(*jj).end())
{
if ((*jj).second[fck].size()==0) continue;
if ((*jj).second[fck][0]==leftover)  
{

 lmp= &  (*jj).second[fck];
found=true;
typedef mjm_loo_parsing<Tr> Loo;

MM_ERR(Loo::Dump(*lmp));
} // found 
} //  for fck // found leftover
if (!found)
//else
{
Ss ss;
ss<<" some defs but no leftover macro def dates "<<MMPR3(leftover,w,l[0]);
ps.add_error(w,j,ss.str().c_str());
} // no macro 
} // found in leftovers

} // if date

} // id

////////////////////////////////////////////
if (!found) { 
MM_ERR(" macro lefover not found stage 1")
auto ii=m_dmacros.find(w);
// these need to be defined everyday for a macro recipe. 
// 2021-08-11 want a syntax for leftovres from prior day 
found=(ii!=m_dmacros.end());
if (found) { 
// verify dates are equal,
//MM_ERR(" evaluate macro or recipe "<<MMPR(w))
//const Line & lm= m_macros[(*ii).second];
 lmp= &  m_macros[(*ii).second];
if ((*lmp)[0]!=l[0])
{
Ss ss;
ss<<" no current macro def dates "<<MMPR2((*lmp)[0],l[0]);
ps.add_error(w,j,ss.str().c_str());
}
} // found  for today 
} // no date adj found or missing  
if (!found)
{
MM_ERR(" macro lefover check recupes  ")
//auto jj=m_drecipes.find(w);
auto jj=m_crecipes.find(w);
//found=(jj!=m_drecipes.end());
found=(jj!=m_crecipes.end());
 //lmp= &  m_recipes[(*jj).second];
 lmp= &((*jj).second.noun_result());
}
if (!found)
{
if (!Ignore(w)) ps.adj(w); return 2; //  break;
// ps.add_error(w,j," macro not found"); 
}
const Line & lm=(*lmp);
// add or remove nouns based on the lists
//const IdxTy adsz=ps.adjectives.size();
const IdxTy adsz=ps.m_phrase.words();
//if (ps.adjectives.size()<1) { 
if (adsz<1) { 
MM_ONCE(" obsolete share factors ignored for now make defaults etc",)
//if (w!="PMDINNER")if(w!="AMDINNER") ps.add_error(w,j," obsolete share factor"); 
} 
if (ps.warn_depth()) 
{ 
Ss ss; 
ss<<" macro depth "<<MMPR3(ps.depth, w,j);
 MM_ERR(ss.str()) ;
ps.add_error(w,j,ss); 
} // warn_depth 
const bool too_deep= (ps.stop_depth());
if (too_deep)
{
Ss ss; 
ss<<" macro stop depth "<<MMPR3(ps.depth, w,j);
 MM_ERR(ss.str()) ;
ps.add_error(w,j,ss); 
//return 99; 
} // just want to record it as a noun unexpanded, 
PS ps2=ps;
// be design, only one adjective is used and that is number of
// recipe quantities. Follow on adjectives replace "$n" in the maco
// definition. 
// TODO FIXME this needs to account for percent consumed of offered 
const bool check_for_vars=(adsz>1);
// the above reference is stull fcking in scope 2021-08-12 
//auto & ax=ps.m_phrase.adj();
if (check_for_vars)
{
std::vector<StrTy> adjx;
//adjx.push_back(ps.adjectives[0]);
// TODO definiition problem the FIRST entry is the qty rest are vars 
// TODO 20201-10-28 this is not right, the qty is apparently the LAST value 
//adjx.push_back(ax[0]);
// ax is a ref to ps.phrase.... doh 
//if (ax.size()) adjx.push_back(ax[ax.size()-1]);
if (ax.size()) adjx.push_back(ax[0]);
IdxTy nunused=1;
//if  ( adsz> 2) if (ps.adjectives[1]=="of")
if  ( adsz> 2) if (ax[1]=="of")
{
//adjx.push_back(ps.adjectives[1]);
adjx.push_back(ax[1]);
//adjx.push_back(ps.adjectives[2]);
adjx.push_back(ax[2]);
// TODO not the right thing here but "of" not used now doh 
nunused=3;
}
Line lmex=lm;
bool used=false;
for(IdxTy k=0; k<lmex.size(); ++k)
{
Word & lw=lmex[k];
const char * p=lw.c_str();
if (p[0]=='$')
{
used=true; // even if not really found 
const IdxTy var=atoi(p+nunused);
//if (var<adsz) lw=ps.adjectives[var];
if (var<adsz) lw=ax[var];
// TODO 2021-10-28 need to remove the var from the phrase or else it
// multiples later...

else {
Ss ss;
ss<<" bad vars "<<MMPR4(k,adsz,var,lw);
ps.add_error(w,j,ss.str().c_str());
}
}
} // for k
//if (used ) ps.adjectives=adjx;
if (used ) ax=adjx;
MM_ERR(" reseting ps2 date")
ps2.reset_old_date();
Parse(lmex,ps2,po);
MM_ERR(" done with ps2 parse ")
} // check for vars
else  {
// then recurse but define the evluation like anther noun,
//PS ps2=PS(ps);
// always do this for error checking... 
// this is why no free on delete
if (lm.size()>2) MM_ERR(" parsing macro def "<<MMPR3(lm[0],lm[1],lm[2]))
else MM_ERR(" parsing macro def size  "<<MMPR(lm.size()))
MM_ERR(" reseting ps2 date")
ps2.reset_old_date();
Parse(lm,ps2,po);
MM_ERR(" done with ps2 parse ")
} 
// adjectives left?
ps2.check_eol(); // 2021-04-09 

ps.add_errors(ps2);
//auto x=m_cnouns[ival].evaluate(w,ps.adjectives, &  (Super::m_cc));
// so ps2 contains all the noun evals and need to be multiplied
// by the adjective list. Use the reserve MACRONOUN for this
//auto x=m_cnouns[MACRONOUN].evaluate(w,ps.adjectives, &  (Super::m_cc));
const IdxTy msz=(m_cnouns[MACRONOUNS].size());
if(msz!=1)
{
Ss ss;
  ss<<" macro def size needs to be one"<<MMPR(msz);
  //ps.add_error(w,j, " macro def size needs to be one");
  ps.add_error(w,j, ss.str().c_str());
}
//auto x=m_cnouns[MACRONOUNS][0].evaluate(w,ps.adjectives, &  (Super::m_cc),m_units);
ps.organize_adjectives();
auto x=m_cnouns[MACRONOUNS][0].evaluate(w,ps.m_phrase, &  (Super::m_cc),m_units);
//MM_ERR(MMPR(x.dump()))
ps.add_errors(x.errors());
if (too_deep||po.dont_expand_recipes()) ps.have_noun(x);
else
{
 if (!odified) ps.have_noun(x,ps2);
 else ps.have_noun4(x,ps2,vminus,vplus);

}
} // else , ps2 goes out of scope  , ps2 goes out of scope 


// if no def today, or no def ever??? 


return 0; 
} // ParseMacro
/////////////////////////////////////////////////
typedef typename Cnoun::noun_score NounScore;

//IdxTy  ScoreNouns(NounScore * nsp, const Cnouns & xvec, PS & ps ) const
IdxTy  ScoreNouns( Cnouns & xvec, PS & ps ) const
{
const IdxTy nnouns=xvec.size();
NounScore nsp[nnouns];
IdxTy in=0;
IdxTy best=~0;
int best_score=0;
IdxTy non_zer=0;
IdxTy more_8=0;
IdxTy n_best=0;
for(; in<nnouns; ++in)
{
//nsp[in]=NounScore(ps.admap,ps.dates, &(xvec[in])); 
//nsp[in]=NounScore(ps.m_phrase.admap(),ps.dates, &(xvec[in])); 
nsp[in]=NounScore(ps.m_phrase,ps.dates, &(xvec[in])); 
//MM_DIE(" need the admap thing") 
const int score_in=nsp[in].score();
if (score_in>0) ++non_zer;
if (score_in>8) ++more_8;
if (score_in>best_score) { best=in; best_score=score_in; } 
//if (nsp[in].score()==3) best=in;

} // for in 
if (best== ~0U)
{
Ss ss; ss<<"no nouns of "<<MMPR(nnouns)<<" qualify ";
StrTy noun="unknown";
if (nnouns>0) noun=xvec[0].name();
ps.add_error(noun,ps.j,ss); 

} // no best
if (best== ~0U)  best=(nnouns-1);
IdxTy ndefault=0; 
IdxTy locdef=0;
for(in=0; in<nnouns; ++in) 
{ int x= nsp[in].score(); 
if (x==best_score)
{
if (xvec[in].def()) {locdef=in; ++ndefault; }  
 ++n_best; 
} // x==best_score
}  // in 

// if n_best>1, see if there is a tie breaking default
if (n_best>1)
{
if (ndefault==1) { n_best=1; best=locdef; } 
} // n_best>1
if (n_best!= 1)
{


Ss ss; ss<<"tied for best  "<<MMPR(ndefault)<< MMPR4(nnouns,n_best,best_score,ps.m_phrase.dump())<<"  ";
 for(in=0; in<nnouns; ++in) ss<<nsp[in].score()<<" ";
StrTy noun="unknown";
if (nnouns>0) noun=xvec[0].name();
ps.add_error(noun,ps.j,ss); 

} // no best


if ( non_zer>1)
{
Ss ss; for(in=0; in<nnouns; ++in) ss<<nsp[in].score()<<" ";
MM_ERR(" multiple nouns resolved "<<MMPR4(xvec[0].name(),non_zer,more_8,ss.str()))
} 



return best;

} // ScoreNouns

typedef typename Cnoun::partss_type Pt; 
typedef typename Cnoun::line_parts_type LinePt; 
IdxTy ExplodeNoun(  Explosion & ystack, const   LinePt & parts, const StrTy & w
, PS & ps, const IdxTy j, const IdxTy cner, Eval & x  )
{
IdxTy rc=~0;
//MM_LOOP(ii,cn.parts())
// I guess the noun should just compile this to a Ragged but leave here for now.
Ragged r;
MM_LOOP(ii,parts)
{
r.add((*ii));
//const StrTy & wp=(*ii).first;
} // ii
// these are now just another input file for a noun dictionary 

// expand like a daily snack maco


return rc; 
} // ExplodeNoun
IdxTy ExplodeNoun(  Explosion & ystack, const   Pt & parts, const StrTy & w
, PS & ps, const IdxTy j, const IdxTy cner, Eval & x  )
{
IdxTy rc=0;
//MM_LOOP(ii,cn.parts())
MM_LOOP(ii,parts)
{
const StrTy & wp=(*ii).first;
// this was const ref but may need to modify for rank units. 
Qdim  qdp=(*ii).second;
const StrTy qsfx=qdp.sfx();
// 2021-09-06 this gets confused with expired nouns 
auto& xvecp=m_cnouns[wp]; // .evaluate(w,ps.adjectives, &  (Super::m_cc));
IdxTy oknouns=0;
IdxTy okone=0;
IdxTy locc=0;
IdxTy ndef=0;
IdxTy defone=0;
MM_LOOP(jj,xvecp)
{
if ((*jj).date_ok(ps.date())) { ++oknouns; okone=locc;
if ((*jj).def()) { ++ndef; defone=locc; } 
 } 

++locc;
}
const IdxTy nnouns=xvecp.size();
if (nnouns==0)
{
MM_ERR(" making fake nonn "<<MMPR(wp))
Line ll;
ll.push_back(wp);
// should have a dummy ctor that just takes a name
Cnoun dummy(ll);
xvecp.push_back(dummy);
}

//else if (nnouns!=1)
else if (oknouns!=1)
{ 
if ( ndef==1) { okone=defone;}
else{
MM_SS(" expanded nouns muyst be unique or have default   "<<MMPR4(oknouns,nnouns,w,wp));
ps.add_error(w,j,ss);
rc|=1; /// expanded_ok=false;
} // ndef!=1
} // oknouns!=1

Cnoun & nounp=xvecp[okone];
// y evaluates to the amount of nounp due to evaluation x.
// 
Eval y(&nounp,&x,qdp,&m_units); // x;
if (y.failed())
{ MM_SS(" expand units problem  "<<MMPR3(nounp.canon(),w,wp))
ss<<MMPR4(x.qty(),x.sfx(),qdp.sfx(),nounp.serving().sfx());
ps.add_error(w,j,ss);
rc|=1; //   expanded_ok=false;
}
ystack.push_back(y);
} // ii
return rc;
} // ExplodeNoun

#if 0 
#endif


IdxTy ParseNoun( IdxTy& j, const StrTy & _w, const Line & l, PS & ps, PO & po)
{
const StrTy & w=_w;
//auto x=m_cnouns[ival].evaluate(w,ps.adjectives, &  (Super::m_cc));
//bool used_the_noun=false;
auto& xvec=m_cnouns[w]; // .evaluate(w,ps.adjectives, &  (Super::m_cc));
const IdxTy nnouns=xvec.size();
if (nnouns==0) // MM_ERR(" no nouns wtf "<<MMPR(w))
{Ss ss;
ss<<" no nouns  "<<MMPR(w);
//ps.add_error(w,j,ss.str().c_str());
ps.add_error(w,j,ss);
return ~0;
}

ps.organize_adjectives();

//if (nnouns>1) MM_ERR(" multiple nouns for  "<<MMPR2(nnouns,w))
// FIXME this works better if the adjectives have been parsed first doh
IdxTy best=ScoreNouns(xvec,ps);
//if (nnouns!=1) { MM_ERR(" pick fo multiple "<<MMPR3(w,best,nnouns)) } 
Cnoun & cn=xvec[best];
/////////////////////////////////////////
//Eval x=cn.evaluate(w,ps.adjectives, &  (Super::m_cc),m_units);
Eval x=cn.evaluate(w,ps.m_phrase, &  (Super::m_cc),m_units);
////////////////////////////////////////
// this is now done in ystack 
// probably if multiple selections... 
// wat not working, tolerate duplicates for now... 
ps.add_errors(x.errors());
Explosion  ystack;
ystack.push_back(x);
const IdxTy rc=ExplodeEvaluation(ystack,j,w,ps,po);
// TODO dropping bad adjectives now in expansions.. 
// TODO figure out why ystack can't do this wth 
if ((rc!=0))//  || w.errors())
{Ss ss;
ss<<" explode failed just add unexploded thing   "<<MMPR(w);
ps.add_error(w,j,ss);
ystack.clear();
ystack.push_back(x);

}
 MM_LOOP(ii,ystack){ ps.have_noun((*ii)); ps.add_errors((*ii).errors());} 
return 0;
} // ParseNoun
// for each ystack member, either expand and add its expansion and delete it
// or just retain it.
IdxTy ExplodeEvaluation(Explosion & ystack, IdxTy& j, const StrTy & w, PS & ps, PO & po)
{
IdxTy rc=0;
if (ystack.size()==0) return rc;
IdxTy i=0;
IdxTy iter=0;
while (i<ystack.size()) // this constantly varies. 
{ 
++iter;
if ( iter>500) 
{
Ss ss; ss<<" explode dun on iter "<<MMPR2(iter,ystack.size());
MM_ERR(ss.str()) ; ps.add_error(w,j,ss); 
rc=1;
break;
}
if (ystack.size()>500)
{
Ss ss; ss<<" explode dun on size  "<<MMPR2(iter,ystack.size());
MM_ERR(ss.str()) ; ps.add_error(w,j,ss); 
rc=2;
break;
}
Eval & x=ystack[i];
Cnoun & cn= x.noun();
StrTy choice;
IdxTy ec=PickAnExplosion(choice,x,cn,j,w,ps,po);
// zero means try to expand, if not just keep on the stack
if (ec!=0) { ++i; continue; }

const Pt & pp=cn.parts(choice,0);
if (pp.size()==0) { ++i; continue; } // nothing there 
Explosion ystacknouveau; 
// this does not update the depth not sure about scale and
// adjectives, should just use the noun parse 
// expand one evaluation one level only 
const IdxTy rc=ExplodeNoun(ystacknouveau,pp,w,ps,j,cn.expand_rank(),x);
// if it expanded, remove this element and tack on those
const IdxTy yns=(ystacknouveau.size());// expanded_ok=true; 
// this also makes depth testing impossible ... 
if ((rc==0)&&(yns>0)) // expanded_ok=true; 
{
const IdxTy ysz=ystack.size(); 
const IdxTy szj=ysz+yns-1;
Explosion y2(szj);
// this really needs pointers and data structs lol  wtf TODO FIXME 
for(IdxTy j=0; j<i; ++j) y2[j]=ystack[j]; 
for(IdxTy j=i+1; j<ysz; ++j) y2[j-1]=ystack[j]; 
for(IdxTy j=ysz; j<=szj; ++j) y2[j-1]=ystacknouveau[j-ysz]; 
// slower than wth.... 
ystack=y2;
// keep i the same 
} // rc==0
else{ ++i; continue; } // nothing there avoid infinite loop 

} // i 

return rc;
} // ExplodeEvaluation

IdxTy PickAnExplosion(StrTy & choice, Eval & x, Cnoun & cn, IdxTy& j, const StrTy & w, PS & ps, PO & po)
{
choice="";
// TODO FIXME this does not function here until all the recursions
// are nominally equal. 
const bool too_deep=ps.stop_depth();
const bool warn_deep=ps.warn_depth();
if (warn_deep)
{
Ss ss; ss<<" too deep expanding noun "<<MMPR2(w,j);
MM_ERR(ss.str())
ps.add_error(w,j,ss); 

}
const bool skip_all_expand=Bit(m_expand_state,2);
bool expand_lines= (cn.expand_lines());
// the blank choice could be a legitimate one 
bool try_an_expand=Bit(m_expand_state,0)||cn.expand();// (choice!=""); 

// then check form settings  
// blank is still ok. 
const bool have_pref_expand=Bit(m_expand_state,1)||(m_expand_type.length()!=0);
const bool have_exp_type=cn.have_parts(m_expand_type);
const bool have_exp_line_type=cn.have_line_parts(m_expand_type);
if (have_exp_type&&!have_exp_line_type) expand_lines=false;
else if (!have_exp_type&&have_exp_line_type) expand_lines=!false;

if (have_exp_type || have_exp_line_type) choice=m_expand_type;

// finally anything specific to this event record 
const StrTy*  ev=x.property("expand");
const bool have_ex_ev=(ev!=0);
//if (have_ex_ev) choice=(*ev);
// if the noun has it. 
if (have_ex_ev) { MM_ERR(MMPR(cn.have_parts(*ev)))} 
const bool have_ev_type=have_ex_ev?cn.have_parts(*ev):false;
const bool have_ev_line_type=have_ex_ev?cn.have_line_parts(*ev):false;
// if at least one exists, pick that one.
if (have_ev_type&&!have_ev_line_type) expand_lines=false;
else if (!have_ev_type&&have_ev_line_type) expand_lines=!false;
if (have_ev_type || have_ev_line_type) choice=(*ev);

try_an_expand|=
have_ev_type||have_ev_line_type || have_exp_type||have_exp_line_type; 
try_an_expand&=!skip_all_expand;
if (try_an_expand)
{
if (too_deep)
{
try_an_expand=false;
Ss ss; ss<<" stopping expansion too deep";
MM_ERR(ss.str())
ps.add_error(w,j,ss);

}
}
const bool explain_explosion=false;
if ( explain_explosion ) { MM_ERR(MMPR4(choice,expand_lines,try_an_expand,have_pref_expand) << MMPR4(have_exp_type,have_exp_line_type, have_ex_ev,((have_ex_ev)?(*ev):StrTy())) 
<< MMPR2(have_ev_type,have_ev_line_type)
<<MMPR4(cn.expand(),cn.expand_lines(),skip_all_expand,m_expand_state)
)
} // explain_explosion

IdxTy rc=try_an_expand?0:1;
return rc;
} // PickAnExplosion





#if 0

#endif


/////////////////////////////////////////////////
//public:
//void Parse(const Line & l, IdxTy flags=0)
void Parse(const Line & l, PS & ps, PO & po)
{
//MM_ERR("Parse fck "<<MMPR2(l.size(),ps.j))
const IdxTy szl=l.size();
bool date_oor=false;
for(IdxTy j=ps.j0; j<szl;++j)
//MM_SZ_LOOP(j,l,szl)
{
ps.j=j;
//MM_ERR("Parse fck "<<MMPR2(l.size(),ps.j))
D val=0;
const Word & w=l[j];
if (w.c_str()[0]=='#') break;
// this skicks parsing in a badlocation.. . 
//if (ps.skipping()) { if (w.c_str()[0]!=')') continue ; } 
IdxTy c=Syntax(w,j,ps,&val);
if (c==BAD) MM_ERR(MMPR2(ps.date(),ps.consumer_name())<<MMPR4(c,class_enumval(c),w,j))
//MM_ERR("class "<<MMPR3(w,int(c),class_enumval(c)))
IdxTy ival=val;
if (ps.skipping()) { 
// 2020-05-06 also want to NEST comment.... 
if (c==LPAREN) ps.paren();  
if (c==RPAREN) ps.rparen(); continue ; } 
switch (c)
{
//case TIME: { if (val>ps.time) ps.time=val; break; } 
case TIME: { ps.have_time(w,val);  break; } 
// these can be mostly string free form notes and dmel etc 
// need handlers though for recipe which transcends a given day 
// also need variables for things like "made on day xxx" 
case RESERVED: { 
if (date_oor) return; 
//MM_ERR(" note found a reserve word "<<MMPR(w)) 
ps.have_reserved(w,l); return ;  } 
case NOUN: { 
IdxTy rc= ParseNoun(  j,  w, l,  ps, po);

break; } 
// 2021-08-12 want to allow dates as adjecitves doh
//case DATE: { ps.have_date(ival,w); if (!po.date_ok(w))  return;   break; } 
case DATE: { 
MM_ERR(MMPR3(w,ps.have_date(),ival));
if (ps.have_date()) {  if(!Ignore(w)) ps.adj(w); break; } 
// 2021-08-18  we now need to keep all macro defs for leftovers etc. 
//ps.have_date(ival,w); if (!po.date_ok(w))  return;   break; } 
ps.have_date(ival,w); if (!po.date_ok(ps.date()))  date_oor=true;   break; } 
// TODO FIXME this needs to reflect plus and minus suffixes and var expand
case MACROMOD: //  { 
case MACRO: { 
IdxTy rc= ParseMacro(  j,  w, l,  ps, po);
if (rc==1) return; 
 break; } 
case NAME: {if (date_oor) return;  ps.have_name(w);  break; } 
case IGNORE: {  break; } 
case LPAREN: {ps.paren();  break; } 
case RPAREN: {ps.unparen();   break; } 
case AMPERSAND: { ps.have_latex(w);  break; } 
case BSLASH: { ps.have_latex(w);  break; } 

default: 


if(!Ignore(w)) ps.adj(w);
} ; // switch
//if (date_oor) return; // need to really keep macro def however.. 
} // j


} // Parse



bool Ignore(const StrTy & w)
{ return (m_dignores.find(w)!=m_dignores.end());  }
// may want to just validate, output time/qty, make template, markup
// markup and template need to generate another Ragged
// output time/qty not sure on dest  but may be Ragged

void Parse(PS& ps, PO & po)
//void Parse(IdxTy flags=0)
{
//IdxTy flags=0;
Ragged & r= Super::m_form;
ps.form=&r;
//if (po.eval()) ps.dmglob= new typename PS::DateMap2;
if (po.eval()) ps.dmglob= new typename PS::DateMap2(&m_units);
//if (po.eval()) ps.dmglob= new typename PS::DateMap2(&m_st);
IdxTy lno=0;
MM_LOOP(ii,r)
{
const Line & l =(*ii);
//MM_ERR(" parsing line "<<MMPR2(lno,l.size()))
++lno;
const IdxTy llen=l.size();
if (llen>0) {
// assume date is first but check whole file for issues. 
// do not check here, use parser for comments etc
//const StrTy & ldate=l[0];
//Parse(l,flags);
const IdxTy esi=ps.errors_size();
Parse(l,ps,po);
const IdxTy esf=ps.errors_size();
if (esf!=esi) MM_ERR(" errors for date "<<l[0]) ;

}
const bool just_ignore=(llen==0)||(l[0].c_str()[0]=='#');
if (!just_ignore) ps.new_line();

} // ii 
// generate a blank template with zero quantities and placeholders
// left in 
if ( po.blank())
{
// this should use the loaded form if not marked up AND
// do this AFTER markup 
if (ps.markup) { MM_ERR(" mem leak due to logic error with markup")}
else ps.markup = new Ragged();
ps.markup_form();
ps.blank = new Ragged();
blank(ps,po);
//ps.blank_form();
MM_ERR(" made blank")
} // blank
if (po.markup())
{
if (ps.markup) { MM_ERR(" mem leak due to logic error with markup")}
else ps.markup = new Ragged();
ps.markup_form();
} 

} // Parse

//enum { IGNORE,RESERVED,NOUN,TIME,DATE,MACRO,NAME, BAD=Super::BAD};

//enum { MACROMASK=CharClass::UC|CharClass::DIGIT, DIGIT=CharClass::DIGIT};
IdxTy Syntax(const StrTy & word, const IdxTy pos, PS & ps,  D * val =0 )
{
IdxTy p=0;
IdxTy * pp=&p;
const char * wp=word.c_str();
const IdxTy len=word.length();
if (len==1) {
if (wp[0]=='&') return AMPERSAND;
if (wp[0]=='(') return LPAREN;
if (wp[0]==')') return RPAREN;
if (wp[0]=='\\') return BSLASH;
}
if (IsIn(word,m_dreserveds,pp)) { if(val) *val=p;  return RESERVED; }
if (word=="NOTE") { if(val) *val=~0;  return RESERVED; }
if (word=="COMMENT") { if(val) *val=~0;  return RESERVED; }
if (word=="DMEL") { if(val) *val=~0;  return RESERVED; }
//if (IsIn(word,m_dnouns,pp)){ if (val) *val=p;  return NOUN;}
if (IsIn(word,m_cnouns)){  return NOUN;}
if (IsIn(word,m_dates,pp)) if (m_dates[word]!=0)
{
//if (val) *val=atof(m_dates[word].c_str());
if (val) *val=p; // m_dates[word];
 return DATE;
}
const bool macro=Macro(word);
const bool macromod=MacroModified(word);
const bool time=Time(word,val);
const bool name=Name(word);
//MM_ERR(MMPR(pos)<<MMPR4(word,macro,time,name))
if (time) return TIME;
if (name) return NAME;
if (macro) return MACRO;
if (macromod) return MACROMOD;
if (pos!=0) return BAD;
//IdxTy ds=0;
const StrTy gdate=GoodDate(pp,word);
const bool date=(gdate==word);
//if (ds!=0) 
if (date){  m_dates[word]=p;
if (val) *val=p; // atof(m_dates[word].c_str());
}
//MM_ERR(MMPR2(pos,p)<<MMPR4(word,macro,time,name)<<MMPR2(gdate,date))
if (date) return DATE;
//StrTy z= Super::m_hand.serial_days(Super::m_hand.lexi_days(word));

// fcking templated base fcking class fck 
return BAD;
} // word
// return true 
bool SameIfdDate(const StrTy & x, const StrTy & known)
{
if (x==known) return true; 
IdxTy dn= atoi(Super::m_hand.serial_days(x).c_str());
return (dn!=0);
}
StrTy GoodDateOld(IdxTy * pn, const StrTy & w)
{
StrTy dlexi= (Super::m_hand.lexi_days(w));
if (pn==0) return dlexi;
IdxTy dn= atoi(Super::m_hand.serial_days(dlexi).c_str());
*pn=dn;
return dlexi;
} // GoodDate
// the bash calls are expensive and don't show up
// as CPU time- task man runs at 10 pct CPU lol 
// this was even with caching the results... 
StrTy GoodDate(IdxTy * pn, const StrTy & w)
{
StrTy dlexi=w;
IdxTy xu=((m_cal.date_to_number(w)));
D x=D(xu);
//D x=D((m_cal.date_to_number(w)));
// TODO wtf? 2021-06-30 ignoring bad dates... 
if ((x<1000) ||(int(xu)<=0))
//if (x!= 000)
{
dlexi= (Super::m_hand.lexi_days(w));
x=D((m_cal.date_to_number(dlexi)));

}
if (pn!=0) *pn=IdxTy(x);
return dlexi;
} // GoodDate
mutable mjm_calendar m_cal;
#if 0 
#endif



bool Name(const StrTy & w)
{
const char * s=w.c_str();
if (*s==0) return false;
const IdxTy len=w.length();
IdxTy mask=UC;
if (!Cmask(s[0],mask)) return false;
++s;
mask=m_mask_name|LC|DIGIT;
while (*s!=0)
{
if (!Cmask(s[0],mask)) return false;
++s;
}
return true;
}
bool Time(const StrTy & w, D * val)
{
const char * s=w.c_str();
if (*s==0) return false;
const IdxTy len=w.length();
if (len==6)
{
// this is a bastard notation with AM/PM redudant
// for error check and 24 hour time xxxx[AP]M
//if (!Super::m_cc.mask(s[0],DIGIT)) return false;
if (!Cmask(s[0],DIGIT)) return false;
if (!Cmask(s[1],DIGIT)) return false;
if (!Cmask(s[2],DIGIT)) return false;
if (!Cmask(s[3],DIGIT)) return false;
const IdxTy t=atoi(s);
const IdxTy min=atoi(s+2);
if (min>59) return false;
//val=((t-min)*60.0 + min)/60.0;
// more code but saved div lol 
//if (val) *val=(t-min)/100 + (D(min)/60.0);
char doh[3]; doh[0]=s[0]; doh[1]=s[1]; doh[2]=0;
const IdxTy tdoh=atoi(doh);
if (val) *val=tdoh + (D(min)/60.0);
// on the edge not allowed lol 
if (t==0) return false;
if (t>=2400)  return false;
if (s[5]!='M') return false;
if (s[4]=='P') {  return (t>=1200); } 
if (s[4]=='A') {  return (t<=1200); } 
return false; 
}
else if (len==5)
{
if (!Cmask(s[0],DIGIT)) return false;
if (!Cmask(s[1],DIGIT)) return false;
if (!Cmask(s[4],DIGIT)) return false;
if (!Cmask(s[3],DIGIT)) return false;
const IdxTy min=atoi(s+3);
if (val) *val=atoi(s)+(D(min)/60.0);
return (s[2]==':');
}
return false; 
} // Time
bool Macro(const StrTy & w)
{
const char * s=w.c_str();
if (*s==0) return false;
while (*s!=0)
{
//if (!Super::m_cc.mask(*s,MACROMASK)) return false;
if (!Cmask(*s,MACROMASK)) return false;
++s;
}
return true;
}

// this needs to exclude dates etc OR be done after ruling
// out a date. Macro can start with numbers etc.  
bool MacroModified(const StrTy & w)
{

typedef typename CharClass::read_buffer Rb;
 Rb rb;
//typename CharClass::read_buffer rb;
rb.clear();
Super::m_cc.parse_groups(rb,w.c_str());
// the first entry has to qualify as a macro,
// if the partsing criteria are right but they are now
// due to numbers and letters mixes
// the others must be +/- and nounrs or maybe macro 
const IdxTy n=rb.string_count();
if (n<6) return false;
// this can not be numeric if the next one is a hyphen 
//const bool one_no= ((rb[0][0]==CharClass::TINT)||(rb[0][0]==CharClass::TFLOAT));
bool pieces_ok=false;
bool have_pm=false;
bool have_an=false;
for (IdxTy j=0; j<n; j+=2)
{
// these need to be alpha and int with isolated +/-
const bool one_no= ((rb[j][0]==CharClass::TINT));
const bool two_alpha= ((rb[j][0]==CharClass::TALPHA));
/// must have at least one alph 
have_an|=two_alpha; //|one_no;
bool two_pm= ((rb[j+1][0]=='-')||(rb[j+1][0]=='+'));
if (two_pm) two_pm&=(rb[j+1][1]==0); // len of 1 
have_pm|=two_pm;
if (!one_no) if (!two_alpha) if (!two_pm) return false;
 } // j 
pieces_ok=have_pm&&(have_an);
if (true) return pieces_ok;

const char * s=w.c_str();
if (*s==0) return false;
while (*s!=0)
{
//if (!Super::m_cc.mask(*s,MACROMASK)) return false;
if (!Cmask(*s,MACROMASK))
{
if (*s!='-') if (*s!='+') return false;
}

++s;
}
return true;
}



bool Cmask(const char c, const IdxTy m)
{ return Super::m_cc.mask(c,m); } 
///if (!Super::m_cc.mask(s[0],DIGIT)) return false;

bool IsIn(const StrTy & w, const DictTy & d, IdxTy * p=0 )
{
auto ii=d.find(w);
const bool found=(ii!=d.end());
if (found) if (p!=0) *p=(*ii).second;
return found; 
//return (d.find(w)!=d.end()) ; // null entries should not exist 
//return false;
}
template <class Tf> 
bool IsIn(const StrTy & w, const Tf & d )
{
auto ii=d.find(w);
const bool found=(ii!=d.end());
return found; 
}




/*
void xxx()
{
StrTy x= Super::m_hand.serial_days(Super::m_hand.lexi_day());
StrTy y= Super::m_hand.serial_days(Super::m_hand.lexi_days("1 day ago"));
StrTy z= Super::m_hand.serial_days(Super::m_hand.lexi_days("2020-07-20"));
MM_ERR(MMPR3(x,y,z))
}
*/
void CompileRecipes()
{
IdxTy line=0, word=0;
Ragged & r = m_recipes;
const IdxTy lines=r.size();
if (lines==0) return;

// this needs to get the name from compiling doh 
Recipe x;
x.parse(&r,line,word);
if (x.words_used()==0)
{
if (line>=lines) return;
if (line==(lines-1))if (word>=r[line].size() ) return; 
MM_ERR(" verb parsing ended early "<<MMPR4(line,word,r.size(),r[r.size()-1].size()))
return; 
}// eof 
const StrTy& nm=x.name();
m_crecipes[nm]=x;

}// CompileRecipes


void Index()
{
//m_drecipes.clear();
m_crecipes.clear();
m_dreserveds.clear();
m_dignores.clear();
m_noun_groups.clear();
//m_nouns.index_field(m_dnouns,0,0,0);
//m_recipes.index_field(m_drecipes,0,0,0);
m_reserveds.index_field(m_dreserveds,0,0,0);
m_ignores.index_field(m_dignores,0,0,0);
//m_cnouns.resize(m_dnouns.size());
//MM_LOOP(ii,m_dnouns)
m_cnouns.clear();
m_cnouns.load(m_nouns);
m_finder.clear();
m_finder.load(m_finds);
#if 0 
#endif

//m_cnouns.index_field(m_dnouns,0,0,0);
// index the groups as pointers should be stable now.
m_cnouns.index_groups(m_noun_groups);
#if 0 
#endif

CompileRecipes();
} // Index

void Init()
{
m_mask_name=Super::m_cc.uset("_-");
m_expand_state=0;
}

//m_form_fn=fn; Load(Super::m_form,m_form_fn);

// members
StrTy m_form_fn, m_nouns_fn,m_recipes_fn,m_reserveds_fn,m_ignores_fn,m_find_fn;
StrTy m_units_fn;
StrTy m_expand_type;
IdxTy m_expand_state;
Ragged m_reserveds, m_nouns,m_recipes,m_macros,m_ignores,m_finds;
Recipes m_crecipes;
typedef std::map<StrTy,Ragged> Leftovers;
Leftovers m_leftovers;
//Ragged m_class; // parse classification of corresponding thing in m_form. 
//DictTy m_dnouns, m_dreserveds,m_dmacros,m_drecipes,m_dates,m_dignores;
DictTy m_dnouns, m_dreserveds,m_dmacros,m_dates,m_dignores;
//CnounVec m_cnouns;
CnounMap m_cnouns;
IdxTy m_mask_name;
Units m_units;
typedef std::map<StrTy, std::vector<const Cnoun* > > NounGroupMap;
NounGroupMap m_noun_groups;
//BackingFile m_file;
Finder m_finder; // for resource files etc 
}; // mjm_diet_diary_form

//////////////////////////////////////////////

template <class Tr>
class mjm_diet_diary_form_map : public std::map<typename Tr::StrTy, mjm_diet_diary_form< Tr > >  
{
 typedef mjm_diet_diary_form_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_diet_diary_form< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_diet_diary_form_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_diet_diary_form_map




////////////////////////////////////////////
#ifdef  TEST_MJM_DIET_DIARY_FORM
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_diet_diary_form <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_DIET_DIARY_FORM "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
int main(int argc,char **args)
{
about();
typedef mjm_diet_diary_form<Tr>  Myt;
//Myt x(argc,args);
Myt x;
typedef Myt::parse_settings PO;
//PO po;
StrTy startdate,enddate;
//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
StrTy cmdp1="";
StrTy cmdp2;
if (sz>1) cmdp1=li.word(1);
if (sz>2) cmdp2=li.word(2);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
if (cmd=="dates"){ startdate=cmdp1; enddate=cmdp2;  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="parse") 
{PO po; Myt::PS ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}
if (cmd=="parse-week") 
{PO po; Myt::PS ps; ps.debug_os=&std::cerr;  x.parse_week(ps,po);}


if (cmd=="blank") 
{PO po(1<<PO::BLANK); Myt::PS ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}
if (cmd=="markup") 
{PO po(1<<PO::MARKUP); Myt::PS ps; ps.debug_os=&std::cerr;  
x.parse(ps,po);
StrTy fn=cmdp1;
typedef std::stringstream Ss;
MM_ERR(" dump of markuyp ")
//Ss ss; x.save(ss,*(ps.markup)); MM_ERR(ss.str()) 
if ((fn=="-")||(fn=="")) {Ss ss; x.save(ss,*(ps.markup)); MM_ERR(ss.str()) } 
else 
{ std::ofstream ofs(fn); x.save(ofs,*(ps.markup)); MM_ERR(" saved to "<<MMPR(fn))}

} // markup
if (cmd=="markup-week") 
{PO po(1<<PO::MARKUP); Myt::PS ps; ps.debug_os=&std::cerr;  
x.parse_week(ps,po);
StrTy fn=cmdp1;
typedef std::stringstream Ss;
MM_ERR(" dump of markuyp ")
//Ss ss; x.save(ss,*(ps.markup)); MM_ERR(ss.str()) 
if ((fn=="-")||(fn=="")) {Ss ss; x.save(ss,*(ps.markup)); MM_ERR(ss.str()) } 
else 
{ std::ofstream ofs(fn); x.save(ofs,*(ps.markup)); MM_ERR(" saved to "<<MMPR(fn))}

} // markup-weel



if (cmd=="commit") 
{
x.clear_form();
x.load_form();
StrTy fn=cmdp1;
std::ifstream ifs(fn); x.load_form(ifs);
x.save_form();
MM_ERR(" form updated")

} // commit 
if (cmd=="template") 
{
StrTy fn=cmdp1;
PO po(1<<PO::BLANK); Myt::PS ps; ps.debug_os=&std::cerr;  
//x.parse(ps,po);
x.parse_week(ps,po); // may not do whole anyway lol 
typedef std::stringstream Ss;
if ((fn=="-")||(fn=="")) {Ss ss; x.save(ss,*(ps.blank)); MM_ERR(ss.str()) } 
else 
{ std::ofstream ofs(fn); x.save(ofs,*(ps.blank)); MM_ERR(" saved to "<<MMPR(fn))}
} // template
if ((cmd=="eval")  || (cmd=="eval-week"))
{
IdxTy flags=atoi(cmdp1.c_str());
IdxTy flagout=atoi(cmdp2.c_str());
StrTy daily="dog_daily.txt";
StrTy glob="dog_glob.txt";
StrTy usedd="dog_used.txt";
const bool dump_dmglob=Bit(flagout,0);
const bool dump_rest=Bit(flagout,1);
const bool save_dmglob=Bit(flagout,2);
const bool save_daily=Bit(flagout,3);
const bool save_used=Bit(flagout,4);
IdxTy idx=3;
if (save_dmglob)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") glob=cip.wif(idx); ++idx;  } 
if (save_daily)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") daily=cip.wif(idx); ++idx;  } 
if (save_used)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") usedd=cip.wif(idx); ++idx;  } 

const bool week=(cmd=="eval-week");


MM_ERR(
MMPR4(flags,flagout,daily,glob)<<MMPR4(usedd,dump_dmglob,dump_rest, save_dmglob)<<MMPR2(save_daily,save_used))
//MM_FAULT
PO po(1<<PO::EVAL); 
Myt::PS ps; ps.debug_os=&std::cerr;  
if (!week)
{
po.date_range(startdate,enddate); 
MM_ERR(MMPR2(startdate,enddate))
x.parse(ps,po);
}else x.parse_week(ps,po);
typedef std::stringstream Ss;
if (dump_dmglob) { 
Ss ss; ss<<ps.dmglob->dump();
//x.save(ss,*(ps.blank));
MM_ERR("%%%%% dump of dmglob ") MM_ERR(ss.str()) 
} // dump_dmglob
std::vector<StrTy> no;

typedef mjm_ragged_table Ragged;
Ragged d,used;
// void dog_daily(Ragged & d, Ragged * used,noun_order &no, const IdxTy flags)
ps.dmglob->dog_daily(d, & used, no,flags);
if (dump_rest) { 
Ss rr;
rr<<"%%%%% dump of d or daily dog report "<<CRLF ;
d.dump_os(rr,3);
rr<<"%%%%% dump of used or inventory report  "<<CRLF ;
used.dump_os(rr,3);
MM_ERR(rr.str()) 
 } // dump_rest

if (save_dmglob) {std::ofstream osf(glob.c_str()); 
osf<<(*(ps.dmglob)).dump(); }
if (save_daily) {std::ofstream osf(daily.c_str()); d.dump_os(osf,3); }
if (save_used) {std::ofstream osf(usedd.c_str()); used.dump_os(osf,3); }

}



if (cmd=="load") { x.load(cip.p1);  MM_ERR("loading "<<MMPR(x.dump()))  }
//if (cmd=="load-form") { x.load_form(cip.p1);  MM_ERR("loading "<<MMPR(x.dump()))  }
if (cmd=="load-form") { x.set_file(cip.p1); x.load_form();  
// MM_ERR("loading "<<MMPR(x.dump()))  
}
if (cmd=="load-units") { x.load_units(cip.p1);  
// MM_ERR("loading "<<MMPR(x.dump()))  
}
if (cmd=="load-nouns") { x.load_nouns(cip.p1);  
//MM_ERR("loading "<<MMPR(x.dump()))  
}
if (cmd=="load-finder") { x.load_finder(cip.p1);  
//MM_ERR("loading "<<MMPR(x.dump()))  
}

if (cmd=="load-ignores") { x.load_ignores(cip.p1);  
//MM_ERR("loading "<<MMPR(x.dump()))  
}
if (cmd=="load-reserveds") { x.load_reserveds(cip.p1);  
// MM_ERR("loading "<<MMPR(x.dump())) 
 }
if (cmd=="load-recipes") { x.load_recipes(cip.p1);  MM_ERR("loading "<<MMPR(x.dump()))  }
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="nouns") {x.index();  MM_ERR(x.dump_nouns()) }
if (cmd=="expand") {
MM_ERR(" expand "<<MMPR3(cip.line(),cip.p1, cip.p2));
x.set_expansion(cip.p1,atoi(cip.p2.c_str()));  }
//if (cmd=="xxx") { x.xxx(); }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DIET_DIARY_FORM_H__ 
