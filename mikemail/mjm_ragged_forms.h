#ifndef MJM_RAGGED_FORMS_H__
#define MJM_RAGGED_FORMS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


#include "mjm_instruments.h"
#include "mjm_collections.h"
#include "mjm_pawnoff.h"
#include "mjm_misc_parse.h"
#include "mjm_read_buffer.h"

#include "mjm_constrained_file.h"
 
// Mon Jul 27 18:40:40 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ragged_forms   
// g++ -std=gnu++11 -DTEST_MJM_RAGGED_FORMS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ragged_forms.h  -lpthread -lreadline

template <class Tr>
class mjm_ragged_forms 
{
 typedef mjm_ragged_forms Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
protected:
typedef mjm_ragged_table Ragged;
typedef mjm_pawnoff<Tr> Hand;
typedef mjm_var_parse<Tr> CharClass;
typedef mjm_read_buffer<Tr> Rb;
typedef mjm_constrained_file<Tr> BackingFile;

public:
mjm_ragged_forms():m_use_file(false) {}
~mjm_ragged_forms() {}
const static IdxTy bad() { return ~0; } 
enum {BAD= ~0};
IdxTy size() const { return m_form.size();}
void load( const IdxTy flags=0) { Load(flags); }  
void save( const IdxTy flags=3) { Save(flags); }  
void load(const StrTy fn, const IdxTy flags=0) 
//{ std::ifstream is(fn); Load(is,m_form,flags); }
{  Load(fn,flags); }
void load(std::istream & is,  const IdxTy flags=0) { Load(is,m_form,flags); } 
void load(std::istream & is, Ragged &r, const IdxTy flags=0) { Load(is,r,flags); } 
void save( std::ostream & os, Ragged & r,  const IdxTy flags=3) { Save(os,r,flags); } 
void save( const  StrTy & fn, Ragged & r,  const IdxTy flags=3) { Save(fn,r,flags); } 
void use_dir(const StrTy & dir ) { m_use_file=true; m_file.root_path(dir); }
void set_file(const StrTy & f ) { m_use_file=true; m_file.rel_path(f); }
void mkpath(const StrTy & f ) { m_use_file=true; m_file.mkpath(f); }
const StrTy & full() const {return m_file.full(); } 
StrTy dump(const IdxTy flags=3) { return Dump(flags); }
protected:
Ragged & form(Myt &x ) { return x.m_form; } 
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=3) {Ss ss; ss<<m_form.dump(3); return ss.str(); }
StrTy Dump(const IdxTy flags=3) {Ss ss; ss<<m_form.dump(flags); return ss.str(); }
StrTy Dump(const Ragged & r, const IdxTy flags=3) 
{Ss ss; ss<<r.dump(flags); return ss.str(); }

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn, Ragged & r,  const IdxTy flags=3)
{ std::ofstream os(fn); os<<r.dump(flags); }
void Save( std::ostream & os, Ragged & r,  const IdxTy flags=3)
{  os<<r.dump(flags); }

void Save( const IdxTy flags)
{
OsTy * os=m_file.ostream(false);
if (os==0)
{
MM_ERR(" unable to save"<<m_file.dump())
return; 
}
Save(*os,m_form,flags); 
m_file.close(os);

} // Save

void Load( const IdxTy flags)
{
IsTy * is=m_file.istream();
MM_ERR(" loading from m_file "<<MMPR(m_file.full()))
if (is==0)
{
MM_ERR(" unable to load "<<m_file.dump())
return; 
}
Load(*is,m_form,flags); 
m_file.close(is);
} // Load

void Load(const StrTy & fn ,  const IdxTy flags)
{
if (m_use_file )
{
MM_ERR(" should use the file facility here "<<MMPR2(fn,flags))
}
Load(m_form,fn,flags); 
// std::ifstream is(fn); 
//Load(is,m_form,flags); 
} // Load

void Load(Ragged & r,const StrTy & fn ,  const IdxTy flags)
{
Rb rb(fn);
rb.split_and_mark(',');
const IdxTy n=rb.string_count();
for(IdxTy j=0; j<n; ++j){  
MM_ERR(MMPR3(fn,rb[j],j))
std::ifstream is(rb[j]); 
Load(is,r,flags); 
} 
//MM_FAULT
}  // Load

void Load(IsTy & is , Ragged & r,  const IdxTy flags)
{
const bool csv=Bit(flags,1);
CommandInterpretter li(&is);
li.set_split(6,csv?',':' ');
//m_form.load(li,0);
r.load(li,0);

}
// members
Ragged m_form;
Hand m_hand;
CharClass m_cc;
BackingFile m_file;
bool m_use_file;
}; // mjm_ragged_forms

//////////////////////////////////////////////

template <class Tr>
class mjm_ragged_forms_map : public std::map<typename Tr::StrTy, mjm_ragged_forms< Tr > >  
{
 typedef mjm_ragged_forms_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ragged_forms< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ragged_forms_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ragged_forms_map




////////////////////////////////////////////
#ifdef  TEST_MJM_RAGGED_FORMS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ragged_forms <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_RAGGED_FORMS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_ragged_forms<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="load") { x.load(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_RAGGED_FORMS_H__ 
