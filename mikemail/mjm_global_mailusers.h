#ifndef MJM_GLOBAL_MAILUSERS_H__
#define MJM_GLOBAL_MAILUSERS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include "mjm_collections.h"
#include "mjm_string_tokenizer.h"
#include "mjm_canned_methods.h"
#include "mjm_generic_message.h"
#include "mjm_read_buffer.h"
#include "mjm_canned_methods.h"
// this creates loop doh  parameter class defs here now 
//#include "mjm_mailproc/mjm_mailproc_handler.h"

#include "mjm_pawnoff.h"
// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"
#ifdef  TEST_MJM_GLOBAL_MAILUSERS
#include "./mjm_message_store.h"
#endif


// Fri Aug 21 10:52:44 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_global_mailusers   
// g++ -std=gnu++11 -DTEST_MJM_GLOBAL_MAILUSERS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_global_mailusers.h  -lpthread -lreadline

template <class Tr>
class mjm_global_mailusers 
{
 typedef mjm_global_mailusers Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

protected:
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;

typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_read_buffer<Tr>  Rb;


typedef string_tokenizer St;
typedef IdxTy TokTy;


class _user_desc
{
typedef _user_desc Myt;
typedef StrTy User;
typedef TokTy Domain;
typedef IdxTy Bits;
typedef std::map<TokTy,Bits> Groups;
typedef mjm_canned_methods Canned;


enum { B4=0, REGISTERED=1,WASREGISTERED=2,AUTOREPLY=3, IGNORE=4,LOG=5 };

public:
_user_desc() { Init(); }
_user_desc(const Myt & that ) { Copy(that); }
_user_desc(const Line & l ) { Init(); Setup(l); }
Line line( ) { return  ToLine(); }
bool test(const IdxTy flags) const  { return Mask(m_history,flags); }  
static IdxTy bit_def(const StrTy& s)   { return BitDef(s); } 
bool registered() const { return Bit(m_history,REGISTERED); } 
bool ignore() const { return Bit(m_history,IGNORE); } 
bool b4() const { return Bit(m_history,B4); } 
void  set_registered()  { Set(REGISTERED,true);  } 
void  set_ignore()  { Set(IGNORE,true);  } 
void  set_b4()  { Set(B4,true);  } 
Myt& operator=(const Myt & that ) {Copy(that); return *this;  }  
const StrTy & user() const { return m_user; } 
bool changed() const { return m_changed; } 
void user(const StrTy & u ) { if (u!= m_user ){ m_user=u; m_changed=true; } } 
static IdxTy flag(const StrTy & exp) { return Flag(exp); } 
void set(const IdxTy b) { Set(b,true); }
void reset(const IdxTy b) { Set(b,!true); }

StrTy dump () 
{ Ss ss; 
//Bits m_history; Groups m_groups; bool m_changed;

ss<<MMPR4(m_user,m_domain,m_blacklist,m_whitelist); 
ss<<MMPR3(m_history,m_groups.size(),m_changed);
ss<<MMPR3(b4(),ignore(),registered());
return ss.str(); } 
protected:
static IdxTy Flag(const StrTy & exp) { 

return Flag(exp); 

} 
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
bool Mask(const IdxTy f, const IdxTy mask) const  { return  ((f&mask)!=0); }
void Or(const IdxTy m, const bool pol )
{
const IdxTy oh=m_history;
m_history=pol?(m_history|m):(m_history&(~m));
if (m_history !=oh) m_changed=true;
}
void Set(const IdxTy b, const bool pol)
{
const IdxTy m=(1<<b);
const bool cx=(pol!=Mask(m_history,m));
if (cx) { m_history=(pol)?(m_history|m):(m_history &(~m));   } 
m_changed|=cx;
} // Set

//cpputil -ienumc bit_def
// needs to make a cool compiled literal lol. 
static IdxTy BitDef(const StrTy& s)  
{
static std::map<StrTy, IdxTy> m;
static bool found=false;
if (!found)
{
found=true;

m["B4"]=B4; 
m["REGISTERED"]=REGISTERED; 
m["WASREGISTERED"]=WASREGISTERED; 
m["AUTOREPLY"]=AUTOREPLY; 
m["IGNORE"]=IGNORE; 
m["LOG"]=LOG; 
} // !found
auto ii =m.find(s);
if (ii==m.end()) return ~0; 
return (*ii).second;
} // bit_def 

void Init()
{
m_domain=0;
m_blacklist=0;
m_whitelist=0;
m_history=0; 
} // Init
void Setup(const Line & l)
{
const IdxTy sz=l.size();
IdxTy i=0;
if (i>=sz) return;
m_user=l[i];
++i;
for(; i<sz; ++i)
{
const StrTy & w=l[i];
if (w=="history") { U(m_history,l,i,sz); continue; } 

} // i 
MM_ERR(" exist SETUP "<<MMPR2(m_history,m_user))
} // Setup

//Line line( ) { return  ToLine(); }
Line ToLine() {
Line l;
l.push_back(m_user);
l.push_back("history");
Ss ss; ss<<m_history;
l.push_back(ss.str()); 
return l;
} // ToLine


bool U(StrTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{ ++i; if (i>=sz) return false; x=(l[i]); return true; }
bool U(IdxTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{ ++i; if (i>=sz) return false; x=myatoi(l[i]); return true; }

// canned is a dumb header doh
int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
int myatoi(const char * c) const { return Canned::myatoi(c); }


void Copy(const Myt & that ) 
{ 
 m_user = that.m_user;
 m_domain=that.m_domain;
 m_blacklist=that.m_blacklist;
 m_whitelist=that.m_whitelist;
 m_history=that.m_history;
 m_groups=that.m_groups;
 m_changed=that.m_changed;

}// that

User m_user;
Domain m_domain;
Bits m_blacklist;
Bits m_whitelist;
Bits m_history;
Groups m_groups;
bool m_changed;

Rb m_rb;
// history etc


}; // _user_desc

public:
typedef _user_desc user_desc;
typedef std::map<StrTy,user_desc> Umap;

mjm_global_mailusers() {Init(); }
~mjm_global_mailusers() {if (m_changed) save();  }
void fn( const StrTy& fn) { m_fn=fn; }
void load() { Load(); } 
void save() {Save(); }  
const IdxTy size() const { return m_umap.size(); }
const user_desc & look_up(const StrTy & u)const  {return LookUp(u); }
user_desc  look_up(const StrTy & u) {return LookUp(u); }
void set(user_desc & ud) { 
if (ud.changed())  { m_umap[ud.user()] =ud; m_changed=true;  save();} 
} 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
protected:
void Load()  { 
// this loads m_users but not the map 
m_users.load(m_fn); 
for(IdxTy i=0; i<m_users.size(); ++i)
{ user_desc ud= user_desc(m_users[i]); 
MM_ERR(" loading histor "<<MMPR2(ud.user(),ud.b4()))
m_umap[ud.user()]=ud;
} // i 
MM_ERR(" user list LOADED SIZE SSSSS "<<MMPR2(m_users.size(),m_umap.size()))
} 
void Save(){ 
// convert umap back into m_users. 
m_users.clear();
MM_LOOP(ii, m_umap) { m_users.add((*ii).second.line()); } // ii 
m_users.save(m_fn,3); m_changed=false; } 
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
user_desc & LookUp(const StrTy & u) { 
MM_ERR(" history fuced look find "<<u)
auto ii=m_umap.find(u);
if (ii!=m_umap.end()) return (*ii).second; 
MM_ERR(" history fuced no find "<<u)
return m_def; }
const user_desc & LookUp(const StrTy & u)const { 
MM_ERR(" history fuced look find "<<u)
auto ii=m_umap.find(u);
if (ii!=m_umap.end()) return (*ii).second; 
MM_ERR(" history fuced no find "<<u)
return m_def; }
// should loop over map now 
virtual StrTy Dump(const IdxTy flags=0) {Ss ss; 
MM_LOOP(ii,m_umap) { ss<<(*ii).first<<" "<<(*ii).second.dump() <<CRLF; } 
 return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Init()
{
m_changed=false;

} // Init 
// members
StrTy m_fn;
Ragged m_config,m_users;
bool m_changed;
user_desc m_def;
Umap m_umap;
}; // mjm_global_mailusers

//////////////////////////////////////////////

template <class Tr>
class mjm_global_mailusers_map : public std::map<typename Tr::StrTy, mjm_global_mailusers< Tr > >  
{
 typedef mjm_global_mailusers_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_global_mailusers< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_global_mailusers_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_global_mailusers_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLOBAL_MAILUSERS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_global_mailusers <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLOBAL_MAILUSERS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_global_mailusers<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLOBAL_MAILUSERS_H__ 
