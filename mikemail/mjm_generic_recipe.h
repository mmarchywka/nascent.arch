#ifndef MJM_GENERIC_RECIPE_H__
#define MJM_GENERIC_RECIPE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_compiled_noun.h"
#include "mjm_unit_crap.h"
// faster than calling date in bash doh 
#include "mjm_calendar.h"
#include "mjm_collections.h"
#include "mjm_diary_parse_error.h"
#include "mjm_loo_parsing.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Mon Oct 12 13:37:33 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_generic_recipe   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GENERIC_RECIPE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_generic_recipe.h  -lpthread -lreadline

template <class Tr>
class mjm_generic_recipe 
{
 typedef mjm_generic_recipe Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_ragged_table Ragged;
typedef typename Ragged::Line Line;
typedef StrTy Word;
typedef std::vector<Word> Words;
typedef std::map<StrTy, IdxTy> DictTy;
typedef std::map<StrTy, StrTy> Properties;
//typedef typename Super::CharClass CharClass;
//typedef mjm_constrained_file<Tr> BackingFile;
//ZZZZBackingFile m_file;
//typedef typename CharClass::read_buffer Rb;

typedef mjm_unit_crap<Tr> Units;
typedef typename Units::qty_dim Qdim;
typedef std::map<StrTy, int > ModMap;
typedef std::map<StrTy, Qdim > AmtMap;

typedef mjm_loo_parsing<Tr> Loo;

typedef std::map<StrTy,int> GroupMap;

typedef mjm_compiled_noun<Tr> Cnoun;
public:
typedef mjm_diary_parse_error<Tr> parse_error;


mjm_generic_recipe() {Init();}
mjm_generic_recipe(const Line & l ) 
{Init(); IdxTy lx=0, wx=0;  Parse(l,lx,wx); }
~mjm_generic_recipe() {}
template <class Te > 
IdxTy parse(Ragged* r, IdxTy& line, IdxTy& word, Te * ev)
{return Parse(r,line,word,ev); } 
IdxTy parse(Ragged* r, IdxTy& line, IdxTy& word)
{return Parse(r,line,word,(void*)0); } 

IdxTy load(const StrTy & fn) { return Load(fn); } 

// how it is refernced in a data file 
const StrTy & name() const { return m_name; } 
// number of words used to define the verb from a Ragged
IdxTy words_used() const { return m_words_used; } 
// how to define this in terns of known nouns. May equal name. 
// quantities should be PER SERVING although this wil be a mistake lol 
const Line & noun_result() const { return m_noun_line; }
const D servings() const { return m_servings; } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
IdxTy bad() const { return ~0; } 
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }

IdxTy Load(const StrTy & fn) { 
Ragged r;
std::ifstream is(fn);
Loo::load(is,r,0);
IdxTy line=0, word=0;
parse(&r,line,word);
m_recipe=0; // goes out of scope
return 0; 

} 


template <class Te > 
IdxTy Parse(Ragged* r, IdxTy& line, IdxTy& word,Te * ev){
IdxTy rc=0;
m_li=line;
m_wi=word;
ev->push_back(parse_error(0,0,"adcasdc"));
return rc; // Parse(r,line,word); 
}  // Parse
//template <class Te > 
IdxTy Next(Ragged* r, IdxTy& line, IdxTy& word,const IdxTy sz, IdxTy * c)
{
if (line>=sz) return ~0; 
++word;
if (word>=(*r)[line].size()) { ++line; word=0; }
if (line>=sz) return ~0; 
if (c) ++(*c); 
return 0;
}
IdxTy Parse(Ragged* r, IdxTy& line, IdxTy& word,void * ev){
//MM_ERR(" parsing "<<MMPR2(line,word))
const IdxTy rsz=r->size();
IdxTy rc=0;
m_li=line;
m_wi=word;
if ( word!=0) 
{m_words_skipped+=(*r)[line].size()-word;  ++line; word=0; if(line>=rsz) return rc; }
while (true)
{
//MM_ERR(" parsing "<<MMPR2(line,word))
if (line>=rsz) { rc=1;  return rc; } 
const Line & l=(*r)[line];
if (l.size()==0) { ++line; continue; }
if (l[0]=="RECIPE"){ ++m_words_used; ++word;  break; } 
m_words_skipped+=l.size()-word;
++line;
} // while 
const Line & l=(*r)[line];
rc= Parse( l, line,  word, ev);
#if 0
const IdxTy lsz=l.size();
if (lsz<2) { rc=2; return rc; } 
m_name=l[1];
++m_words_used;
IdxTy i=2;
for(; i<lsz; ++i)
{
MM_ERR(" parsing "<<MMPR2(line,word))
//if (word>=l.size()) { rc=1; return rc; } 
const Word & w=l[i];
if (w=="NOUNLINE") {Loo::TakeLine(m_noun_line,i,l,lsz); }
else if (w=="prop") {Loo::TakeProperties(m_prop,i,l,lsz,StrTy()); }
else if (w=="code") {Loo::TakeCode(m_code,i,l,lsz); }
else if (w=="ingredients") {Loo::TakeProperties(m_ing,i,l,lsz,Qdim()); }
else if (w=="servings") {Loo::NextFloat(m_servings,i,l,lsz); }
} // i  
m_words_used+=i-2;
#endif

return rc; // Parse(r,line,word); 
}  // Parse

IdxTy Parse(const Line & l, IdxTy& line, IdxTy& word,void * ev)
{
IdxTy rc=0;
const IdxTy lsz=l.size();
if (lsz<2) { rc=2; return rc; } 
if (l[0]!="RECIPE") { rc=~0; return rc; } 
m_name=l[1];
++m_words_used;
IdxTy i=2;
for(; i<lsz; ++i)
{
//MM_ERR(" parsing "<<MMPR2(line,word))
//if (word>=l.size()) { rc=1; return rc; } 
const Word & w=l[i];
// Real world- invented date . inventor, entered, source, obsolete date
// RECIPE name [ property k,v,k,v... ] [ bibtex ] [ url ] [ upc ]   \\ } 
// when reporting, this is how the recipe is expanded
if (w=="NOUNLINE") {Loo::TakeLine(m_noun_line,i,l,lsz); }
else if (w=="prop") {Loo::TakeProperties(m_prop,i,l,lsz,StrTy()); }
else if (w=="groups") {Loo::TakeCount(m_groups,i,l,lsz); }
else if (w=="bibtex") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="bomtex") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="UPC") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="text") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="startdate") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="enddate") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="source") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="inventor") {Loo::TakeString(m_prop,i,l,lsz);} 
else if (w=="code") {Loo::TakeCode(m_code,i,l,lsz); }
else if (w=="ingredients") {Loo::TakeProperties(m_ing,i,l,lsz,Qdim()); }
else if (w=="servings") {Loo::NextFloat(m_servings,i,l,lsz); }


} // i  
m_words_used+=i-2;
return rc;
} // Parse line 

// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR2(m_name,m_servings);
ss<<MMPR2( m_li,m_wi);
ss<<MMPR4( m_lf,m_wf,m_words_skipped,m_words_used);
ss<<" m_noun_line ";
MM_LOOP(ii,m_noun_line) { ss<<" "<<(*ii); } 
MM_LOOP(ii,m_prop) { ss<<" prop  "<<(*ii).first<<"="<<(*ii).second; } 
MM_LOOP(ii,m_ing) { ss<<" ingredient  "<<(*ii).first<<"="<<(*ii).second.dump(); } 
MM_LOOP(ii,m_groups) { ss<<" group  "<<(*ii).first<<"="<<(*ii).second; } 
ss<<" code ";
m_code.string(ss,0);
if (true) { 
ss<<CRLF;
MM_LOOP(ii,m_code)
{
const Line & l=(*ii);
MM_LOOP(jj,l) { ss<<(*jj)<<"\t";  }
ss<<CRLF;

} // ii 
} // if 
return ss.str(); 

}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Init()
{
m_recipe=0;
m_li=0; m_wi=0;
m_lf=0; m_wf=0;
m_words_skipped=0;
m_words_used=0;
m_servings=0;
}
// members
// nouns,verbs,units
Ragged * m_recipe;
// location in m_recipe if not null; 
IdxTy m_li,m_wi;
IdxTy m_lf,m_wf,m_words_skipped,m_words_used;

// RECIPE name [ property k,v,k,v... ] [ bibtex ] [ url ] [ upc ]   \\ } 
//
// NOUNLINE  n-WORDs.... \\ } 
// last entry on the line : 
// code { {label:} verb {operands ... } \\  } 
StrTy m_name;
D m_servings;
// Real world- invented date . inventor, entered, source, obsolete date

// Bibtex, citations.  
//  Properties - open ended free text. 
Properties m_prop;

GroupMap m_groups;
// Ingredients - Noun list including UPC or bomtex AND amounts 
AmtMap m_ing;
// noun_evaluations???

// Resources- non-consumable nouns or tools, time, etc 
// More nouns and maybe "time"

// Noun list, prepared result can include adjectives that may indicate
// degradation etc- char broiled etc...
Line m_noun_line;
// Instructions- executes on Kitchen Virtual Machine but just text here...
//  verb operand, operand ...
Ragged m_code;

}; // mjm_generic_recipe
///////////////////////////////////////////////////////////////

template <class Tr> 
class mjm_recipe_collection 
{
typedef mjm_recipe_collection Myt;
typedef mjm_generic_recipe<Tr> Tgt;
//typedef  mjm_ragged_forms<Tr>  Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef std::vector<Tgt> Tgts; 
typedef std::map<StrTy, Tgts> TgtMap;
typedef typename TgtMap::iterator Itor;
typedef typename TgtMap::const_iterator CItor;

typedef mjm_ragged_table Ragged;
typedef typename Ragged::Line Line;
typedef StrTy Word;

public:

const IdxTy size() const { return m_map.size(); }
Tgts & operator[](const StrTy & k) { return m_map[k];}
const Tgts & operator[](const StrTy & k)const  { return m_map[k];}
Itor find(const StrTy & k) { return m_map.find(k); } 
CItor find(const StrTy & k)const { return m_map.find(k); } 

Itor begin() { return m_map.begin(); }
CItor begin()const  { return m_map.begin(); }

Itor end()  { return m_map.end(); }
CItor end()const  { return m_map.end(); }
void clear() { m_map.clear(); } 

void load(const Ragged & r) { Load( r); }
template <class Tm> void index_groups(Tm & m ) { IndexGroups(m); } 

private:
template <class Tm> void IndexGroups(Tm & m )
{
MM_LOOP(ii,m_map)
{
const StrTy  & nm=(*ii).first;
const Tgts & vec=(*ii).second;
MM_LOOP(jj,vec)
{
const Tgt & cn=(*jj);
const Tgt * p=&cn;
MM_LOOP(kk,cn.groups())
{
m[(*kk).first].push_back(p);
} // kk 
} // jj 
} // ii 

} // IndexGroups
void Load(const Ragged & r)
{
MM_LOOP(ii,r)
{
//IdxTy i=(*ii).second;
const Line & l =(*ii); // m_nouns[i]; 
if (l.size()==0) continue;
//m_cnouns[i]=Cnoun(l);
m_map[l[0]].push_back(Tgt(l));
} // ii 

} // Load

TgtMap m_map;

}; // mjm_recipe_collection





//////////////////////////////////////////////

template <class Tr>
class mjm_generic_recipe_map : public std::map<typename Tr::StrTy, mjm_generic_recipe< Tr > >  
{
 typedef mjm_generic_recipe_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_generic_recipe< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_generic_recipe_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_generic_recipe_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GENERIC_RECIPE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_generic_recipe <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GENERIC_RECIPE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_generic_recipe<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load(cip.p1); MM_ERR(x.dump()) }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GENERIC_RECIPE_H__ 
