#ifndef MJM_LINE_ISTREAMS_H__
#define MJM_LINE_ISTREAMS_H__

#define LINE_LOCK_MM_ERR

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_read_buffer.h"

#include <dirent.h>
#include <math.h>
#include <time.h>
#include <unistd.h>
#include <iostream>
#include <stdexcept>
#include <exception>
#include <typeinfo>
#include <stdio.h>
#include <string>

#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
// rand()
#include <stdlib.h>
#include <stdint.h>
#include <streambuf>
#include <iostream>


#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <exception>
#include <stdexcept>

//#define MM_VERR MM_ERR
#define MM_VERR(x) 

// g++ -std=gnu++11 -DTEST_ISTREAMS -I. -I../../mjm/hlib -gdwarf-3 -O0  -x c++ mjm_line_istreams.h  -lpthread

// g++ -std=gnu++11 -DTEST_ISTREAMS -I. -I../../mjm/hlib -x c++ mjm_line_istreams.h  -lpthread

// exception handling needs this, 
// g++ -std=gnu++11 -DTEST_ISTREAMS -I. -I../../mjm/hlib -x c++ mjm_line_istreams.h 
//  g++  -DTEST_ISTREAMS -I. -I../../mjm/hlib -x c++ mjm_line_istreams.h  


// Thu May  9 04:59:29 EDT 2019
// generated by -classhdr mjm_line_istreams  


template <class Tr>
class myrdbuf : public std::streambuf , mjm_thread_util<Tr>::locks
{
public:

 typedef myrdbuf Myt;
typedef typename mjm_thread_util<Tr>::locks Locks;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef uint64_t KeyCode;
//typedef typename mjm_read_buffer<Tr> Rb;
typedef  mjm_read_buffer<Tr> Rb;
// typedef typename Tr::MyBlock  MyBlock;
typedef typename std::streambuf Sb;
typedef typename std::streamsize Sz;
typedef typename std::streampos Sp;
typedef typename std::streamoff So;
typedef typename std::ios_base::seekdir Sseek;
typedef typename std::ios_base::openmode Smode;
typedef char Ch;
enum { RW_MU=0 , KLUGE_MU, MU_SZ};
public:
// custom API
myrdbuf():Locks(MU_SZ) {Init(); }
~myrdbuf() {Release(); }

// unsafe 
Ch * dest() { 
MM_VERR("dest")
Enter(RW_MU);
Ch * x= m_buf+m_end; 
Exit(RW_MU);
return x; 
}
IdxTy space() { 
MM_VERR("space")
Enter(RW_MU);
m_ptr=gptr()-m_buf; // the synchronization here is wrong. 
IdxTy x=(m_end<m_ptr)?(m_ptr-m_end):( m_sz-m_end);
Exit(RW_MU);
MM_VERR("space "<<MMPR4(x,m_ptr,m_end,m_sz))
return x; 
 } 

void dest(Ch ** p, IdxTy & space) { 
MM_VERR("dest")
Enter(RW_MU);
Ch * pp= m_buf+m_end; 
*p=pp;
m_ptr=gptr()-m_buf; // the synchronization here is wrong. 
IdxTy x=(m_end<m_ptr)?(m_ptr-m_end):( m_sz-m_end);
space=x;
Exit(RW_MU);
MM_VERR("space "<<MMPR4(x,m_ptr,m_end,m_sz))
//return x; 
 } 





void delivered(const IdxTy n) { 
MM_VERR("deliver")
Enter(KLUGE_MU);
Enter(RW_MU);
m_end+=n;
m_ptr=gptr()-m_buf; // the synchronization here is wrong. 
//if (m_end==m_sz) m_end=0;
//if (m_end>m_ptr) 
setg(m_buf+m_ptr, m_buf+m_ptr,m_buf+m_end);
MM_VERR(" setgg "<<MMPR2(m_ptr,m_end))
//else setg(m_buf, m_buf+m_ptr,m_buf+m_end);

Exit(RW_MU);
Exit(KLUGE_MU);
MM_VERR("delivered  "<<MMPR3(m_ptr,m_end,m_sz))
} 

void done() { 
Enter(RW_MU);
m_delivered=true;
Exit(RW_MU);}

 protected:
void Enter(const IdxTy i) {this->EnterSerial(i); }
void Exit(const IdxTy i) {this->ExitSerial(i); }


// istream API
virtual Sb* setbuf (char* s, Sz n)
{
m_buf=s; m_sz=n;
MM_VERR(MMPR(n))
return this; 
} // setbuf
virtual Sp  seekoff (So off, Sseek way,
                   Smode which = std::ios_base::in | std::ios_base::out)
{
MM_VERR(MMPR3(off,way,which))
return 0;
}
virtual Sp seekpos (Sp sp, Smode which = std::ios_base::in | std::ios_base::out)
{
MM_VERR(MMPR(sp))

return 0;
}
virtual int sync()
{ return 0; }
virtual  Sz showmanyc()
{
MM_VERR("showmany")
Enter(RW_MU);
Sz new_ptr=gptr()-m_buf; // the synchronization here is wrong. 
Sz old_ptr=m_ptr;
m_ptr=gptr()-m_buf; // the synchronization here is wrong. 
if (m_ptr==m_sz)
{
// we need contig for delivery otherwise this is dumb 
m_ptr=0; 
if (m_end==m_sz) m_end=0; 
setg(m_buf, m_buf+m_ptr,m_buf+m_end);
MM_VERR(" setgging "<<MMPR2(m_ptr,m_end))
}
Sz s=(m_end<m_ptr)?(m_sz-m_ptr):(m_end-m_ptr);
Exit(RW_MU);
MM_VERR(" showmany "<<MMPR4(s,new_ptr,old_ptr,m_end))
return s; }
virtual Sz xsgetn (char* s, Sz n)
{
MM_VERR(MMPR(n))
return 0; 
}
virtual int underflow() { MM_VERR("underflow") 
// let the other stuff run while access is disabled. 
Exit(KLUGE_MU);
while ( showmanyc()==0)
{
MM_VERR(" underflow wait")
Enter(RW_MU);
if (m_delivered){ MM_VERR(" return EOF") Exit(RW_MU); return EOF; } 
Exit(RW_MU);
//usleep(10);
pthread_yield();
}
MM_VERR(" underflow returning "<<MMPR(showmanyc()))

Enter(KLUGE_MU);
auto x=sgetc();
MM_VERR(MMPR2(x,EOF))
// return sbumpc(); 
 return x; //  sgetc(); 

} // needs an eof call char_traits::eof()
virtual int uflow() { MM_VERR("uflow")  

Exit(KLUGE_MU);
while ( showmanyc()==0)
{
MM_VERR(" uflow wait")
Enter(RW_MU);
if (m_delivered){ Exit(RW_MU); MM_VERR("return EOF")  return EOF; } 
Exit(RW_MU);
//usleep(10);
pthread_yield();
}
MM_VERR(" uflow returning "<<MMPR(showmanyc()))

Enter(KLUGE_MU);
auto x=sbumpc();
MM_VERR(MMPR2(x,EOF))
// return sbumpc(); 
 return x; //  sgetc(); 
//return sbumpc(); 
//return EOF; 


} // needs an eof call char_traits::eof()
virtual int pbackfail(int c=EOF) { MM_VERR(" pbackfail")  return EOF; } // needs an eof call char_traits::eof()

private:
void Init()
{
MM_VERR("iinit")
m_sz=1<<25;
m_buf= new Ch[m_sz];
m_ptr=0;
m_end=0;
m_delivered=false;
setg(m_buf, m_buf+m_ptr,m_buf+m_end);
Enter(KLUGE_MU);
}
void Release()
{
MM_VERR("release must be called by consumer ")
Exit(KLUGE_MU);
delete [] m_buf;

}

Ch * m_buf;
IdxTy m_sz,m_ptr,m_end;
bool m_delivered;

}; // myrdbuf





template <class Tr>
class mjm_line_istreams  : public mjm_thread_util<Tr>::locks
{
 typedef mjm_line_istreams Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef uint64_t KeyCode;
// typedef typename Tr::MyBlock  MyBlock;

public:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
typedef typename mjm_thread_util<Tr>::locks Locks;

enum { MAP_MU=0 , MU_SZ};

mjm_line_istreams():Locks(MU_SZ) {}


private:

//mutable MutexVector m_mutex_vector;


//void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
//void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

void Init()
{
//m_mutex_vector = MutexVector(MU_SZ);
}


private:


}; // mjm_line_istreams


template <class Tr>
class mjm_line_istream  : public std::istream , mjm_thread_util<Tr>::locks
{
typedef  std::istream Super;
typedef  typename mjm_thread_util<Tr>::locks Locks;
 typedef mjm_line_istream Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef typename std::streambuf Sb;
typedef typename std::streamsize Sz;
typedef typename std::streampos Sp;
typedef typename std::streamoff So;
typedef typename std::ios_base::seekdir Sseek;
typedef typename std::ios_base::openmode Smode;
typedef  myrdbuf<Tr> Rdb;

typedef uint64_t KeyCode;
typedef int Fd;
typedef  mjm_thread_util<Tr> ThreadUtil;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
public:
//typedef typename mjm_thread_util<Tr>::locks Locks;
enum { BAD=~0};
enum { MAP_MU=0 , MU_SZ};

//mjm_line_istreams():Locks(MU_SZ) {}
//mjm_line_istream():Locks(MU_SZ) {Init(); }
//mjm_line_istream(Rdb * p ):Locks(MU_SZ)  {m_sb=p;  }

mjm_line_istream(const StrTy & fn ):Locks(MU_SZ) {m_fn=fn; Init(); }
~mjm_line_istream( ) {Release(); }
void launch() { Launch(); } 
/*
Super & getline(char * s, Sz n)
{
MM_ERR(" called ok ")
return *this; } 

Super & getline(char * s, Sz n, char delim)
{
MM_ERR(" called ok ")
return *this; 
}
*/
private:
void Release()
{
delete m_sb;
}
void Init()
{
m_sb=new Rdb();
rdbuf(m_sb);
//m_fd=open(m_fn.c_str(),O_RDONLY|O_DIRECT);
m_fd=open(m_fn.c_str(),O_RDONLY);
MM_ERR(MMPR2(m_fn,m_fd))
//m_mutex_vector = MutexVector(MU_SZ);
}
class P
{
public:
P(Fd n, Myt* _p) : p(_p),fd(n) {}
Myt * p;
Fd fd;

}; // P 
void Launch()
{
P*  p= new P(m_fd,this);
//P* pp=&p;
ThreadUtil::fire_and_forget(1,&Myt::Thread , (void*) p);
}

static void* Thread(void * p)
{
MM_ERR(" launder starts")
try {
P* pp=(P*)p;
((*pp).p)->Load();
} catch (...) 
{
CatchDot3();
}

MM_ERR(" launder ends")
return 0;
} // Thread 

static void CatchDot3()
{
   // https://stackoverflow.com/questions/315948/c-catching-all-exceptions
  std::exception_ptr pe = std::current_exception();
  MM_ERR((pe ? pe.__cxa_exception_type()->name() : "null"))
}

void Load()
{
ssize_t ntot=0;
while (true)
{
char * buf=0; // m_sb->dest();
IdxTy count=0; // m_sb->space();
m_sb->dest(&buf,count);
if (count==0)
{
//usleep(100);
pthread_yield();
}
else{
//typedef uint64_t KeyCode;
MM_VERR(MMPR2((KeyCode)buf,count))
ssize_t n=::read(m_fd,buf,count);
MM_VERR(MMPR3(n,ntot,count))
if ( n<=0)
{
m_sb->done();
MM_VERR(" breaking "<<MMPR2(n,ntot))
break; 
}
m_sb->delivered(n);
ntot+=n; } 
} // while 

} // Load


StrTy m_fn;
Rdb *  m_sb;
Fd m_fd;

}; // mjm_line_istream


template <class Tr>
class mjm_fd2rdbuf  : public  mjm_thread_util<Tr>::locks
{
//typedef  std::istream Super;
typedef  typename mjm_thread_util<Tr>::locks Locks;
 typedef mjm_fd2rdbuf Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef uint64_t KeyCode;
// typedef typename Tr::MyBlock  MyBlock;
typedef typename std::streambuf Sb;
typedef typename std::streamsize Sz;
typedef typename std::streampos Sp;
typedef typename std::streamoff So;
typedef typename std::ios_base::seekdir Sseek;
typedef typename std::ios_base::openmode Smode;
typedef  myrdbuf<Tr> Rdb;

typedef int Fd;
typedef  mjm_thread_util<Tr> ThreadUtil;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
public:
//typedef typename mjm_thread_util<Tr>::locks Locks;
enum { BAD=~0};
enum { MAP_MU=0 , MU_SZ};
class pair
{
public:
pair(const StrTy & f, Rdb * r, const Fd &fd ) 
: m_fn(f),m_sb(r),m_fd(fd),ntot(0),state(0) {}
pair( ) 
: m_fn(),m_sb(0),m_fd(~0),ntot(0),state(0) {}


void done() { m_sb->done();state=1; } 
void delivered(const IdxTy n)
{
m_sb->delivered(n);
ntot+=n;
}
StrTy m_fn;
Rdb *  m_sb;
Fd m_fd;
IdxTy ntot;
IdxTy state;
}; // pair

typedef pair Pair;
typedef std::vector<Pair> Pairs;

mjm_fd2rdbuf( ):Locks(MU_SZ),m_done(false) { Init(); }
~mjm_fd2rdbuf( ) { Quit(); }
void add_pair(const Pair & p) { m_pairs.push_back(p); }
Pair add_pair(const StrTy fn) { 
Rdb * sb=new Rdb();
//rdbuf(m_sb);
Fd fd=open(fn.c_str(),O_RDONLY);
MM_ERR(MMPR2(fn,fd))
Pair p(fn,sb,fd);
m_pairs.push_back(p); return p;  }
void launch() { Launch(); } 
private:
void Init()
{
//m_sb=new Rdb();
//rdbuf(m_sb);
//m_fd=open(m_fn.c_str(),O_RDONLY);
//MM_ERR(MMPR2(m_fn,m_fd))
}
void Quit()
{
m_done=true;


}
class P
{
public:
P() {}
P(Fd n, Myt* _p) : p(_p),fd(n) {}
Myt * p;
Fd fd;

}; // P 
void Launch()
{
P*  p= new P(~0,this);
//P*  p= new P;
//P* pp=&p;
ThreadUtil::fire_and_forget(1,&Myt::Thread , (void*) p);
}

static void* Thread(void * p)
{
MM_ERR(" launder starts")
try {
P* pp=(P*)p;
((*pp).p)->Load();
} catch (...) 
{
CatchDot3();
}

MM_ERR(" launder ends")
return 0;
} // Thread 

static void CatchDot3()
{
   // https://stackoverflow.com/questions/315948/c-catching-all-exceptions
  std::exception_ptr pe = std::current_exception();
  MM_ERR((pe ? pe.__cxa_exception_type()->name() : "null"))
}
IdxTy Connect( Pair & p)
{
IdxTy ntot=0;
char * buf=0;  
IdxTy count=0; 
p.m_sb->dest(&buf,count);
if (count==0) return 0 ; 
//typedef uint64_t KeyCode;
MM_VERR(MMPR2((KeyCode)buf,count))
ssize_t n=::read(p.m_fd,buf,count);
MM_VERR(MMPR3(n,p.ntot,count))
if ( n<=0)
{
//p.m_sb->done();
p.done();
MM_VERR(" breaking "<<MMPR2(n,ntot))
return n; 
}
ntot+=n;
p.delivered(n);
//p.m_sb->delivered(n);
//p.ntot+=n;  
return n;
}
void Load()
{
while (true)
{
MM_LOOP(ii,m_pairs)
{
int n=Connect((*ii));
if (n<=0) return; 
} // ii 
if (m_done) return;
//sleep(1);
//usleep(100);
pthread_yield();
if (m_done) return;
} // true

} // Load
/*
void Load()
{
ssize_t ntot=0;
while (true)
{
char * buf=0; // m_sb->dest();
IdxTy count=0; // m_sb->space();
m_sb->dest(&buf,count);
if (count==0)
{
sleep(1);
}
else{
//typedef uint64_t KeyCode;
MM_VERR(MMPR2((KeyCode)buf,count))
ssize_t n=::read(m_fd,buf,count);
MM_VERR(MMPR3(n,ntot,count))
if ( n<=0)
{
m_sb->done();
MM_VERR(" breaking "<<MMPR2(n,ntot))
break; 
}
m_sb->delivered(n);
ntot+=n; } 
} // while 

} // Load
*/
Pairs m_pairs;
volatile bool m_done;

}; // mjm_fd2rdbuf



template <class Tr>
class mjm_loaded_istream  : public std::istream , mjm_thread_util<Tr>::locks
{
typedef  std::istream Super;
typedef  typename mjm_thread_util<Tr>::locks Locks;
 typedef mjm_loaded_istream Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef uint64_t KeyCode;
// typedef typename Tr::MyBlock  MyBlock;
typedef typename std::streambuf Sb;
typedef typename std::streamsize Sz;
typedef typename std::streampos Sp;
typedef typename std::streamoff So;
typedef typename std::ios_base::seekdir Sseek;
typedef typename std::ios_base::openmode Smode;
typedef  myrdbuf<Tr> Rdb;

typedef int Fd;
typedef  mjm_thread_util<Tr> ThreadUtil;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
typedef mjm_fd2rdbuf<Tr>  F2R;
typedef typename F2R::Pair  F2RP;
public:
//typedef typename mjm_thread_util<Tr>::locks Locks;
enum { BAD=~0};
enum { MAP_MU=0 , MU_SZ};


mjm_loaded_istream(const StrTy & fn ):Locks(MU_SZ) {m_fn=fn; Init(); }
~mjm_loaded_istream( ) {delete m_f2rp; delete m_pair.m_sb;  }
void launch() {  } 
private:
void Init()
{
m_f2rp= new F2R();
// FIXME TODO this needs mutex 
m_pair= m_f2rp->add_pair(m_fn);
//m_sb=new Rdb();
rdbuf(m_pair.m_sb);
//m_fd=open(m_fn.c_str(),O_RDONLY|O_DIRECT);
m_pair.m_fd=open(m_pair.m_fn.c_str(),O_RDONLY);

m_f2rp->launch();
MM_ERR(MMPR2(m_fn,m_pair.m_fd))
//m_mutex_vector = MutexVector(MU_SZ);
}

static void CatchDot3()
{
   // https://stackoverflow.com/questions/315948/c-catching-all-exceptions
  std::exception_ptr pe = std::current_exception();
  MM_ERR((pe ? pe.__cxa_exception_type()->name() : "null"))
}

StrTy m_fn;
F2RP m_pair;
F2R * m_f2rp;
//Rdb *  m_sb;
//Fd m_fd;

}; // mjm_loaded_istream


// just avoid the stream crap 
////////////////////////////////////////////////////////////////////////////////
// this double buffered rather than circular approach may work too although
// not sure of tradeoffs. Avoiding stream interface may be ok 

template <class Tr>
class mjm_byte_source  : public  mjm_thread_util<Tr>::reentrant_locks
{
//typedef  std::istream Super;
typedef  typename mjm_thread_util<Tr>::reentrant_locks Locks;
 typedef mjm_byte_source Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef uint64_t KeyCode;
// typedef typename Tr::MyBlock  MyBlock;
//typedef typename std::streambuf Sb;
//typedef typename std::streamsize Sz;
//typedef typename std::streampos Sp;
//typedef typename std::streamoff So;
//typedef typename std::ios_base::seekdir Sseek;
//typedef typename std::ios_base::openmode Smode;
//typedef  myrdbuf<Tr> Rdb;
typedef char Ch;
typedef mjm_read_buffer<Tr> RdBuf;
typedef int Fd;
typedef  mjm_thread_util<Tr> ThreadUtil;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
//typedef mjm_fd2rdbuf<Tr>  F2R;
//typedef typename F2R::Pair  F2RP;
public:
//typedef typename mjm_thread_util<Tr>::locks Locks;
enum { BAD=~0};
enum { MU_FLIP=0 , MU_FLIP2=1, MU_SZ=2};
mjm_byte_source(const StrTy & fn ):Locks(MU_SZ) {m_fn=fn; Init(); }
~mjm_byte_source( ) {//delete m_f2rp; delete m_pair.m_sb; 
 }


Ch * read_ptr() { return m_b[rdidx()].buf(); }
IdxTy  read_size() { return m_b[rdidx()].size(); }

Ch * write_ptr() { return m_b[wridx()].buf(); }
IdxTy  write_size() { return m_b[wridx()].space(); }
IdxTy  write_space() { return m_b[wridx()].size(); }
void next() { 
EnterMu();
if (!m_flipped)
{
m_b[rdidx()].clear(); 
if ( m_eof){  flip(); m_next=false; } 
else 
m_next=true;
} else {  m_next=false;  m_flipped=false;  } 
ExitMu();
 } 
void read_buf(Ch *& b, IdxTy & n)
{
EnterMu();
if (m_flipped) m_flipped=false;
RdBuf & f=m_b[rdidx()];
b=f.buf(); // m_b[rdidx()];
n=f.size(); // m_b[rd
ExitMu();
}

void write_buf(Ch *& b, IdxTy & n)
{
EnterMu();
RdBuf & f=m_b[wridx()];
b=f.next(); // m_b[rdidx()];
n=f.space(); // m_b[rd
ExitMu();
}
void wrote(const IdxTy n )
{
EnterMu();
m_b[wridx()].appended(n);
if ( m_next&&!m_flipped){  flip(); m_next=false; } 
ExitMu();
} 
// these are all now re-entrant 
const IdxTy rdidx() { EnterMui(); const IdxTy x= m_ff;   ExitMui();  return x;  } 
const IdxTy wridx() { EnterMui(); const IdxTy x= 1-m_ff;   ExitMui();  return x;  } 
//const IdxTy wridx() { return 1-m_ff; } 
void flip() {EnterMu();  //m_b[rdidx()].clear();  
m_ff=1&(m_ff+1); m_flipped=true; ExitMu();   }
bool eof() {if ( !m_eof ) return m_eof; return ((write_space()+read_size())==0);    }
//void launch() {Launch();  } 

private:
void EnterMu() { this->EnterSerial(MU_FLIP); }
void ExitMu() { this->ExitSerial(MU_FLIP); }
// wtf not re-entrant???? 
void EnterMui() { this->EnterSerial(MU_FLIP); }
void ExitMui() { this->ExitSerial(MU_FLIP); }


void Init()
{
m_next=true;
m_flipped=!true;
m_eof=false;
//m_f2rp= new F2R();
// FIXME TODO this needs mutex 
//m_pair= m_f2rp->add_pair(m_fn);
//m_sb=new Rdb();
//rdbuf(m_pair.m_sb);
//m_fd=open(m_fn.c_str(),O_RDONLY|O_DIRECT);
m_ff=0;
m_fd=open(m_fn.c_str(),O_RDONLY);

//RdBuf m_b[2];
// no copy ctor or ass operator
const IdxTy BUFBITS=16;
m_b[0].pad(BUFBITS,1); // =RdBuf(BUFBITS,1);
m_b[1].pad(BUFBITS,1); // =RdBuf(BUFBITS,1);
Launch();
//m_f2rp->launch();
MM_ERR(MMPR2(m_fn,m_fd))
//m_mutex_vector = MutexVector(MU_SZ);
}

class P
{
public:
P(Fd n, Myt* _p) : p(_p),fd(n) {}
Myt * p;
Fd fd;

}; // P 
void Launch()
{
P*  p= new P(m_fd,this);
//P* pp=&p;
MM_ERR(" launch ")
ThreadUtil::fire_and_forget(1,&Myt::Thread , (void*) p);
}

static void* Thread(void * p)
{
MM_ERR(" launder starts")
try {
P* pp=(P*)p;
((*pp).p)->Load();
} catch (...) 
{
CatchDot3();
}

MM_ERR(" launder ends")
return 0;
} // Thread 


void Load()
{
ssize_t ntot=0;
while (true)
{
char * buf=0; // m_sb->dest();
IdxTy count=0; // m_sb->space();
write_buf(buf,count);
//MM_ERR(MMPR2(count,ntot))
//ssize_t n=::read(p.m_fd,buf,count);
if (count==0)
{
wrote(0);
usleep(10);
pthread_yield();
}
else{
MM_VERR(MMPR2((KeyCode)buf,count))
ssize_t n=::read(m_fd,buf,count);
// throwing... 
MM_VERR(MMPR3(((KeyCode)n),ntot,count))
//MM_ERR(MMPR(count))
//MM_ERR(MMPR(ntot))
//MM_ERR(MMPR(n))

if ( n<=0)
{
done_loading();
MM_VERR(" breaking "<<MMPR2(n,ntot))
break; 
}
wrote(n);
//m_sb->delivered(n);
ntot+=n; } 

} // while 

} // Load

static void CatchDot3()
{
   // https://stackoverflow.com/questions/315948/c-catching-all-exceptions
  std::exception_ptr pe = std::current_exception();
  MM_ERR((pe ? pe.__cxa_exception_type()->name() : "null"))
}
void done_loading() { m_eof=true; } 
bool done() { return m_eof; } 
StrTy m_fn;
RdBuf m_b[2];
IdxTy m_ff;
bool m_next,m_flipped,m_eof;
//F2RP m_pair;
//F2R * m_f2rp;
//Rdb *  m_sb;
Fd m_fd;

}; // mjm_byte_source





////////////////////////////////////////////////////////////////////////////////

#ifdef TEST_BYTE_SOURCE


class Tr {
public:
typedef unsigned int IdxTy;
typedef double D;
typedef std::string StrTy;
typedef std::stringstream Ss;
typedef std::istream IsTy;
typedef std::ostream OsTy;
typedef std::ofstream Ofs;
//typedef mjm_block_matrix<D> MyBlock;
//typedef  data_model_error_log Dmel;
typedef uint64_t KeyCode;
enum { BAD=~0};
}; // 
typedef Tr::IdxTy IdxTy;
int main(int argc, char ** args)
{
typedef mjm_byte_source<Tr> Ty;
Ty x("mboxx");
//x.launch();
//char c[100000];
IdxTy ntot=0;
MM_ERR(" try y");
IdxTy lines=0;
IdxTy ch=0;
while ( !x.eof())
{
char * b; IdxTy n;
x.read_buf(b,n);
MM_ERR(MMPR(n))
for(IdxTy i=0; i<n; ++i) std::cout<<b[i];
x.next();
if (n==0) {pthread_yield(); usleep(100); continue; }
ntot+=n;
MM_ERR(MMPR2(n,ntot))
}
MM_ERR(MMPR2(ntot,x.eof()))
//MM_ERR(MMPR3(y.fail(),y.bad(),y.rdstate()))
return 0; 
}



#endif


#ifdef TEST_ISTREAMS

class Tr {
public:
typedef unsigned int IdxTy;
typedef double D;
typedef std::string StrTy;
typedef std::stringstream Ss;
typedef std::istream IsTy;
typedef std::ostream OsTy;
typedef std::ofstream Ofs;
//typedef mjm_block_matrix<D> MyBlock;
//typedef  data_model_error_log Dmel;
typedef uint64_t KeyCode;
enum { BAD=~0};
}; // 
typedef Tr::IdxTy IdxTy;
int main(int argc, char ** args)
{
typedef mjm_line_istream<Tr> Ty;
Ty x("mboxx");
x.launch();
char c[100000];
//x.getline(c,20);
std::istream & y=x;
//sleep(1);
MM_ERR(" try y");
IdxTy lines=0;
IdxTy ch=0;
while ( y.good()&&!y.eof())
{
y.getline(c,90000);
if (!y.eof()&&!y.good())
{
MM_ERR(" not good could mean line too long")
}
if (y.eof()&&!y.good()) break; // no chars don't cound .
++lines;
ch+=strlen(c);
c[72]=0;
MM_ERR(MMPR(c))
//MM_ERR(MMPR(c))
}
MM_ERR(MMPR4(ch,lines,y.good(),y.eof()))
MM_ERR(MMPR3(y.fail(),y.bad(),y.rdstate()))
return 0; 
}

#endif




#endif // MJM_LINE_ISTREAMS_H__ 
