#ifndef mjm_constrained_file_H__
#define mjm_constrained_file_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <boost/filesystem/path.hpp>
#include <sys/stat.h>

#include <sys/stat.h>
#include <unistd.h>
#include <string>
#include <fstream>
#include <fcntl.h>



// Tue Aug 18 18:44:01 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_constrained_file   

//  g++ -std=gnu++11 -DTEST_mjm_constrained_file -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_constrained_file.h  -lpthread -lreadline -lboost_filesystem -lboost_system

// g++ -std=gnu++11 -DTEST_mjm_constrained_file -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_constrained_file.h  -lpthread -lreadline

template <class Tr>
class mjm_constrained_file 
{
 typedef mjm_constrained_file Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
//typedef std::filesystem::path Path;
typedef boost::filesystem::path Path;
class istream_desc
{
public:
enum details  { DIRECT, STRSTREAM, DONTDELETE,RETIRED} ;
enum idetails { FSTREAM=(1<<DIRECT)} ;
istream_desc() : m_mode(0) {}
//istream_desc(const IdxTy m) : m_mode(m) {}
istream_desc & set(const details m) { m_mode|=(1<<m); return *this; } 
istream_desc & set(const idetails m) { m_mode|=(m); return *this; } 
istream_desc & reset(const IdxTy m) { m_mode&=~(1<<m); return *this; } 
bool del() const { return !Bit(m_mode,DONTDELETE); } 
bool ss() const { return Bit(m_mode,STRSTREAM); } 
bool unused() const { return Bit(m_mode,RETIRED)||(m_mode==0); } 
void set_unused()  { m_mode=0;  } 
StrTy dump() const 
{
Ss ss;
ss<<MMPR(m_mode);
ss<<MMPR(Bit(m_mode,DIRECT));
ss<<MMPR(Bit(m_mode,STRSTREAM));
ss<<MMPR(Bit(m_mode,DONTDELETE));
ss<<MMPR(Bit(m_mode,RETIRED));
return ss.str();
}
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
IdxTy m_mode;
}; // istream_desc
class ostream_desc
{
public:
enum details  { DIRECT, STRSTREAM, DONTDELETE,RETIRED} ;
enum idetails { FSTREAM=(1<<DIRECT), TEMPSTR=(1<<STRSTREAM) } ;
ostream_desc() : m_mode(0) {}
//istream_desc(const IdxTy m) : m_mode(m) {}
ostream_desc & set(const details m) { m_mode|=(1<<m); return *this; } 
ostream_desc & set(const idetails m) { m_mode|=(m); return *this; } 
ostream_desc & reset(const IdxTy m) { m_mode&=~(1<<m); return *this; } 
bool del() const { return !Bit(m_mode,DONTDELETE); } 
bool ss() const { return Bit(m_mode,STRSTREAM); } 
bool unused() const { return Bit(m_mode,RETIRED)||(m_mode==0); } 
void set_unused()  { m_mode=0;  } 
StrTy dump() const 
{
Ss ss;
ss<<MMPR(m_mode);
ss<<MMPR(Bit(m_mode,DIRECT));
ss<<MMPR(Bit(m_mode,STRSTREAM));
ss<<MMPR(Bit(m_mode,DONTDELETE));
ss<<MMPR(Bit(m_mode,RETIRED));
return ss.str();
}
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
IdxTy m_mode;
}; // ostream_desc




typedef std::map<OsTy*, ostream_desc> OsMap;
typedef std::map<IsTy*, istream_desc> IsMap;

enum { MAP_MU=0 , MU_SZ};
public:
mjm_constrained_file():m_mutex_vector(MU_SZ), m_ok(false) {  Init();}
~mjm_constrained_file() {}
void root_path(const StrTy & r) { m_root=r; Update();} 
void rel_path(const StrTy & p) { m_path=p; Update(); } 
bool mkpath(const StrTy & p) { return MkPath(p); } 
bool ok() const { return m_ok; }
const StrTy & full() const { return m_full; } 
IsTy* istream() { return Istream(); } 
OsTy* ostream(const bool append ) { return Ostream(append); } 
void close(IsTy * is ) { Close(is); }  
void close(OsTy * os ) { Close(os); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool MkPath(const StrTy & p) { 
const StrTy x=m_path;
m_path=p;
Update();
if (!ok()) m_path=x;
if (!ok()) return false;
const bool y=Mkdir(m_full);
m_path=x;
return y;
} 
/// likely common needs here 
// https://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exist-using-standard-c-c11-c
bool Exists(const StrTy & name)
{
 struct stat64 buffer;   
  return (stat64(name.c_str(), &buffer) == 0);
}
// not recursive 
bool Mkdir(const StrTy & dir)
{
if (Exists(dir)) return true;
IdxTy e=mkdir(dir.c_str(), S_IRUSR | S_IWUSR | S_IXUSR);
if (Exists(dir)) return true;
return (e==0);
}






IsTy* Istream() { 
if (!ok()) return 0; 
IsTy * p=  new std::ifstream(m_full.c_str()); 
// need to see if already in use etc. 
//m_ism[p]= istream_desc(istream_desc::FSTREAM);
m_ism[p]= istream_desc();
m_ism[p].set(istream_desc::FSTREAM);
if (m_ism.size()>10) MM_ERR( " need to write code to prune imaps doh"); 
return p; 
} 
OsTy* Ostream(const bool append ) { 
if (!ok()) return 0; 
OsTy * p= new Ss(); // OsTy(m_full.c_str()); 
m_osm[p]= ostream_desc();
m_osm[p].set(ostream_desc::TEMPSTR);
if (m_osm.size()>10) MM_ERR( " need to write code to prune omaps doh"); 

return p;
} 

void Close(IsTy * is ) { 
istream_desc & isd= m_ism[is];

if ( isd.del()) delete is; 
isd.set_unused();
}  
void Close(OsTy * os ) { 
// this really should do a find but a null return
// indicates a huge problem anyay
ostream_desc & osd= m_osm[os];
if (osd.ss())
{
// eventually put in a mutex ect 
std::ofstream*  fout = new std::ofstream(m_full.c_str()); 
Ss * ss=(Ss*) os;
(*fout)<<(ss->str());
delete fout;
}
if ( osd.del()) delete os; 
//delete os; 
osd.set_unused();
}  

bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Update()
{
m_full_path=m_root+m_path;
//std::error_code ec;
//m_canonical_path=Path::normalize(m_full_path);
m_canonical_path=m_full_path.normalize();
//if (ec) MM_ERR(MMPR(ec.message()));
//m_full=(StrTy(m_canonical_path));
m_full=m_canonical_path.generic_string();
m_sz=m_root.length();
m_ok=(0==strncmp(m_root.c_str(),m_full.c_str(),m_sz));

if( !m_ok)  MM_ERR(" outside of scope "<<MMPR2(m_root,m_full));

}

bool CanStat()
{
struct stat buffer;   
  return (stat (m_full.c_str(), &buffer) == 0);
}

void Init()
{
// need to init mutexes 
}
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR4(m_root,m_path,m_sz,m_full); 
ss<<MMPR2(m_ok,CanStat());
ss<<" m_ism ";
MM_LOOP(ii,m_ism) { ss<<(*ii).second.dump()<<CRLF; }
ss<<" m_osm ";
MM_LOOP(ii,m_osm) { ss<<(*ii).second.dump()<<CRLF; }

return ss.str(); }
// members
StrTy m_root,m_path;
IdxTy m_sz;
Path m_full_path,m_canonical_path;
StrTy m_full;
bool m_ok;
IsMap m_ism;
OsMap m_osm;

}; // mjm_constrained_file

//////////////////////////////////////////////

template <class Tr>
class mjm_constrained_file_map : public std::map<typename Tr::StrTy, mjm_constrained_file< Tr > >  
{
 typedef mjm_constrained_file_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_constrained_file< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_constrained_file_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_constrained_file_map




////////////////////////////////////////////
#ifdef  TEST_mjm_constrained_file
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_constrained_file <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" mjm_constrained_file "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_constrained_file<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
const StrTy & p1= cip.p1;
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="root") { x.root_path(p1);  MM_ERR(x.dump()) }
if (cmd=="rel") { x.rel_path(p1);  MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // mjm_constrained_file_H__ 
