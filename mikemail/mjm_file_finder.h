#ifndef MJM_FILE_FINDER_H__
#define MJM_FILE_FINDER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun Dec 20 09:28:14 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_file_finder   
// g++  -Wall -std=gnu++11 -DTEST_MJM_FILE_FINDER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_file_finder.h  -lpthread -lreadline

template <class Tr>
class mjm_file_finder 
{
 typedef mjm_file_finder Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef mjm_pawnoff<Tr> MyHand;
typedef typename MyHand::blob Blob;

typedef mjm_ragged_table Ragged;
class _SearchLoc
{
public:
_SearchLoc(): depth(0) {} 
_SearchLoc(const StrTy & _d,const IdxTy de): d(_d),depth(de) {} 
StrTy d;
IdxTy depth; // really this is better off as a string but wth 

}; // _SearchLoc

typedef _SearchLoc SearchLoc;
typedef std::vector<SearchLoc> SearchVec;

//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_file_finder() {}
~mjm_file_finder() {}
void clear() { m_vec.clear(); }
void load(const Ragged & r) { Load(r); } 
void  push(const StrTy & d,const IdxTy depth ) 
{ m_vec.push_back(SearchLoc(d,depth)); } 

IdxTy count(const StrTy & fn) const { return Count(fn); } 
template <class Ty>
IdxTy find(Ty & locs, const StrTy & nm, const StrTy & d, const IdxTy depth, const IdxTy flags ) const
{ return Find(locs,nm,d,depth,flags); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
IdxTy Count(const StrTy & fn) const { 
IdxTy cnt=0;
MM_LOOP(ii,m_vec) { cnt+=Count(fn,(*ii).d,(*ii).depth); } // ii
return cnt; 

} 
//./mjm_mailproc/mjm_mailproc_handler.h:rc=m_hand.fileio(dest,err,data,lcmd+m_bfile);

template <class Ty>
IdxTy Find(Ty & locs, const StrTy & nm, const StrTy & d, const IdxTy depth, const IdxTy flags ) const
{
Blob dest;
IdxTy rc=FindBlob(dest,nm,d,depth); 

int * p=dest.lines(0);
int * p0=p;
if (!p) return 0  ;
while (*p!=(~0)) { locs.push_back(StrTy(dest.ptr()[*p])); ++p; } // p 
delete p0;
return rc;
} // Find
//template <class Ty>
IdxTy Find(StrTy & locs, const StrTy & nm, const StrTy & d, const IdxTy depth) const
{
Blob dest;
IdxTy rc=FindBlob(dest,nm,d,depth); 
locs=StrTy(dest); 
return rc;
} // Find



IdxTy FindBlob(Blob & dest, const StrTy & nm, const StrTy & d, const IdxTy depth) const
{
Blob err,data;
Ss ss; ss<<depth;
const StrTy cmd="find "+d+StrTy(" -maxdepth ")+ss.str()+StrTy(" -name ")+nm;
IdxTy c=m_hand.fileio(dest,err,data,cmd);
return c; 
} // FindBlod

IdxTy Count( const StrTy & nm, const StrTy & d, const IdxTy depth) const
{
IdxTy v=0;
Blob dest,err,data;
Ss ss; ss<<depth;
//const StrTy cmd="find "+d+StrTy(" -maxdepth ")+ss.str()+StrTy(" -name ")+nm+
// the parens are needed because this uses < and > to redirect 
const StrTy cmd="( find "+d+StrTy(" -maxdepth ")+ss.str()+StrTy(" -name \"")+nm+
StrTy("\" | wc -l ) ");
//StrTy("\" ");
IdxTy c=m_hand.fileio(dest,err,data,cmd);
//./mjm_mailproc/mjm_mailproc_handler.h:rc=m_hand.fileio(dest,err,data,lcmd+m_bfile);
v=atoi(StrTy(dest).c_str());
MM_ERR(MMPR(StrTy(dest))<<MMPR4(nm,v,cmd,StrTy(err)))
return v;
} // Find
void To(StrTy & d,  const StrTy & s)  { d= s; } 
void To(IdxTy & d,  const StrTy & s)  { d=strtod(s.c_str(),0); } 
template<class Td, class Tl > 
bool SetIf(Td & d, IdxTy & j, const Tl & l, const IdxTy lsz)
{
++j; if (j>=lsz) return false;
To(d,l[j]);
return true;

}
void Load(const Ragged & r) { 
const IdxTy sz=r.size();

MM_ERR(" loading "<<MMPR(sz))

for(IdxTy i=0; i<sz; ++i)
{
const Ragged::Line & l=r[i];
const IdxTy lsz=l.size();
MM_ERR(" loading "<<MMPR3(i,m_vec.size(),lsz))
if (!lsz) continue;
IdxTy j=0;
StrTy p;
IdxTy d=0; 
if ( l[0]=="path")  
{ 
if ((lsz&1)==0)
{
Ss ss; MM_LOOP(ii,l) { ss<<(*ii)<<" "; } 
MM_ERR(" should have path [dir,depth]... "<<MMPR3(i,lsz,ss.str()))
}
while (j<(lsz-1))  
{SetIf(p,j,l,lsz); SetIf(d,j,l,lsz);  SearchLoc sl(p,d); m_vec.push_back(sl); } 
continue;
}


} // i 

}  // Load



// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

mutable MyHand m_hand;
SearchVec m_vec;

}; // mjm_file_finder

//////////////////////////////////////////////

template <class Tr>
class mjm_file_finder_map : public std::map<typename Tr::StrTy, mjm_file_finder< Tr > >  
{
 typedef mjm_file_finder_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_file_finder< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_file_finder_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_file_finder_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FILE_FINDER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_file_finder <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FILE_FINDER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_file_finder<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FILE_FINDER_H__ 
