#ifndef MJM_SNACKS_ACCUMULATOR_H__
#define MJM_SNACKS_ACCUMULATOR_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_string_tokenizer.h"
#include "mjm_index_blob.h"
#include "mjm_collections.h"
#include "mjm_unit_crap.h"

// Wed Aug  5 10:38:25 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_snacks_accumulator   
// g++ -std=gnu++11 -DTEST_MJM_SNACKS_ACCUMULATOR -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_snacks_accumulator.h  -lpthread -lreadline

template <class Tr >
class mjm_snacks_accumulator 
{
 typedef mjm_snacks_accumulator Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef string_tokenizer St; 
typedef IdxTy TokTy;

// avoided except for report autoranging. 
typedef mjm_unit_crap<Tr> Units;
typedef typename Units::qty_dim Qdim;


// should use the thing in the units class now 
class _qty_typed
{
typedef _qty_typed Myt;
public:
_qty_typed() : m_v(0),m_type(~0),m_empty(true),m_error(false) {}
_qty_typed(const D & v) : m_v(v),m_type(~0),m_empty(true),m_error(false) {}
_qty_typed(const D & v, const IdxTy t) : m_v(v),m_type(t),m_empty(false),m_error(false)  {}
_qty_typed(const D & v, const StrTy& sfx) 
: m_v(v),m_type(~0),m_val(v,sfx),m_empty(false),m_error(false)  {}
_qty_typed(const Qdim& qd) 
: m_v(0),m_type(~0),m_val(qd),m_empty(false),m_error(false)  {}


const D & qty() const { return m_v;}
const IdxTy type() const { return m_type;}
bool valid() const { return !m_error; } 
bool empty() const { return type()==IdxTy(~0); } 
void  invalidate()  { m_error=true; } 
void add(const D & del) { m_v+=del; }
Myt operator+(const Myt & x)
{
Myt y=(*this);
y+=x;
return y;
}
Myt& operator+=(const Myt & x)
{
// there is AddsOk in the unit_crap file that requires literal
// match. But should have a version that uses the units things too. 
 if( x.m_type!=m_type) { 
if (m_v!=0)
{ MM_ERR(" types don't match "<<MMPR4(x.m_type,m_type,x.m_v,m_v))}
else m_type=x.m_type;
} 
//y.m_type=m_type;
m_v+=x.m_v;
return *this;
}

private:
D m_v;
IdxTy m_type;
Qdim m_val;
bool m_empty,m_error;

}; // _qty_typed

typedef _qty_typed qty_typed;

public:
typedef std::vector<StrTy> noun_order;
mjm_snacks_accumulator() {Init();}
mjm_snacks_accumulator( Units * p ) {Init(); m_punits=p; }
mjm_snacks_accumulator(St * pst) {Init(); m_pst=pst; }
~mjm_snacks_accumulator() { delete m_pst; }

void units( Units * p ) { m_punits=p; } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
void dog_daily(Ragged & d, Ragged * used,noun_order &no, const IdxTy flags)
{ DogDaily(d,used, no,flags); }
//template<class Tps> void add(const Tps & ps) { Add(ps); }
// FIXME need to track units here or there 
template<class Tps,class Tne,class Tnoun > 
void add(Tps & ps, const Tne & ne, const Tnoun & noun ) { 
Add(ps,ne,noun); } 
private:
class snack_data
{
static IdxTy bad() { return ~0; } 
public:
snack_data(): m_noun_idx(bad()),
//m_time_idx(bad()), m_units_idx(bad()), m_consumer_idx(bad()),
m_time_idx(bad()),  m_consumer_idx(bad()),
m_quality_idx(bad()),
//m_qty(-1),m_of(-1),m_pct(-1),m_has_of(false),m_error_idx(0) {}
m_of(-1),m_pct(-1),m_has_of(false),m_error_idx(0) {}
void set_noun(const StrTy & n, St & st) { m_noun_idx=st(n); } 
//void set_units(const StrTy & n, St & st) { m_units_idx=st(n); } 
void set_time(const StrTy & n, St & st) { m_time_idx=st(n); } 
void set_time(const D &d , St & st) {Ss ss; ss<<d; m_time_idx=st(ss.str()); } 
void set_consumer(const StrTy & n, St & st) { m_consumer_idx=st(n); } 
//void set_qty(const D & d) { m_qty=d; } 
void set_of(const D & d) { m_of=d; } 
void set_pct(const D & d) { m_pct=d; } 
void set_has_of(const bool b ) { m_has_of=b; } 
void set_eaten(const D & d, const StrTy & sfx, St & st)
{ m_eaten=qty_typed(d,st(sfx)); }
IdxTy noun_idx() const { return m_noun_idx; } 
IdxTy consumer_idx() const { return m_consumer_idx; } 
const qty_typed & eaten() const { return m_eaten; } 
//D qty() const { return m_qty;}
//D xxfraction() const {if (m_of==0) return 1;  return m_qty/m_of;}
D fraction() const { return m_pct/100.0;}
StrTy sfraction() const {
if (!m_has_of) return StrTy("-") ; 
Ss ss; ss<<fraction();
 return ss.str();
}
/*
StrTy xxsfraction() const {
if (!m_has_of) return StrTy("-") ; 
const D e=m_qty/m_of;
Ss ss; ss<<e;
 return ss.str();
}
*/

//#define DUMP_DEF(x)  ss<<MMPR(x);
//#define DUMP_DEFI(x)  ss<<MMPR(x);

//#define DUMP_DEF(x)  ss<<" "<<(x);
#define DUMP_DEFI(x) if(x.length()!=0)  ss<<(x); else ss<<"-";
#define DUMP_DEF(x) if(x.length()!=0)  ss<<" "<<(x); else ss<<" -";
#define DUMP_DEFN(x)  ss<<" "<<(x); 

template <class Tv> static void header(Tv & l ) //  const
{
l.push_back("time");
l.push_back("consumer");
l.push_back("noun");
l.push_back("qty");
l.push_back("units");
l.push_back("fraction");
l.push_back("eaten_qty");
l.push_back("eaten_type");

}
void dump(Ss & ss, St & st,const IdxTy flags)  const 
{

//ss<<st(m_time_idx)<<" "<<st(m_consumer_idx)<<" "<<st(m_noun_idx);
//ss<<" "<<m_qty<<" "<<st(m_units_idx)<<" "<<sfraction();
//ss<<" "<<m_eaten.qty()<<" "<<st(m_eaten.type());  

DUMP_DEFI(st(m_time_idx))
DUMP_DEF(st(m_consumer_idx))
DUMP_DEF(st(m_noun_idx))
//DUMP_DEFN(m_qty)
//DUMP_DEF(st(m_units_idx))
DUMP_DEF(sfraction())
DUMP_DEFN(m_eaten.qty())
DUMP_DEF(st(m_eaten.type()))  



}

#undef DUMP_DEF
#undef DUMP_DEFN
#undef DUMP_DEFI

private:
IdxTy m_noun_idx;
IdxTy m_time_idx;
//IdxTy m_units_idx;
IdxTy m_consumer_idx;
IdxTy m_quality_idx;
//D m_qty,m_of,m_pct;
D m_of,m_pct;
qty_typed m_eaten,m_offered;
bool m_has_of;
IdxTy m_error_idx; 

friend mjm_snacks_accumulator<Tr>;


}; // snack_data
typedef snack_data Tdata;
class date_rec
{
public:
date_rec(const StrTy & s, const IdxTy serial, const IdxTy ivec)
: m_s(s),m_serial(serial),m_ivec(ivec) {}
IdxTy serial() const { return m_serial; } 
StrTy m_s; // date string
// serial since epoch, first location in data vector. 
IdxTy m_serial, m_ivec;

}; // date_rec
typedef date_rec Tdate;

// at some point make this a blob or something 
typedef std::vector<Tdata> DataVec;
// date strings in order
//typedef std::vector<StrTy> DateVec;
// key is date serial since epoch, value is 
typedef std::map<IdxTy,Tdate> DateMap;
typedef std::vector<Tdate> DateVec;



bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
const bool include_hdr=Bit(flags,0); 
if (include_hdr)
{
Line l;
l.push_back("serial");
l.push_back("date");
Tdata::header(l);
ss<<l[0];
for(IdxTy i=1; i<l.size(); ++i)  ss<<" "<<l[i];
ss<<CRLF;

}
const IdxTy sz=m_dates.size();
for(IdxTy i=1; i<sz; ++i)
{
const date_rec & dd=m_dates[i];
const StrTy & date=dd.m_s;
const IdxTy  serial=dd.m_serial;
const IdxTy jmax=(i+1<sz)?m_dates[i+1].m_ivec:m_data.size();
for(IdxTy j=dd.m_ivec; j<jmax; ++j)
{
const Tdata & r=m_data[j];
ss<<serial<<" "<<date<<" ";
r.dump(ss,(*m_pst),0);
ss<<CRLF;

} // j 

} // i 

return ss.str(); 

} // Dump

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
typedef IdxTy Consumer;
typedef IdxTy  NounTy;
//typedef std::map<NounTy, D> NounMap;
// could be a map but need to look for reducible etc
// and best matches not exact string match. 
//typedef std::vector<qty_typed> TypedVec;
// needs to be a map for column headers etc. 
typedef std::mapr<StrTy,qty_typed> TypedMap;
// in general not all quantities will add together and unit segreated
// sums can handle the general case for later resolution or diagnosis
class _add_or_append_type : public TypedMap // Vec
{
typedef _add_or_append_type Myt;

public:
typedef qty_typed arg_type;
void add(const arg_type & t) {Add(t); } 

private:
// either expand or add to an existing entry 
void Add(const arg_type & t) {
MM_DIE(" forgot to code doh") 
} 


}; // _add_or_append_type;
typedef _add_or_append_type add_or_append_type;

//typedef std::map<NounTy, qty_typed> NounMap;
// NounTy is a tokenized string, or int if tokenizer used... 
typedef std::map<NounTy, add_or_append_type>  NounMap;

typedef std::map<Consumer,NounMap> DailyMap;


void AddToLine(Line & l, const StrTy & nm, const qty_typed & _qt, const bool include_units, const bool auto_range)
{
l.push_back(nm); 
/// make a copy for autoranging...
qty_typed qt= _qt; // (*ii).second;
//MM_ERR(MMPR2(auto_range,m_punits))
if (auto_range)  if (m_punits)
{
StrTy ty=(*m_pst)(qt.type());
D qty=qt.qty();
(*m_punits).auto_range(qty,ty);
qt=qty_typed(qty,(*m_pst)(ty));
}
//Ss ss; ss<<(*ii).second.qty();
Ss ss; ss<<qt.qty();
l.push_back(ss.str());  
if (include_units){
const StrTy & ty=(*m_pst)(qt.type());
 //StrTy s=((*m_pst)((*ii).second.type())); 
 StrTy s=ty; // ((*m_pst)((*ii).second.type())); 
if (s.length()==0) s="-";
if (!qt.valid()) s+="*";
 l.push_back(s); 
// l.push_back((*m_pst)((*ii).second.type())); 
} // include units 



} // AddToLine

typedef std::vector<NounTy> NostMap;
//typedef std::map<NounTy,qty_typed> Nmap;
//typedef NounMap Nmap;
typedef std::map<NounTy,IdxTy> Ulmap;
typedef std::map<StrTy,qty_typed> Alphanmap;
void UsedReport( Ragged & used,  const NostMap& nost,const NounMap &nmap, const bool include_units,
const bool auto_range,const bool used_hdr )
{
if (used_hdr)
{
Line l;
l.push_back("Noun");
l.push_back("Qty");
if (include_units) l.push_back("Units");
used.add(l); 
} // used_hdr
MM_LOOP(jj,nost)
{
auto ii=nmap.find(*jj);
if (ii==nmap.end()) continue;
// now ii.second is a vertor
MM_LOOP(kk,(*ii).second)
{
Line l;
//AddToLine(l,(*m_pst)((*ii).first),(*ii).second,include_units,auto_range);
AddToLine(l,(*m_pst)((*ii).first),(*kk),include_units,auto_range);
used.add(l); 
} // kk 
}// ii

} // UsedReport
void DailyLine(Ragged & d,const DailyMap & m,const NostMap & nost
, Ulmap &  umap
,const bool push_all,const bool push_zero
,const bool labels_each, const bool include_units
,const IdxTy serial, const StrTy & date,
const bool fill_units
)
{
MM_LOOP(ii,m)
{
const StrTy c=(*m_pst)((*ii).first);
Line l;
Ss ss; ss<<serial;
l.push_back(ss.str());
l.push_back(date);
l.push_back(c);
// data_rec
// TODO verify this needs to be a copy and not a ref 
//const auto x=(*ii).second;
// this is a noun and a qty_typed
const NounMap x=(*ii).second;
MM_LOOP(jj,nost)
{
const auto kk=x.find((*jj));
//points to  qty_typed kk=x.find((*jj));
const bool found=(kk!=x.end());
//const D q=(kk!=x.end())?(*kk).second.qty():0;
// kk.second is now a vector ... but nost does not know about 
// that yet doh...  
const D q=found?(*kk).second.qty():0;
const bool push_col=push_all||(found&&(push_zero||((q!=0)))); 
if ( push_col){
if (labels_each) { l.push_back((*m_pst)(*jj));  } 
Ss rr; rr<<q; l.push_back(rr.str());
if (include_units)
{
 //l.push_back((*m_pst)((*kk).second.type())); 
 StrTy s=found?((*m_pst)((*kk).second.type())):StrTy("-"); 
if (!found) if (fill_units) s=(*m_pst)(umap[(*jj)]);
if (s.length()==0) s="-";
 l.push_back(s); 
} // include_units

} // push_col


} // jj 
//////////////////////////////
d.add(l);
} // ii m 

} // DailyLine
void MakeMaps(NounMap & nmap, Alphanmap & alphanmap, Ulmap & umap)
{
// TODO FIXME this needs to make units work doh 
MM_LOOP(ii,m_data) 
{ 
const auto&  ee=(*ii).eaten();
const NounTy nidx=(*ii).noun_idx();  
const StrTy & nname=(*m_pst)(nidx);
auto jj=umap.find(nidx);
if (jj==umap.end()) umap[nidx]=ee.type();
if (umap[nidx]!=ee.type())
{
const StrTy & u1=(*m_pst)(umap[nidx]);
const StrTy & u2=(*m_pst)(ee.type());
MM_ERR(" units may not add right "<<MMPR3(nname,u1,u2))

}
//if (occurance_order)
//PlusEq(nmap[(*ii).noun_idx()],(*ii).eaten());  
PlusEq(nmap[nidx],ee);  
//else 
//PlusEq(alphanmap[(*m_pst)((*ii).noun_idx())],(*ii).eaten()); 
PlusEq(alphanmap[nname],ee); 
} // ii

} // MakeMaps

void DogDaily(Ragged & d, Ragged * used, noun_order &no, const IdxTy flags)
{
// return noun order in noun_order if zero size at entry 
// return serial, date canonical, consumer, [noun, qty]... 
// right now assume units match 
const bool push_all=Bit(flags,0); // include all fields used anywhere
const bool occurance_order=Bit(flags,1); // order fields as encountered instead of alpha 
const bool auto_range= Bit(flags,2); // adjust inventory totals to best fit suffix 
const bool include_units= auto_range || Bit(flags,3);
const bool push_zero=!Bit(flags,4); // include entries with value of zero 
const bool labels_hdr=Bit(flags,5); // create a header line with field labels
const bool labels_each=!labels_hdr; // include field names on each line 
const bool fill_units=true; // zero entries may not have units, borrow sfx 
const bool used_hdr=Bit(flags,6); // create a header line in used report 
if (!push_all)
{
if (labels_hdr) MM_ERR(" options produce inconsistent output since colums vary "<<MMPR2(push_all,labels_hdr))

} // !push_all

NostMap  nost;
NounMap  nmap;
Ulmap  umap;
Alphanmap alphanmap;

MakeMaps( nmap, alphanmap,umap);
#if 0 

// TODO FIXME this needs to make units work doh 
MM_LOOP(ii,m_data) 
{ 
const auto&  ee=(*ii).eaten();
const NounTy nidx=(*ii).noun_idx();  
const StrTy & nname=(*m_pst)(nidx);
auto jj=umap.find(nidx);
if (jj==umap.end()) umap[nidx]=ee.type();
if (umap[nidx]!=ee.type())
{
const StrTy & u1=(*m_pst)(umap[nidx]);
const StrTy & u2=(*m_pst)(ee.type());
MM_ERR(" units may not add right "<<MMPR3(nname,u1,u2))

}
//if (occurance_order)
//PlusEq(nmap[(*ii).noun_idx()],(*ii).eaten());  
PlusEq(nmap[nidx],ee);  
//else 
//PlusEq(alphanmap[(*m_pst)((*ii).noun_idx())],(*ii).eaten()); 
PlusEq(alphanmap[nname],ee); 

} // ii

#endif


if (no.size()==0)
{
if (occurance_order)
{MM_LOOP(ii,nmap) { nost.push_back((*ii).first); } }
else { MM_LOOP(ii,alphanmap) { nost.push_back((*m_pst)((*ii).first)); }  } 
}// no.size
else { 
MM_LOOP(ii,no) { nost.push_back((*m_pst)(*ii)); } 
}
if (used) UsedReport(*used,nost,nmap,include_units,auto_range,used_hdr);
#if 0

if (used)
{
if (used_hdr)
{
Line l;
l.push_back("Noun");
l.push_back("Qty");
if (include_units) l.push_back("Units");
used->add(l); 
} // used_hdr
MM_LOOP(jj,nost)
{
auto ii=nmap.find(*jj);
if (ii==nmap.end()) continue;
Line l;
AddToLine(l,(*m_pst)((*ii).first),(*ii).second,include_units,auto_range);
used->add(l); 

}// ii

} // used 
#endif

if (labels_hdr)
{
Line l;
l.push_back(StrTy("Serial"));
l.push_back(StrTy("Date"));
l.push_back(StrTy("Consumer"));

MM_LOOP(jj,nost)
{
 const StrTy f=(*m_pst)(*jj);   
 l.push_back(f);   
if (include_units)
 l.push_back(f+"_units");   
} // jj
d.add(l);
} // labels_hdr
const IdxTy sz=m_dates.size();
for(IdxTy i=1; i<sz; ++i)
{
DailyMap m;
const auto & dd=m_dates[i];
const StrTy & date=dd.m_s;
const IdxTy & serial=dd.serial();
const IdxTy jmax=(i+1<sz)?m_dates[i+1].m_ivec:m_data.size();
////////////////////////////////////////////////
for(IdxTy j=dd.m_ivec; j<jmax; ++j)
{
const auto & r=m_data[j];
Consumer c=r.consumer_idx();
NounTy n=r.noun_idx();
PlusEq(m[c][n],r.eaten());
} // j records for day i 
//void DailyLine( Ragged & d, const DailyMap & m,  const NostMap& nost )
DailyLine(d,m,nost,umap,push_all,push_zero,labels_each,include_units,
serial,date,fill_units
);
//void DailyLine(Ragged & d,const DailyMap & m,const NostMap & nost
//,const bool push_all,const bool push_zero
//,const bool labels_each, const bool include_units
//const IdxTy serial, const StrTy & date, const StrTy & c,
//const bool fill_units
//{
#if 0 
MM_LOOP(ii,m)
{
const StrTy c=(*m_pst)((*ii).first);
Line l;
Ss ss; ss<<serial;
l.push_back(ss.str());
l.push_back(date);
l.push_back(c);
const auto x=(*ii).second;
MM_LOOP(jj,nost)
{
const auto kk=x.find((*jj));
const bool found=(kk!=x.end());
//const D q=(kk!=x.end())?(*kk).second.qty():0;
const D q=found?(*kk).second.qty():0;
const bool push_col=push_all||(found&&(push_zero||((q!=0)))); 
if ( push_col){
if (labels_each) { l.push_back((*m_pst)(*jj));  } 
Ss rr; rr<<q; l.push_back(rr.str());
if (include_units)
{
 //l.push_back((*m_pst)((*kk).second.type())); 
 StrTy s=found?((*m_pst)((*kk).second.type())):StrTy("-"); 
if (!found) if (fill_units) s=(*m_pst)(umap[(*jj)]);
if (s.length()==0) s="-";
 l.push_back(s); 
} // include_units

} // push_col
} // jj 
//////////////////////////////
d.add(l);
} // ii m 
#endif

} // i dates
} // DogDaily




template<class Tps,class Tne,class Tnoun > void Add( Tps & ps, const Tne & ne, const Tnoun & noun ) { 
const StrTy & d=ps.cdates;
const IdxTy serial=ps.date;
if (serial<m_dates.back().serial()) 
{
Ss ss; ss<<"date order wrong "<<MMPR2(serial, m_dates.back().serial());
	//ps.add_error(StrTy(),0, ss.str().c_str()); 
	ps.add_error(StrTy(),0, ss); 
}
if (serial!=m_dates.back().serial()) 
	m_dates.push_back( Tdate(d,serial,m_data.size()) ); 

//qty_typed xxx;
//Add(ps); 
Tdata x;
x.set_noun(ne.canon(),(*m_pst));
//m_data.push_back(x);
// this needs to convert to reporting units if requested 
//x.set_qty(ne.qty());
//x.set_units(ne.sfx(),(*m_pst));
//MM_ERR(" adding "<<MMPR4(ne.rqty(),ne.rsfx(),ne.qty(),ne.sfx()))
x.set_eaten(ne.rqty(),ne.rsfx(),(*m_pst));
x.set_of(ne.of());
x.set_pct(ne.pct());
x.set_has_of(ne.has_of());
x.set_time(ps.time,(*m_pst)); // wtf float 
x.set_consumer(ps.consumer,(*m_pst));
m_data.push_back(x);
} // Add 
void Init()
{ // push dummy records
m_dates.push_back( Tdate("",0,0) ); 
m_pst=0;
m_pst= new St();
m_punits=0;
}
// great except the first time the dest has 
// no units doh. 
void PlusEq( qty_typed & d, const qty_typed & s)
{
if (!m_punits ) { d+=s; return; } 
if (d.empty()) { d+=s; return; } 
// +=
const IdxTy dt=d.type();
const IdxTy st=s.type();
if (dt==st ) { d+=s; return; } 
const StrTy& ud=(*m_pst)(dt);
const StrTy& us=(*m_pst)(st);
StrTy rho="";
D x=0;
IdxTy rc=(*m_punits).convert(x,s.qty(),ud,us,rho);
if (rc==0) d.add(x);
else d.invalidate();

}
// members
St* m_pst;
DataVec m_data;
//DateMap m_dates;
DateVec m_dates;
// fck, 
Units * m_punits;
}; // mjm_snacks_accumulator

//////////////////////////////////////////////

template <class Tr>
class mjm_snacks_accumulator_map : public std::map<typename Tr::StrTy, mjm_snacks_accumulator< Tr > >  
{
 typedef mjm_snacks_accumulator_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_snacks_accumulator< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_snacks_accumulator_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_snacks_accumulator_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SNACKS_ACCUMULATOR
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_snacks_accumulator <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SNACKS_ACCUMULATOR "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_snacks_accumulator<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SNACKS_ACCUMULATOR_H__ 
