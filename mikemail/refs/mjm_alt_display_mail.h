#ifndef MJM_ALT_DISPLAY_H__
#define MJM_ALT_DISPLAY_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
// must be before ncurses 
#include "mjm_instruments.h"
#include "mjm_read_buffer.h"
#include "mjm_misc_parse.h"
//#include "mjm_cursing_viewer.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Mon May 27 17:42:08 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_alt_display   
// g++ -std=gnu++11 -DTEST_MJM_ALT_DISPLAY -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_alt_display.h  -lpthread -lreadline -lncurses

template <class Tr>
class mjm_alt_display 
{
 typedef mjm_alt_display Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef std::map<StrTy, StrTy> AltBlocks;
typedef std::map<StrTy, Myt * > Children;
//typedef std::vector< Myt * > Children;
typedef std::vector< Myt * > ChildStack;
typedef Myt * Parent;
typedef std::map<StrTy, StrTy> StrVars;
typedef std::map<StrTy, int> IntVars;
typedef std::map<StrTy, D> DVars;
typedef mjm_read_buffer<Tr> RdBuf;
typedef std::vector<IdxTy> Dbgstack;
//typedef mjm_cursing_viewer<Tr> Viewer;
typedef mjm_misc_parse<Tr>  AsciiTab;
bool str_to_bool(const StrTy & s) { return ReadWriteMap::str_to_bool(s); } 
public:
mjm_alt_display():m_tag("\\root"), m_mom(0),m_parse_state(0),m_rdbuf(10,1),m_block_level(0),m_block_leveli(0)  {Init(); }
// this is a PARENT making a child not a copy ctor 
explicit mjm_alt_display( Myt & that ):m_tag("child"),m_mom(&that),m_parse_state(that.m_parse_state),m_rdbuf(10,1),
m_block_level(that.m_block_level),m_block_leveli(m_block_level)  {Init(); }
mjm_alt_display( Myt & that, const StrTy &t ):m_tag(t),m_mom(&that),m_parse_state(that.m_parse_state),m_rdbuf(10,1),
m_block_level(that.m_block_level),m_block_leveli(m_block_level)  {Init(); }



~mjm_alt_display() {Release();}
typedef std::vector<Myt*> El;
StrTy display() { return Display(); } 
StrTy display(El & el, const IdxTy flags) { return Display( el,  flags) ; } 
template <class Ty> void set_levels(const Ty & m) { SetLevels( m); } 
void set_level(const StrTy & m) { m_disp_level=m; } 
const StrTy &  level() const { return m_disp_level; } 
IdxTy cmd( const StrTy & cmd) { return Cmd(cmd); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
void load_file(const StrTy &fn) { LoadFile(fn); } 
void new_ch( const char c) { m_latex_mode?m_stack->back()->NewChLatex(c):m_stack->back()->NewCh(c); } 
void eof() { Eof(); } 
const StrTy & name() { return m_tag;}
// return -1 on zero 
IdxTy prior_line(const StrTy & s, const IdxTy p) { return PriorLine(s, p); }
IdxTy next_line(const StrTy & s, const IdxTy p) { return NextLine(s, p); }
void latex_mode(const StrTy & s) { m_latex_mode=str_to_bool(s); } 
bool latex_mode() { return m_latex_mode; } 

private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
bool Bit(const IdxTy flags, const IdxTy b) { return ((1<<b)&flags)!=0; } 
enum {BAD=~0 }; 
// enum { BAD=~0,BITS=8*sizeof(Ch), CARD=(1<<BITS),LC =(1<<0), DIGIT=(1<<1),
//WHITE=(1<<2), CTRL=(1<<3), UC=(1<<4), PUNC=(1<<5),EOL=(1<<6),START=(1<<7),
//STOP=(1<<8), OPER=(1<<9) } ;


//IdxTy PriorLine(const StrTy & s, const IdxTy p) { return Seek(s, p,AsciiTab::EOL,2); }
IdxTy PriorLine(const StrTy & s, const IdxTy p) { return SeekEnd(s, p,AsciiTab::EOL,2,3); }
//IdxTy NextLine(const StrTy & s, const IdxTy p) { IdxTy x2= Seek(s, p,AsciiTab::EOL,0); return Seek(s,x2,AsciiTab::EOL,1); }
IdxTy NextLine(const StrTy & s, const IdxTy p) { return SeekEnd(s, p,AsciiTab::EOL,0,1); }

IdxTy SeekEnd(const StrTy & s, const IdxTy p, const IdxTy mask, const IdxTy flags,const IdxTy bmask)
{
IdxTy x2= Seek(s, p,mask,flags); 
return Seek(s,x2,AsciiTab::EOL,flags^bmask); 
} // SeekEnd
IdxTy Seek(const StrTy & s, const IdxTy p, const IdxTy mask, const IdxTy flags)
{
IdxTy ptr=p;
IdxTy ptrmax=s.length();
const char * q=s.c_str();
const bool pol=Bit(flags,0);
const bool dir=Bit(flags,1);
IdxTy rc=BAD;
while (true)
{
if (ptr==BAD) break;
if (ptr>=ptrmax) break;
const char c=q[ptr];
const bool  tf= (Lut(c)&mask)!=0;
if (tf^pol) return ptr;
dir?(--ptr):(++ptr);
///if (dir&&(ptr==0)) return 0; 
} // true 
return rc;
}

enum { ESC_ON=(1<<0),  DQUOTE_ON=(1<<1), KIDDING_ON=(1<<2), SQUOTE_ON=(1<<3), COMMENT_ON=(1<<4),
NEED_ZERO=(1<<5),FIRST_ON=(1<<6) };
enum { EOL_RESET=ESC_ON|KIDDING_ON|COMMENT_ON, TMASK=AsciiTab::DIGIT|AsciiTab::UC|AsciiTab::LC};
bool C1() const { return (0==(m_parse_state&(ESC_ON|DQUOTE_ON|COMMENT_ON))); } 
bool C2() const { return (KIDDING_ON==(m_parse_state&(KIDDING_ON|ESC_ON|DQUOTE_ON))); } 
bool CF() const { return (FIRST_ON==(m_parse_state&(FIRST_ON))); } 
bool Kidding() const { return (0!=(m_parse_state&(KIDDING_ON))); } 
bool Term(const char c) { return (c=='}' )&&C1()||(Kidding()&&m_latex_mode&&((Lut(c)&TMASK)==0)); }
bool BlockEnd(const char c) { return (c=='}' )&&C1(); }
bool IdEnd(const char c) { return (Kidding()&&((Lut(c)&TMASK)==0)); }
bool BlockStart(const char c) { return (c=='{' )&&C1(); }
bool KidEnd(const char c) { return (c=='{' )&&C2(); }
bool KidStart(const char c) { return (c=='\\' )&&C1(); }
bool Squote(const char c) { return (c=='\'' )&&C1(); }
bool Dquote(const char c) { return (c=='\"' )&&C1(); }
// wtf- backslash escape ? need to sort out  
bool Esc(const char c) { return (c=='\\' ); }
bool First(const char c) { return (c=='\\' )&&C1(); }
bool Lcomment(const char c) { return (c=='%' )&&C1(); }
bool Lcomment2(const char c) { return (c=='%' )&&C1()&&!CF(); }
bool Eol(const char c) { return (c=='\n' )||(c=='\r'); }
void Flip(const IdxTy m) { m_parse_state ^=m; }
void Reset(const IdxTy m) { m_parse_state &=~m; }
void Set(const IdxTy m) { m_parse_state |=m; }
bool Saving() { return m_latex_mode ||(0==(m_parse_state&(COMMENT_ON))); } 
void EndKid() { /* m_parse_state|=NEED_ZERO;*/ m_parse_state&=~KIDDING_ON; }


void NewCh( const char c)
{ // need ctab here. 
//MM_ERR(MMPR3(m_instance,int(c),c));
// ending brace however for begin/end this does not end the block 
if ( Term(c)) { 
bool app=false; 
if (Kidding()) {EndKid(c);app=true; } 
if ( m_latex_mode){ if ( !app) { m_rdbuf.append(c);  app=true; } 
MakeTexts();
if ( m_tag=="\\begin{")
{

return; // do not pop 
} // begin 
if ( m_tag=="\\end{")
{
// should check for underflow and match 
auto te=m_rdbuf.string(0);  
m_stack->pop_back();  
auto  tb=m_stack->back()->m_rdbuf.string(0);  
m_stack->pop_back(); 
if (te!=tb) { MM_ERR(MMPR2(te,tb))}
//{ MM_ERR(MMPR2(te,tb))}
return;  
} // end 

} // m_latex_mode 
// MM_ERR("term")  
else MakeTexts();

if (m_stack->size()==1){ return; }   
m_stack->pop_back(); return ; 

}  
// \foo   
if ( KidStart(c)) { m_rdbuf.mark_append(c); m_parse_state|=KIDDING_ON;  return ; }  
// I guess leave the net in m_rdbuf for display, count the zeroes
// to match the kid that fills in 
// { 
if ( KidEnd(c)) {  EndKid(c); return ; }  
// FIXME the strings between kids are not counted and only maybe one is displayed.. 

//if (Squote(c)) { Flip(SQUOTE_ON); }
//else if (Dquote(c)) { Flip(DQUOTE_ON); }
if (Eol(c)) { m_parse_state&= ~(EOL_RESET); }
if (Lcomment(c)) { m_parse_state|= COMMENT_ON; }
//MM_ERR(MMPR2(Saving(),c))
if (Saving()) m_rdbuf.append(c);
} // NewCh
///////////////////////////////////////////////////
// follow pattern text-child-text-child..... 
// should add a write order to order between
// types of just make a serial thing of each 

// syntax: identifiers \\ , params[], blocks{}, text
/*
i,t,b 

root : s,c strings and children( b,i) 
\foo{ -> tag of foo otherwise blank tag 
Block end removes from stack and finishes node 
 i -> t: add as string to node tagged with i  
   -> b: add node to i node empty tag 
   -> i: renomove inode, new inode in family 
 t -> b: new node no tag 
   -> i: new node i tag 
 b -> b: up and then new blank string then node  node no name 
   -> t: up and add text string 
   -> i: up and add new node with itag

The above is great but it does not return and the blocks 
create lots of blank node names. Go back to older,

 i -> t: add as string to node tagged with i  
   -> b: same as text but break up string with blank node 
   -> i: renomove inode, new inode in family 
 t -> b: new string broken by blank node  
   -> i: new node i tag 
 b -> b: new string and blank node 
   -> t: new string and blank node 
   -> i: new node with itag

m_stack->back() points to the child currently parsing chars
but everyone up the stack has its own state info 
Normally "this" is back unless stack has been altered. 

*/
//////////////////////////////////////////////////


void NewChLatex( const char c)
{
if (First(c)) // backslash in parsing 
{
// have a backslash in a parsing context, firs terminate any current ones
if (CF())
{
if (Saving()) m_rdbuf.append(c);
Reset(FIRST_ON);
return; 
}  // just an eol double slash 
// if there was already one being parsed, this terminates it 
// and it gets now params or text 
// a new kid goes on parent, stop this one. 
if (Kidding()) { 
//StrTy kid= m_rdbuf.mark_string(); 
// this needs to reset KIDDING before passing parse state to kid
//EdKid();  
//NewChildren( kid,  char(0) ,2-1); // now just 1 deep 
NewId(char(0));
RemoveBack();
//m_stack->back()->m_rdbuf.new_append(char(0));  
//m_stack->back()->Blank(); 
m_stack->back()->m_rdbuf.new_append(c); 
} 
// if not already kidding, start a new kid string  in current node
// will be moved to a new child when complete
else m_rdbuf.new_append(c); 
// kidding is now on and it is the first char 
m_stack->back()->Set(KIDDING_ON|FIRST_ON); 
return ;   
} // First(c)

if (BlockStart(c))
{
Reset(FIRST_ON);
++m_block_level;
//This terminates a name  and starts a new item
// the kid itself needs a new block and then 
// it needs to create a new block since c is blockstate... doh 
// \foo{
if ( Kidding()) { // NewId(c); 
StrTy kid= m_rdbuf.mark_string(); 
// this needs to reset KIDDING before passing parse state to kid
EndKid();  
NewChildren( kid,  c,2-1); // now just 1 deep 
// this is for block end, for now it gets input 
//RemoveBack(); // but the child gets no input now 
}   // this resets kidding 
// otherwise just another piece of text 
// although with a draw order, we should start a new string
// for a new block... 
//else { m_rdbuf.append(c); } 
else { 
//m_rdbuf.start_new(); 
//NewChild(StrTy(),c);  
Blank();
m_rdbuf.new_append(c); 
} 
 --m_block_level;   
return ; 
} // BlockStart
if (BlockEnd(c)) // old Term(c) } 
{
Reset(FIRST_ON);
--m_block_level;
if (Kidding()) { 
StrTy kid= m_rdbuf.mark_string(); 
m_rdbuf.start_new(); 
EndKid();  
// create amn identifier child and then remove if from stck 
NewChildren( kid,  c,1);
RemoveBack();// m_stack->back()->NewId(c); 
//RemoveBack();// m_stack->back()->NewId(c); 
//m_stack->back()->m_rdbuf.start_new(); 

return;  } 
// nothing special if not part of a name although
// apparently whit space does not count. 
//else {Blank();   m_rdbuf.new_append(c);  } 
else { m_rdbuf.append(c); m_rdbuf.start_new();  Blank(); return;   } 
// this is only the case if new block does not start... 
//if (m_stack->size()==1){ return; }   
//m_stack->pop_back(); 
//RemoveBack();
return ; 

} // BlockEnd
if (Eol(c)) { 
if (Kidding()) {NewId(c);  
Reset(EOL_RESET|FIRST_ON); return;  }
//Reset(FIRST_ON);
Reset(EOL_RESET); 
}
if (Lcomment2(c)) { Set(COMMENT_ON); }
Reset(FIRST_ON);
// clevely the more common branches are at the end
// when the end is found, 
// NewId extracts last string from this puts it into
// tag of new child and makes c first text char 
if (Kidding())
{
if (IdEnd(c)) { NewId(c); RemoveBack(); return; } 
} 
// accumlate string in current element 
if (Saving()) m_rdbuf.append(c);
} // NewChLatex
///////////////////////////////////////////////////
///////////////////////////////////////////////////


void NewChLatexWorking( const char c)
{
//NewChLatexOld(c);
//const bool first=CF();
// ending brace however for begin/end this does not end the block 
// going into "i" from t,i, or b 
if (First(c)) // backslash in parsing 
{
// have a backslash in a parsing context, firs terminate any current ones
if (CF())
{
if (Saving()) m_rdbuf.append(c);
Reset(FIRST_ON);
return; 
}  // just an eol double slash 
// if there was already one being parsed, this terminates it 
/*
if (m_block_level==m_block_leveli){
if (m_stack->size()>1){ 
// each remove needs to start a new char
 
RemoveBack();
m_stack->back()->m_rdbuf.new_append(c);
//dcacacac
//m_stack->back()->m_rdbuf.append(c);
 return;} 
}

*/
// and it gets now params or text 
// a new kid goes on parent, stop this one. 
if (Kidding()) {
RemoveBack();
NewId(c); 
} 
// if not already kidding, start a new kid string 
else m_rdbuf.new_append(c); 
// kidding is now on and it is the first char 
Set(KIDDING_ON|FIRST_ON); 
return ;   
} // First(c)

if (BlockStart(c))
{
Reset(FIRST_ON);
++m_block_level;
//This terminates a name  and starts a new item
// the kid itself needs a new block and then 
// it needs to create a new block since c is blockstate... doh 
if ( Kidding()) { // NewId(c); 
StrTy kid= m_rdbuf.mark_string(); 
// this needs to reset KIDDING before passing parse state to kid
EndKid();  
NewChildren( kid,  c,2);
}   // this resets kidding 
// otherwise just another piece of text 
// although with a draw order, we should start a new string
// for a new block... 
//else { m_rdbuf.append(c); } 
else { 
//m_rdbuf.start_new(); 
NewChild(StrTy(),c);  } 
 --m_block_level;   
return ; 
} // BlockStart
if (BlockEnd(c)) // old Term(c) } 
{
Reset(FIRST_ON);
--m_block_level;
// don't make a new level here, just continue one 
//if (Kidding()) { EndKid(); RemoveBack(); m_stack->back()->NewId(c); return;  } 
if (Kidding()) { 
StrTy kid= m_rdbuf.mark_string(); 
m_rdbuf.start_new(); 
EndKid();  
// create amn identifier child and then remove if from stck 
NewChildren( kid,  c,1);
RemoveBack();// m_stack->back()->NewId(c); 
RemoveBack();// m_stack->back()->NewId(c); 
m_stack->back()->m_rdbuf.start_new(); 

return;  } 
// nothing special if not part of a name although
// apparently whit space does not count. 
//else {Blank();   m_rdbuf.new_append(c);  } 
else { m_rdbuf.append(c); m_rdbuf.start_new();  Blank(); return;   } 
// if this is a begin tag, just keep accumulating
// stuff . An end tag needs to end all. 

// if ( m_tag=="\\begin") return; 
/*
if ( m_tag=="\\end")
{
// should check for underflow and match 
const StrTy  te=m_rdbuf.string(0);  
//m_stack->pop_back();  
RemoveBack();
const StrTy  tb=m_stack->back()->m_rdbuf.string(0);  
RemoveBack();
//m_stack->pop_back(); 
if (te!=tb) { MM_ERR(MMPR2(te,tb))}
//{ MM_ERR(MMPR2(te,tb))}
return;  
} // end 
*/
// this is only the case if new block does not start... 
//if (m_stack->size()==1){ return; }   
//m_stack->pop_back(); 
RemoveBack();
return ; 

} // BlockEnd
if (Eol(c)) { 
if (Kidding()) {NewId(c);  
Reset(EOL_RESET|FIRST_ON); return;  }
//Reset(FIRST_ON);
Reset(EOL_RESET); 
}
if (Lcomment2(c)) { Set(COMMENT_ON); }
Reset(FIRST_ON);
// clevely the more common branches are at the end
// when the end is found, 
// NewId extracts last string from this puts it into
// tag of new child and makes c first text char 
if (Kidding())
{
if (IdEnd(c)) { NewId(c); RemoveBack(); return; } 
} 
// accumlate string in current element 
if (Saving()) m_rdbuf.append(c);
} // NewChLatexWorking

/////////////////////////////////////////////
void RemoveBack()
{
if (m_stack->size()<2) return; 
m_stack->back()->MakeTexts(); 
m_stack->pop_back(); 
}

void NewChLatexOld( const char c)
{ // need ctab here. 
//MM_ERR(MMPR3(m_instance,int(c),c));
// ending brace however for begin/end this does not end the block 
if (First(c))
{
// have a backslash in a parsing context, firs terminate any current ones
bool app=false; 
if (Kidding()) {EndKid(c);app=true; } 
else m_rdbuf.new_append(c); 
Set(KIDDING_ON|FIRST_ON); 
return ;   
} // First(c)
/////////////////////////////////////////////
const bool first=CF();
Reset(FIRST_ON);
if (BlockStart(c))
{
// now the question is if goes with a kid or not 
++m_block_level;
// if in an identifier terminate and descend
if ( Kidding()) {  EndKid(c);  }  
else { m_rdbuf.append(c); } 
return ; 
}  // BlockStart 
if (BlockEnd(c)) // old Term(c) } 
{
--m_block_level;
// if 
if (Kidding()) {EndKid(c); } 
else { m_rdbuf.append(c); } 
if (m_block_level!=m_block_leveli) return; 
MakeTexts();
if ( m_tag=="\\begin{") return; 
if ( m_tag=="\\end{")
{
// should check for underflow and match 
auto te=m_rdbuf.string(0);  
m_stack->pop_back();  
auto  tb=m_stack->back()->m_rdbuf.string(0);  
m_stack->pop_back(); 
if (te!=tb) { MM_ERR(MMPR2(te,tb))}
//{ MM_ERR(MMPR2(te,tb))}
return;  
} // end 
if (m_stack->size()==1){ return; }   
m_stack->pop_back(); 
return ; 
} // BlockEnd 
if (Eol(c)) { 
if (Kidding()) {EndKid(c);  
Reset(EOL_RESET); return;  }
Reset(EOL_RESET); 
}
if(!first) if (Lcomment(c)) { Set(COMMENT_ON); }
if (Kidding())
{
if (IdEnd(c)) { EndKid(c); return; } 
} 


if (Saving()) m_rdbuf.append(c);

} // NewChLatexOld


// char c inidicates current string is complete
void NewId( const char c)
{
// take the name being accumulated off of this item
// and use it to name the new one. 
StrTy kid= m_rdbuf.mark_string(); 
m_rdbuf.start_new();
// this needs to reset KIDDING before passing parse state to kid
EndKid();  
// create a new child for this block and name it with the 
// string we removed. and make first char c
NewChild(kid,c); 
} // NewId

void EndKid( const char c)
{
if ( m_latex_mode){  m_rdbuf.append(c); }

StrTy kid= m_rdbuf.mark_string(); 
m_rdbuf.mark_pc();

if (m_latex_mode){
// do not descend yet if begin
if (kid=="begin")
{

return; 
}// begin
} // m_latex_mode

//StrTy kid= m_rdbuf.mark_string(); 
//m_rdbuf.mark_pc();
//MM_ERR(MMPR2(kid,m_stack->size()))  
NewChild(kid); EndKid();  
} // EndKid


void Eof() { MakeTexts(); } 
void MakeTexts()
{
// this rarely works as the thing is crapped with nulls
if ( m_rdbuf.strings()==1)
{
if (m_tag=="") m_tag= m_rdbuf.mark_string(); 
}

StrTy def=m_disp_level;
m_rdbuf.new_append(char(0));

//m_texts[def]=m_rdbuf.string();
//m_rdbuf.minimize();
}
// this needs a way to do nested things yet and pick detail level . 
// text is fixed after read, can use read_buffer lol. 
template <class Ty> void SetLevels(const Ty & m)
{
auto ii=m.find(m_tag);
if (ii!=m.end()) m_disp_level=(*ii).second;
IdxTy sz=m_family.size();
for(IdxTy i=0; i<=sz; ++i)
{
m_family[i]->SetLevels(m);
}
} // SetLevels

// for speed this needs to use a rdbuf for assembly not a stream buffer 
StrTy Display(const IdxTy flags=0) {
Ss ss; 
if (false) { ss<<m_texts[m_disp_level];  } 
if (true)
{
IdxTy i=0;
const bool full=(m_disp_level=="1")||(m_disp_level=="all");
IdxTy sz=m_family.size();
for(IdxTy i=0; i<=sz; ++i)
{
if (i<=m_rdbuf.strings()) { if (full) 
{
if (m_latex_mode) {if ( i==i) { ss<<m_tag<<MMPR(i)<<CRLF;}  ss<<m_rdbuf.string(i); } else { ss<<m_rdbuf.string(i); } 
}
else ss<<m_tag;  } 
if( i<sz) ss<<m_family[i]->display();
}
}
 return ss.str(); 
}

StrTy Display(El & el, const IdxTy flags) {
std::vector<StrTy> envstack;
Dbgstack dbgstack;
const bool nest=true;
const bool debug_display=Bit(flags,0);
Ss ss; 
if (false) { ss<<m_texts[m_disp_level];  } 
if (!debug_display) Display(ss,el,flags,envstack,nest);
else DisplayDebug(ss,el,flags,envstack,nest,dbgstack);
/*
if (true)
{
IdxTy i=0;
const bool full=(m_disp_level=="1")||(m_disp_level=="all");
IdxTy sz=m_family.size();
for(IdxTy i=0; i<=sz; ++i)
{
if (i<=m_rdbuf.strings()) { if (full) ss<<m_rdbuf.string(i); else ss<<m_tag;  } 
{ // scoping sz wtf
const IdxTy sz=ss.str().length();
const IdxTy del=sz-el.size();
for(IdxTy j=0; j<del; ++j) el.push_back(this);
}
if( i<sz) ss<<m_family[i]->display(el,flags);
}
}
*/

 return ss.str(); 
}
StrTy P(const Dbgstack & x)
{
Ss ss;
MM_LOOP(ii,x) ss<<(*ii)<<".";
return ss.str();
}
void DisplayDebug(Ss & ss,El & el, const IdxTy flags, std::vector<StrTy> & envstack, const bool nest, Dbgstack  dbgstack ) {
dbgstack.push_back(m_instance);
IdxTy sz=m_family.size();
IdxTy nstrings=m_rdbuf.strings();
const IdxTy szmax=(nstrings>sz)?nstrings:sz;
for(IdxTy i=0; i<szmax; ++i)
{
if (i<m_rdbuf.strings()) {
const StrTy & xx=m_rdbuf.string_sane(i);
ss<<MMPR4(P(dbgstack),i,m_tag,xx)<<CRLF;
}  // i <m_rdbuf.strings()

{ // scoping sz wtf
const IdxTy sz=ss.str().length();
const int  del=int(sz)-int(el.size());
if (del<0) MM_ERR(" logic error with el "<<MMPR3(el.size(),sz,del))
for(IdxTy j=0; j<del; ++j) el.push_back(this);
}
if (i<sz)  {

ss<<MMPR3(P(dbgstack),i,m_tag)<<" child :" <<CRLF;
m_family[i]->DisplayDebug(ss,el,flags,envstack,nest,dbgstack);
}
} // i 

} // DisplayDebug
void Display(Ss & ss,El & el, const IdxTy flags, std::vector<StrTy> & envstack, const bool nest ) {
{
IdxTy i=0;
const bool full=(m_disp_level=="1")||(m_disp_level=="all");
const bool show_tag=Bit(flags,1);
IdxTy sz=m_family.size();
IdxTy nstrings=m_rdbuf.strings();
const IdxTy szmax=(nstrings>sz)?nstrings:sz;
if (m_latex_mode)
{
if (m_tag=="\\begin{") envstack.push_back(m_rdbuf.string_sane(0)); 
if (m_tag=="\\begin") envstack.push_back(m_rdbuf.string_sane(0)); 
if ((m_tag=="\\end{") ||(m_tag=="\\end")) {
const IdxTy esz=envstack.size();
const auto & bb=(esz!=0)?envstack.back():"empty";
//const auto & bb=(esz!=0)?envstack.back():"empty";  
const auto & be=m_rdbuf.string_sane(0);
if (bb!=be) ss<<"MIS begin/end  "<<MMPR2(bb,be)<<CRLF; 
if (esz!=0)  envstack.pop_back();  } 

}
for(IdxTy i=0; i<=szmax; ++i)
{

//{ if (m_latex_mode) if( i<sz) m_family[i]->Display(ss,el,flags,envstack,nest); } 
if (i<m_rdbuf.strings()) { if (full)
{
//if (m_latex_mode){if (i==i)   ss<<m_tag<<MMPR(i)<<CRLF; } 
if (m_latex_mode&&show_tag){if (i==0)   ss<<m_tag; } 
const StrTy & xx=m_rdbuf.string_sane(i);
// TODO kluge  : the read buffer mark_string was wrong... 
//if (xx.length()>0) if (xx.c_str()[0]!=10) { ss<<xx; } 
{ ss<<xx; } 

}
 else { 
const bool htag=show_tag&&(i==0)&&(m_tag.length()!=0); 
//if ((i==0)&&(m_latex_mode)&& (nest))
if ((htag)&&(m_latex_mode)&& (nest))
{
const IdxTy esz=envstack.size();
const IdxTy sp=esz*4;
ss<<CRLF;
for(IdxTy cnt=0; cnt<sp; ++cnt) ss<<" ";

} // nest 
//if (i==0) { if (m_tag.length()!=0)  
if (htag) ss<<m_tag; else ss<<""; 
//else ss<<"\\notag"; }
 }
if (i==0) { 
if (m_latex_mode) if (m_tag=="\\begin{") ss<<m_rdbuf.string(0);
if (m_latex_mode) if (m_tag=="\\begin") ss<<m_rdbuf.string(0);
if (m_latex_mode) if (m_tag=="\\end{") ss<<m_rdbuf.string(0);
if (m_latex_mode) if (m_tag=="\\end") ss<<m_rdbuf.string(0);
}
 }
{ // scoping sz wtf
const IdxTy sz=ss.str().length();
const int  del=int(sz)-int(el.size());
if (del<0) MM_ERR(" logic error with el "<<MMPR3(el.size(),sz,del))
for(IdxTy j=0; j<del; ++j) el.push_back(this);
}
//if (!m_latex_mode) 
if( i<sz) m_family[i]->Display(ss,el,flags,envstack,nest);
}
}




} // Display

void CycleDisp()
{
if ((m_disp_level=="1")||(m_disp_level=="all"))
m_disp_level="0";
else m_disp_level="1";
}
void On() { m_disp_level="1"; }
void Off() { m_disp_level="0"; }

IdxTy Cmd( const StrTy & cmd, const StrTy & nm) { 
// infinite loop,
if (m_tag==nm) { Cmd(cmd); } //  Cmd(cmd);
IdxTy sz=m_family.size();
for(IdxTy i=0; i<sz; ++i) { m_family[i]->Cmd(cmd,nm); }

} // Cmd 
IdxTy Cmd( const StrTy & cmd,const bool top=false) { 
bool descend=false;
Myt * tgt=(top||Root())?this:m_mom;
if (cmd=="cycle") { CycleDisp(); }
if (cmd=="cycle_same") { tgt->Cmd("cycle",m_tag); }
if (cmd=="cycle_all") {descend=true; tgt->CycleDisp(); }
if (cmd=="++") {descend=true; tgt->On(); }
if (cmd=="--") {descend=true; tgt->Off(); }


if (descend)
{
IdxTy sz=m_family.size();
for(IdxTy i=0; i<sz; ++i) { m_family[i]->Cmd(cmd,true); }
} // descend

return 0; 

}  // Cmd

void NewChild(const StrTy & tag)
{
//MM_ERR(" making kid ")
Myt * kid = new Myt(*this);
kid->m_tag=tag;
m_family.push_back(kid);
// next char goes here. 
//m_stack->push_back(kid);
// This push is done in Init() from ctor 
}

// create a new child for this block and name it with the 
// string we removed. and make first char c
void NewChild(const StrTy & tag, const char c)
{
//MM_ERR(" making kid ")
Myt * kid = new Myt(*this,tag);
kid->m_tag=tag;
m_family.push_back(kid);
// This push is done in Init() from ctor 
//kid->m_rdbuf.new_append(c); 
// new_append here creates a dummy string throwing
// off text-child pattern.  
// this instead needs to parse c and start a new block if
// in the right state and c =='{' 
kid->m_rdbuf.append(c); 
}

void NewChildren(const StrTy & tag, const char c,const IdxTy n)
{
//MM_ERR(" making kid ")
Myt * kid = NULL;
StrTy t=tag;
for(IdxTy i=0; i<n; ++i) { 
if ( kid!=NULL) kid->m_rdbuf.start_new();
Myt * p=m_stack->back();
kid=new Myt(*p,t);
t="";
p->m_family.push_back(kid); 
}

// This push is done in Init() from ctor 
//kid->m_rdbuf.new_append(c); 
// new_append here creates a dummy string throwing
// off text-child pattern.  
// this instead needs to parse c and start a new block if
// in the right state and c =='{' 
kid->m_rdbuf.append(c); 
}



void Blank()
{
Myt * kid = new Myt(*this,"");
m_family.push_back(kid);
// Init pushes it doh 
RemoveBack(); 
//kid->MakeTexts(); 

} // Blank

StrTy Dump(const IdxTy flags=0) {Ss ss; 
IdxTy i=0;
Dump(ss,i); 
return ss.str(); }
void Dump(Ss & ss, IdxTy i  )
{
MM_LOOP(ii,m_texts)
{
ss<<MMPR3(m_instance,(*ii).first,(*ii).second.size())<<CRLF;
}
for(IdxTy j=0; j<i; ++j) ss<<" ";
ss<<MMPR2(m_tag,m_latex_mode)<<MMPR4(m_instance, m_family.size(),m_rdbuf.strings(),m_rdbuf.size())<<CRLF;
MM_LOOP(ii,(m_family)) { (*ii)->Dump(ss,i+1); } 

}



void Release()
{
//MM_LOOP(ii,m_kids) { delete (*ii).second; } 
MM_LOOP(ii,m_family) { delete (*ii); (*ii)=0;  } 
if (Root()) delete m_stack;
}
void Init() 
{
m_disp_level="all";
m_instance=Count();
++Count();
m_rdbuf.clear();
// mark the first one 
m_rdbuf.mark_pc();
if (Root()) { m_stack = new ChildStack(); }
else { m_stack=m_mom->m_stack; }
m_stack->push_back(this); 
// m_family = new ChildStack(); 
m_latex_mode=true;
}

bool Root() { return m_mom==NULL; } 
typedef  std::vector<IdxTy> Ctab;
static Ctab MakeCtab()
{
IdxTy card=1<<8;
IdxTy sz=sizeof(IdxTy);
Ctab x(card);
//memset(&x[0],0,256*sizeof(IdxTy));
const IdxTy* p=AsciiTab::lut();
memcpy(&x[0],p,card*sz);

return x; 
}
static const IdxTy Lut(const char c) 
{
static Ctab ctab= Lut(); // MakeCtab();
return ctab[c];
} 
static const Ctab Lut() 
{
static Ctab ctab= MakeCtab();
return ctab;
} 



void LoadFile(const StrTy & fn)
{
std::ifstream ifs(fn);
while (!ifs.eof()) new_ch(ifs.get());
eof();
}
IdxTy&  Count() { 
static IdxTy  serial=0;
return serial; 
} 
IdxTy m_instance;
StrTy m_tag; // \\ name used to create
StrTy m_disp_level; // name of text version to display 
AltBlocks m_texts;
StrVars m_svars;
IntVars m_ivars;

Children m_kids ;
Parent m_mom;
ChildStack* m_stack;
ChildStack m_family;

IdxTy m_parse_state;
RdBuf m_rdbuf;
bool m_latex_mode;
IdxTy m_block_level,m_block_leveli;
}; // mjm_alt_display

//////////////////////////////////////////////

template <class Tr>
class mjm_alt_display_map : public std::map<typename Tr::StrTy, mjm_alt_display< Tr > >  
{
 typedef mjm_alt_display_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_alt_display< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_alt_display_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_alt_display_map




////////////////////////////////////////////
#ifdef  TEST_MJM_ALT_DISPLAY
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;
typedef Tr::Ss Ss;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


void about()
{
Ss ss;
ss<<" mjm_alt_display "<<__DATE__<<" "<<__TIME__<<CRLF;
ss<<" Mike Marchywka marchywka@hotmail.com  "<<CRLF;

std::ostream & os=std::cout;
os<<ss.str();

}



int main(int argc,char **args)
{
typedef mjm_alt_display<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="load") { x.load_file(cip.p1);  MM_ERR(x.dump()) }
if (cmd=="disp") { MM_MSG(x.display()); }
if (cmd=="about") { about(); }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_ALT_DISPLAY_H__ 
