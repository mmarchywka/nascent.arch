//mjm_csv_mmp_form.h
#ifndef MJM_CSV_MMP_FORM_H__
#define MJM_CSV_MMP_FORM_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_ragged_forms.h"
#include "mjm_snacks_accumulator.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Tue Jul 28 18:46:13 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_diet_diary_form   
// g++ -std=gnu++11 -DTEST_MJM_DIET_DIARY_FORM -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_diet_diary_form.h  -lpthread -lreadline

template <class Tr>
class mjm_csv_mmp_form  : public mjm_ragged_forms<Tr> 
{
 typedef mjm_csv_mmp_form Myt;
typedef  mjm_ragged_forms<Tr>  Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// why the fck wont' these inherit fck 
typedef typename Super::Ragged Ragged;
typedef typename Ragged::Line Line;
typedef StrTy Word;
typedef std::vector<Word> Words;
typedef std::map<StrTy, IdxTy> DictTy;
typedef typename Super::CharClass CharClass; 

class parse_error
{
public:
parse_error() :m_w(),m_pos(0),m_msg() {}
parse_error(const StrTy & w, const IdxTy pos, const char * msg)
:m_w(w),m_pos(pos),m_msg(msg) {}
parse_error & scope(const StrTy & w) { 
Ss ss; ss<<w;  ss<<"::"; ss<<m_w; m_w=ss.str(); return *this;
}
StrTy dump() const { Ss ss; return dump(ss).str(); }
Ss &   dump(Ss & ss) const { 
ss<<MMPR3(m_w,m_pos,m_msg); // <<CRLF; 
return ss; } 
StrTy m_w; IdxTy m_pos; const char * m_msg;
};



class compiled_noun
{
typedef std::map<StrTy,D> CanonMap;
typedef std::map<StrTy,D> AdjMap;




class noun_evaluation
{
typedef noun_evaluation Myt;
typedef parse_error Error;
typedef std::vector<Error> Errors;
public:
//noun_evaluation():m_val(-1),m_of(-1) {}
noun_evaluation() {}
noun_evaluation(const StrTy & a ):m_alias(a) {}
class eval_unit
{
typedef eval_unit Myt;
public:
enum { A=0, B=1, SFX=2};
eval_unit(): m_a(1),m_b(1),m_q(1),m_state(0),m_sfx() {}
void clear() { m_a=1; m_b=1; m_state=9; m_sfx=""; } 
const StrTy & canon() const { return m_alias; } 
Myt  operator*(const D & p) { Myt x=(*this); x.m_q*=p; return x; } 
bool has_qty_data() const
{// zero specified is ok, if not zero needs to be by default 
if (m_q==0) return false;
if (Bit(m_state,A)) return true;
return Bit(m_state,B); 
}
// this is a dumb place for updating m_q... 
void a(const D & _a) { m_a=_a; m_q=m_a*m_b; m_state|=(1<<A);}
void b(const D & _b) { m_b=_b; m_q=m_a*m_b; m_state|=(1<<B);}
bool n(const D & _n) { 
if (Bit(m_state,A)) 
{
if (!Bit(m_state,B)) b(_n);
else return false;
}
 else { a(_n);}  return true;  }
void sfx(const StrTy & _s) { m_sfx=_s; m_state|=(1<<SFX);}
void sfx(const char *  _s) { m_sfx=StrTy(_s); m_state|=(1<<SFX);}
bool have_sfx() const { return Bit(m_state,SFX); } 
const StrTy & sfx()const {return  m_sfx;}
const D& qty() const { return m_q; }

StrTy dump() const { Ss ss; return dump(ss).str(); }
Ss &   dump(Ss & ss) const { 
ss<<MMPR(Bit(m_state,SFX)); ss<<MMPR(Bit(m_state,A)); 
ss<<MMPR2(Bit(m_state,B),m_q); ss<<MMPR4(m_a,m_b,m_state,m_sfx);
return ss; } 

D m_a,m_b,m_q;
IdxTy m_state;
StrTy m_sfx;
friend noun_evaluation;
}; // eval_unit

bool ok() const { return m_errors.size()==0; }
const D & qty() const { return m_ate.qty();}
const StrTy & sfx() const { return m_ate.sfx();}
const D & of() const { return m_offered.qty();}
//const D & accepted() const {if (m_of<=0) return 1;  return m_val/m_of;}
const StrTy & canon() const { return m_alias; } 
//const StrTy & units() const { return m_units; } 
Errors & errors() { return m_errors; } 
void add_error(const StrTy & w, const IdxTy pos, const char * msg)
{ 
MM_ERR(MMPR3(w,pos,msg))
m_errors.push_back(Error(w,pos,msg)); }
StrTy dump() const { Ss ss; return dump(ss).str(); }
Ss& dump(Ss & ss) const 
{
ss<<MMPR(m_alias);
ss<<"m_ate "; m_ate.dump(ss);
ss<<"m_offered "; m_offered.dump(ss);
MM_LOOP(ii,m_errors) { (*ii).dump(ss); } 
return ss; 
}

bool has_qty_data() const 
{ return m_ate.has_qty_data()||m_offered.has_qty_data(); } 
Myt operator*(const D eta) const 
{ Myt x=(*this); x.m_ate.m_q*=eta;
 x.m_offered.m_q*=eta;
return x;
}
void scale(const D offered, const D ate )
{
m_ate.m_q*=ate;
m_offered.m_q*=offered;
}
private:

Errors m_errors;
eval_unit m_ate,m_offered;
//D m_val; D m_of; 
StrTy m_alias; 
//StrTy m_units;
friend compiled_noun;
}; // noun_evaluation 

public:
compiled_noun() {Init(Line()); }
compiled_noun(const Line & l) {Init(l); }
enum { IGNORE=0 };
typedef noun_evaluation evaluation;
evaluation evaluate(const StrTy & name, const Words & adj, CharClass * pcc)
{ return Evaluate(name, adj,pcc); } 

private:
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
 evaluation Evaluate(const StrTy & name, const Words & adj, CharClass * pcc)
{
// numbers, shrimp, suffixes, adjectives ( details, maker, etc ) 
evaluation rc(name);
typename evaluation::eval_unit eu;
const IdxTy sz=adj.size();
IdxTy error=0;
bool past_of=false;
bool have_pct=false; // a one word percent eaten of offered. 
D pct_var=0;
Word a="",last="";
for(IdxTy i=0; i<sz; ++i)
{
last=a;
a=adj[i];
if (a=="of")
{ // finish the amount eaten now go to amount given
if (past_of) { rc.add_error(a,i,"multiple \"of\"");  } 
rc.m_ate=eu;
eu.clear();
//units_eaten=units; units=""; qty_eaten=q*b; q=1; b=1;
past_of=true;
continue; 
} // of
if (sfx(a.c_str())!= (~0)) { 
if (eu.have_sfx()){  rc.add_error(a,i,"multiple sfx ");  } 
//have_sfx=true; units=a; 
eu.sfx(a);
continue; }
if (m_adjs.find(a)!= (m_adjs.end())) {  continue; }
typedef typename CharClass::read_buffer Rb;
 Rb rb;
//typename CharClass::read_buffer rb;
rb.clear();
(*pcc).parse_groups(rb,a.c_str());
// qty- int/float ^sfx, size=int/float[- ]sfx
// units = sfx
// shrimp int-x-int, fraction int-/-int 
const IdxTy n=rb.string_count();
if (n==0) continue;
if (n==2)
{
if ((rb[0][0]==CharClass::TINT)||(rb[0][0]==CharClass::TFLOAT))
{
	if (!eu.n(atof(rb[1]))) rc.add_error(a,i,"too many numbers");
} // int or float
	else rc.add_error(a,i,"bad adjective");
continue;
} // n==2
if (n==4) // number sfx
{
const bool one_no= ((rb[0][0]==CharClass::TINT)||(rb[0][0]==CharClass::TFLOAT));
const bool two_sfx= ((rb[2][0]==CharClass::TALPHA));
if ((one_no)&&(two_sfx))
{	if (!eu.n(atof(rb[1]))) rc.add_error(a,i,"too many numbers");
if (strcmp(rb[3],"pct")==0) 
{
if (have_pct) 
{	rc.add_error(a,i,"too many pct values using last one ");
have_pct=true;
pct_var=atof(rb[1]);
}
}
if (eu.have_sfx()){  rc.add_error(a,i,"multiple sfx ");  } 
eu.sfx(rb[3]);

continue;
}
else rc.add_error(a,i,"bad fields "); 
} // n==4
else if (n==6) // shrimp only convert to mg 
{
const bool one_no= ((rb[0][0]==CharClass::TINT));
const bool three_no= ((rb[4][0]==CharClass::TINT));
const bool isx=(strcmp(rb[3],"x")==0);
if (!(one_no&&three_no&&isx)) rc.add_error(a,i," bad alphanum adj");
const IdxTy q=atoi(rb[1]);
const IdxTy sz1=atoi(rb[4])/100;
const IdxTy sz2=atoi(rb[4]+2);
D avg=D(sz1+sz2)/2;
avg=D(q)/avg*28.0;
eu.sfx("g");
if (!eu.n(avg)) rc.add_error(a,i,"too many numbers");
continue;
} // n==6 

Ss ss; ss<<" bad adjective too many fields "<<MMPR4(a,i,n,rb[n-1]);
rc.add_error(a,i,ss.str().c_str());
// pattern is type char followed by string value 
//for(IdxTy j=1; j<n; j+=2)
//{
// number-sfx or number sfx times any number 
// maybe density for volume, needs to reflect adjectives etc.
// for ignored nouns must evaluate to zero 
// "of", accuracy- weighted, measured

//} // j 

} // i 
if (past_of) { rc.m_offered=eu;  }
else { rc.m_ate=eu;  } 
if (have_pct)
{
 if (past_of) 
	rc.add_error(m_name,0,"percent consumed not compaitble with \"of\"  "); 
rc.m_ate=rc.m_offered*pct_var;
}
if (Bit(m_flags,IGNORE))
{
if (rc.has_qty_data())
 rc.add_error(m_name,0,"ignore placeholder noun has meaninful entry  "); 
}
//MM_ERR(MMPR(rc.dump()))
return rc;
} // Evaluate 
static IdxTy sfx(const char * s)
{
typedef std::map<StrTy,IdxTy> SfxMap;
static SfxMap m;
if (m.size()==0)
{
m["mg"]=1;
m["g"]=1;
m["kg"]=1;
m["ml"]=2;
m["cc"]=2;
m["tsp"]=2;

}
auto ii=m.find(StrTy(s));
if (ii!=m.end()) return (*ii).second;
return  ~0; 
} // sfx

void Init(const Line & l) 
{
m_flags=0;
m_default=1;
m_pcc=0;
const IdxTy szl=l.size();
if (szl<1) return; 
m_name=l[0];
for(IdxTy i=1; i<szl; ++i)
{
const Word & w=l[i];
// parts need to work with adjectives... 
if ((w=="part"))
{
++i; if (i>=szl) break;
const StrTy alias=l[i];
D fac=1.0;
++i; if (i<szl) fac=atof(l[i].c_str()); 
m_parts[alias]+=fac;
continue;
} //part 
if ((w=="canon"))
{
++i; if (i>=szl) break;
const StrTy &  alias=l[i];
m_canon=alias;
continue;
} // canon

if ((w=="ignore")) { m_flags|=(1<<IGNORE); continue; } 
if ((w=="default-qty")) { ++i; if (i<szl) m_default=atof(l[i].c_str()); 
 continue; }  // default-qty
if ((w=="adj")) { ++i; if (i<szl) m_adjs[w]+=1; continue; }  //
if ((w=="adjextive")){ ++i; if (i<szl) m_adjs[w]+=1; continue; } // 
MM_ERR(" unknown noun mod "<<MMPR3(m_name,w,i))
} // i 
} // Init

StrTy m_name,m_canon;
CanonMap m_parts;
AdjMap m_adjs;
IdxTy m_flags;
D m_default;
CharClass * m_pcc;
}; // compiled_noun

typedef compiled_noun Cnoun;
typedef std::vector<Cnoun> CnounVec;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:

// need an "eaten vs served percentage and prepared ahead of time?
enum { IGNORE,LPAREN,RPAREN,RESERVED,NOUN,TIME,DATE,MACRO,NAME,AMPERSAND,BSLASH, BAD=Super::BAD};
enum { MACRONOUN=0};
//MM_ERR("class "<<MMPR3(w,c,class_enumval(c)))
enum { MACROMASK=CharClass::UC|CharClass::DIGIT, DIGIT=CharClass::DIGIT};
enum { LC=CharClass::LC};
enum { UC=CharClass::UC};


class parse_settings
{

static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
public:
enum {MARKUP, OUTCLEAN, BLANK, RECIPES }; 
parse_settings() : m_state(0) {}
parse_settings(const IdxTy s) : m_state(s) {}
// output a new Ragged file with the original annotated
// with comment lines for errors 
bool markup() const { return Bit(m_state,MARKUP); }
// output a cleaned up version which may include canonical dates and nouns
// with multiple spaced, parens, and "no" nouns removed.
bool outclean() const { return Bit(m_state,OUTCLEAN); }
// put everything in parens for use the next day. 
bool blank() const { return Bit(m_state,BLANK); }
bool dont_expand_recipes() const { return Bit(m_state,RECIPES); } 
private:
IdxTy m_state;


}; // parse_settings
typedef parse_settings PO;



class parse_state
{
typedef parse_state Myt;
typedef parse_error Error;
typedef std::vector<Error> Errors;
enum {DATED=1, CONSUMER=(1<<1),RESERVED=(1<<2),
NOUNED=(1<<3),LATEX=(1<<4), ADJ=(1<<5), MACROEVAL=(1<<6) };
// MACRO def must be at DATED&!CONSUMER&!RESERVED&!NOUNED 
//Test(DATED)&&!Test(CONSUMER|RESERVED|NOUNED)
bool Test( const IdxTy mask) const { return (state&mask)!=0; } 
bool Test(const IdxTy state, const IdxTy mask) const { return (state&mask)!=0; } 
bool TestAll( const IdxTy mask) const { return (state&mask)==mask; } 
bool TestAll(const IdxTy state, const IdxTy mask) const 
{ return (state&mask)==mask; } 

typedef typename compiled_noun::evaluation E; 
// date,consumer,noun,time, qty (  , units )
typedef std::map<D,E> Emap;
typedef std::map<StrTy,Emap> NounMap;
typedef std::map<StrTy, NounMap> ConsumerMap;
typedef std::map<StrTy,ConsumerMap> DateMap;
typedef mjm_snacks_accumulator<Tr> DateMap2;
typedef std::vector<E> Evec;
//ne=dm[cdates][consumer][canon][tmft()]; 
public:
parse_state():form(0),line(0),nparen(0), d(0),j(0),j0(0),state(0)
,date(0), old_date(0),time(0),depth(0),
markup(0),blank(0),canonical(0),mom(0),root(this),
per_noun_os(0),debug_os(0),dmlocal(0),dm(0),exp(0)  {} 
// macro def needs to get the line numer 
parse_state(parse_state & p ):form(p.form),line(p.line),nparen(0), d(0),j(0),j0(0),state(0)
,date(p.date), old_date(p.old_date),time(p.time),depth(p.depth+1),
markup(p.markup),blank(p.blank),canonical(p.canonical)
,mom(&p),root((p.root==&p)?mom:p.root) ,
per_noun_os(0),debug_os(0),dmlocal(0),dm(0),exp(1)  {
//MM_ERR(" copy ctor called ")

} 

void adj(const Word & w ) { state|=ADJ;  adjectives.push_back(w); }
enum { IGNORE=1 };
bool skipping() const { return nparen!=0; } 
// need to verify this is in a name location and NOT a adjective
void have_name(const StrTy & w) {
//MM_ERR( " should ba name "<<MMPR2(w,Test(state,CONSUMER)))
if ( Test(state,CONSUMER))  adj(w); 
else { //if (!expanding()) 
consumer=w; 
state|=CONSUMER; } 
}
// comments, note , outcome, DMEL, AKA obsolete etc
// aggregate and do something 
void have_reserved(const StrTy & w) {
if (!Test(state,CONSUMER)){ consumer=w; state|=RESERVED; } 
else // if we already have a consumer, this is not a reserved
// word but rather bad choice of macro or adjective
{
add_error(w,j,"can not use reserved word here   ");
}

}
void have_latex(const StrTy & w) {
state|=LATEX;

}
D tfmt() const { return int(time*60)/60; } 
// a new data point for date, time, consumer, noun, qty 
void have_noun(E & ne) {
// could just save ne's in big collection 
// date,consumer,noun,time, qty (  , units )
// really want a tokenized ragged with float columns .... 
state|=NOUNED;
if (depth==0)
{
if (dm==0) dm= new DateMap2();
dm->add(*this);
} 
else
{
evec.push_back(ne);
adjectives.clear();
return; // avoid checking anything here 
}

if (debug_os!=0)  
	(*debug_os)<<" DEBUG NOUN "<<MMPR4(cdates,consumer,ne.canon(),tfmt())
		<<MMPR2(ne.qty(),ne.sfx())<<CRLF; 
if (tfmt()==0)
	add_error(ne.canon(),0," time of zero likely an error ");
// MM_ERR(" FICL "<<MMPR((debug_os!=0)))
adjectives.clear();
} // have_noun 1 param 

//  ne is based on the adjectives for the macro which was expanded into ps2
// this needs to allow for variables etc. 
void have_noun(E & ne, Myt & ps2) 
{
state|=NOUNED;
if (ps2.time>time) time=ps2.time;
MM_LOOP(ii,ps2.evec)
{
// offered and ate should be in ne not in ps2 entries, 
// just multiply ne terms by each ps2 term
E neq=(*ii);
//neq=neq*ne.offered();
neq.scale(ne.of(),ne.qty());
//operator
have_noun(neq);

} // ii 
adjectives.clear();
// ps2 not reusable will go out of scope soon 
} // have_noun 2 param 
void have_date(const IdxTy ival,const StrTy & w) 
{ 
// if we already have a date, need to punt to adjectives
if (Test(DATED)) add_error(w,j," alreadhy have a date");
dates=w; cdates=w;  date=ival; state|=DATED;
if (date<old_date)
add_error(w,j," new date less than old date");
  }
bool have_macro_def(const StrTy & w, DictTy & dmacros )
{ // true of def, false if requires expansion 
tname=w; // stupid kluge should be saved ... 
// in this state, it should be a definition not a usage 
const bool want_def=Test(DATED)&&!Test(CONSUMER|RESERVED|NOUNED);
auto ii=dmacros.find(w);
// these need to be defined everyday for a macro recipe. 
bool found=(ii!=dmacros.end());
// with prefix adjectives, the expansion already has the prefactors
// for evaluation .. 
return want_def;

} // have_macro_def
void rparen() {unparen(); }
void paren() {++nparen; }
void unparen() {
// verify not zero ... 
if (nparen==0) add_error("",j," too many right parens ");
else --nparen; }
StrTy dump() const { Ss ss; ss<<MMPR4(d,j,state,date)<<MMPR2(time,adjectives.size());  return ss.str(); }
// at end of processing a line
void new_line() { 
// do someething with dangling adjectives 
if (adjectives.size()!=0) add_error("",j," unused adjectives at end of line  ");
// check and reset paren count 
if (nparen!=0) add_error("",j," dangling  parens ");
nparen=0;
old_err[line]=errors;
errors.clear();
old_date=date;
d=0; j=0; state=0; date=0; time=0;
adjectives.clear();
dates=""; cdates=""; entry_type="";
consumer="";
++line; }
void add_error(const StrTy & w, const IdxTy pos, const char * msg)
{ 
MM_ERR(MMPR3(line,date,consumer)<<MMPR3(w,pos,msg))
errors.push_back(Error(w,pos,msg)); }
void add_errors(Errors & e) { MM_LOOP(ii,e) errors.push_back(*ii); e.clear(); }
void add_errors(Myt & that) { Errors & e=that.errors;  
Ss ss;
ss<<tname<<"("<<j<<")";
const StrTy pfx=ss.str(); // (that.evec.size()>0)?that.evec[0].canon():"";
MM_LOOP(ii,e)
{
//auto ee=(*ii);
 errors.push_back((*ii).scope(pfx));
}
 e.clear(); }
bool expanding() const { return exp!=0; } 


Errors errors; 
typedef std::map<IdxTy,Errors> OldErr;
OldErr old_err;
void markup_form(const IdxTy flags=0 )
{
Ragged & r=*form;
Ragged & d=*markup;

MM_SZ_LOOP(i,r,szr)
{
const Line & l=r[i];
d.add(l);
auto ii=old_err.find(i);
if (ii==old_err.end()) continue;
MM_LOOP(jj,(*ii).second)
{
Line x;
x.push_back("#");
x.push_back((*jj).dump());
d.add(x);
} // jj 
} // i 

} // markup

Ragged * form;

IdxTy line,nparen;
IdxTy d,j,j0;
IdxTy state;
IdxTy date,old_date;
// date string as found and canonical version 
StrTy dates,cdates,consumer;
StrTy entry_type;
D time;
IdxTy depth; // recursion for recipe expansion 
Words adjectives;
Ragged * markup;
Ragged * blank;
Ragged * canonical;
Myt * mom,* root;

OsTy * per_noun_os;
OsTy * debug_os;
Evec evec;
DateMap*  dmlocal; // don't really want this here for recursion.. 
DateMap2*  dm; // don't really want this here for recursion.. 

IdxTy exp;
StrTy tname;
}; // parse_state 

typedef parse_state PS;


mjm_csv_mmp_form() {Init();}
~mjm_csv_mmp_form() {}

//m_form_fn=fn; Load(Super::m_form,m_form_fn);
//StrTy m_form_fn, m_nouns_fn,m_reserveds_fn;
//Ragged m_reserveds, m_nouns,m_macros;
void clear_form() { Super::m_form.clear(); } 
void load_form(const StrTy & fn){m_form_fn=fn; Super::Load(Super::m_form,fn,1); }
void load_form(IsTy & is){m_form_fn=""; Super::load(is,1); }
void load_nouns(const StrTy & fn){m_nouns_fn=fn; Super::Load(m_nouns,fn,0); }
void load_recipes(const StrTy & fn){m_nouns_fn=fn; Super::Load(m_recipes,fn,0); }
void load_ignores(const StrTy & fn){m_ignores_fn=fn; Super::Load(m_ignores,fn,0); }
void load_reserveds(const StrTy & fn){m_reserveds_fn=fn; Super::Load(m_reserveds,fn,0); }
void index() { Index(); } 
void parse(PS& ps, parse_settings & po)
 { index();  Parse(ps,po); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//cpputil -enumc class_enumval
StrTy class_enumval(const IdxTy c)
{
switch (c)
{
case IGNORE : { return "IGNORE"; }
case RPAREN : { return "RPAREN"; }
case LPAREN : { return "LPAREN"; }
case RESERVED : { return "RESERVED"; }
case NOUN : { return "NOUN"; }
case TIME : { return "TIME"; }
case DATE : { return "DATE"; }
case MACRO : { return "MACRO"; }
case NAME : { return "NAME"; }
case AMPERSAND : { return "AMPERSAND"; }
case BSLASH : { return "BSLASH"; }
case BAD : { return "BAD"; }
default : MM_ERR(" class_enumval bad enum value "<<MMPR(c))
} // switch 
return StrTy("bad_enum_value");
} // class_enumval 




//public:
//void Parse(const Line & l, IdxTy flags=0)
void Parse(const Line & l, PS & ps, parse_settings & po)
{
//MM_ERR("Parse fck "<<MMPR2(l.size(),ps.j))
const IdxTy szl=l.size();
for(IdxTy j=ps.j0; j<szl;++j)
//MM_SZ_LOOP(j,l,szl)
{
ps.j=j;
//MM_ERR("Parse fck "<<MMPR2(l.size(),ps.j))
D val=0;
const Word & w=l[j];
if (w.c_str()[0]=='#') break;
// this skicks parsing in a badlocation.. . 
//if (ps.skipping()) { if (w.c_str()[0]!=')') continue ; } 
IdxTy c=Syntax(w,j,ps,&val);
//MM_ERR("class "<<MMPR3(w,int(c),class_enumval(c)))
IdxTy ival=val;
if (ps.skipping()) { if (c==RPAREN) ps.rparen(); continue ; } 
switch (c)
{
case TIME: { if (val>ps.time) ps.time=val; break; } 
// these can be mostly string free form notes and dmel etc 
// need handlers though for recipe which transcends a given day 
// also need variables for things like "made on day xxx" 
case RESERVED: { ps.have_reserved(w); if (true)  return ;  break; } 
case NOUN: { 
auto x=m_cnouns[ival].evaluate(w,ps.adjectives, &  (Super::m_cc));
// need to pickup these errors into ps
//MM_ERR("NOUN "<<MMPR3(w,j,ps.dump()))  ps.adjectives.clear();  
//MM_ERR(MMPR(x.dump()))
ps.add_errors(x.errors());
ps.have_noun(x);
//MM_ERR("NOUN "<<MMPR4(w,j,x.qty(),ps.dump()))  ps.adjectives.clear();  
break; } 
case DATE: { ps.have_date(ival,w);  break; } 
case MACRO: { 
// normally this is word 2 with ampersand or word 1 without
// this it is a definition although now allow kewyrod "RECIPE"
// to precede.
if (ps.have_macro_def(w,m_dmacros))
{ // either save the def or we are expanding it and this is the
// name of the macro on first occurence...  
if (ps.expanding())
{

 ps.have_name(w);   

} // expanding
else { 
// if true, this should be a defintion, put into dmacros
// this only has the latest one,
m_dmacros[w]=m_macros.size();
// on expansion, the most recent one will be found and checked for
// too-old
m_macros.add(l);
return ; // nothing to do although macro should be validadated
 } // not expanding 

} // have_macro_def
else // if not a def and a def is found, take adjectives and expand the macro
{
const Line * lmp=0;
auto ii=m_dmacros.find(w);
// these need to be defined everyday for a macro recipe. 
bool found=(ii!=m_dmacros.end());
if (found) { 
// verify dates are equal,
//MM_ERR(" evaluate macro or recipe "<<MMPR(w))
//const Line & lm= m_macros[(*ii).second];
 lmp= &  m_macros[(*ii).second];
if ((*lmp)[0]!=l[0])
{
Ss ss;
ss<<" no current macro def dates "<<MMPR2((*lmp)[0],l[0]);
ps.add_error(w,j,ss.str().c_str());
}
} // found 
if (!found)
{
auto jj=m_drecipes.find(w);
found=(jj!=m_drecipes.end());
 lmp= &  m_recipes[(*jj).second];
}
if (!found)
{
if (!Ignore(w)) ps.adj(w); break;
// ps.add_error(w,j," macro not found"); 
}
const Line & lm=(*lmp);
// then recurse but define the evluation like anther noun,
//PS ps2=PS(ps);
// always do this for error checking... 
PS ps2=ps;
Parse(lm,ps2,po);
ps.add_errors(ps2);
//auto x=m_cnouns[ival].evaluate(w,ps.adjectives, &  (Super::m_cc));
// so ps2 contains all the noun evals and need to be multiplied
// by the adjective list. Use the reserve MACRONOUN for this
auto x=m_cnouns[MACRONOUN].evaluate(w,ps.adjectives, &  (Super::m_cc));
//MM_ERR(MMPR(x.dump()))
ps.add_errors(x.errors());
if (po.dont_expand_recipes()) ps.have_noun(x);
else ps.have_noun(x,ps2);


} // else


// if no def today, or no def ever??? 

 break; } 
// 
case NAME: { ps.have_name(w);  break; } 
case IGNORE: {  break; } 
case LPAREN: {ps.paren();  break; } 
case RPAREN: {ps.unparen();   break; } 
case AMPERSAND: { ps.have_latex(w);  break; } 
case BSLASH: { ps.have_latex(w);  break; } 

default: 


if(!Ignore(w)) ps.adj(w);
} ; // switch

} // j


} // Parse
bool Ignore(const StrTy & w)
{ return (m_dignores.find(w)!=m_dignores.end());  }
// may want to just validate, output time/qty, make template, markup
// markup and template need to generate another Ragged
// output time/qty not sure on dest  but may be Ragged

void Parse(PS& ps, parse_settings & po)
//void Parse(IdxTy flags=0)
{
//IdxTy flags=0;
Ragged & r= Super::m_form;
ps.form=&r;
IdxTy lno=0;
MM_LOOP(ii,r)
{
const Line & l =(*ii);
//MM_ERR(" parsing line "<<MMPR2(lno,l.size()))
++lno;
//Parse(l,flags);
Parse(l,ps,po);
ps.new_line();
} // ii 
// generate a blank template with zero quantities and placeholders
// left in 
if ( po.blank())
{


} // blank
if (po.markup())
{
ps.markup = new Ragged();
ps.markup_form();
} 
} // Parse

//enum { IGNORE,RESERVED,NOUN,TIME,DATE,MACRO,NAME, BAD=Super::BAD};

//enum { MACROMASK=CharClass::UC|CharClass::DIGIT, DIGIT=CharClass::DIGIT};
IdxTy Syntax(const StrTy & word, const IdxTy pos, PS & ps,  D * val =0 )
{
IdxTy p=0;
IdxTy * pp=&p;
const char * wp=word.c_str();
const IdxTy len=word.length();
if (len==1) {
if (wp[0]=='&') return AMPERSAND;
if (wp[0]=='(') return LPAREN;
if (wp[0]==')') return RPAREN;
if (wp[0]=='\\') return BSLASH;
}
if (IsIn(word,m_dreserveds,pp)) { if(val) *val=p;  return RESERVED; }
if (IsIn(word,m_dnouns,pp)){ if (val) *val=p;  return NOUN;}
if (IsIn(word,m_dates,pp)) if (m_dates[word]!=0)
{
//if (val) *val=atof(m_dates[word].c_str());
if (val) *val=p; // m_dates[word];
 return DATE;
}
const bool macro=Macro(word);
const bool time=Time(word,val);
const bool name=Name(word);
//MM_ERR(MMPR(pos)<<MMPR4(word,macro,time,name))
if (time) return TIME;
if (name) return NAME;
if (macro) return MACRO;
if (pos!=0) return BAD;
//IdxTy ds=0;
const StrTy gdate=GoodDate(pp,word);
const bool date=(gdate==word);
//if (ds!=0) 
if (date){  m_dates[word]=p;
if (val) *val=p; // atof(m_dates[word].c_str());
}
MM_ERR(MMPR2(pos,p)<<MMPR4(word,macro,time,name)<<MMPR2(gdate,date))
if (date) return DATE;
//StrTy z= Super::m_hand.serial_days(Super::m_hand.lexi_days(word));

// fcking templated base fcking class fck 
return BAD;
} // word

StrTy GoodDate(IdxTy * pn, const StrTy & w)
{
StrTy dlexi= (Super::m_hand.lexi_days(w));
if (pn==0) return dlexi;
IdxTy dn= atoi(Super::m_hand.serial_days(dlexi).c_str());
*pn=dn;
return dlexi;
}

bool Name(const StrTy & w)
{
const char * s=w.c_str();
if (*s==0) return false;
const IdxTy len=w.length();
IdxTy mask=UC;
if (!Cmask(s[0],mask)) return false;
++s;
mask=m_mask_name|LC|DIGIT;
while (*s!=0)
{
if (!Cmask(s[0],mask)) return false;
++s;
}
return true;
}
bool Time(const StrTy & w, D * val)
{
const char * s=w.c_str();
if (*s==0) return false;
const IdxTy len=w.length();
if (len==6)
{
//if (!Super::m_cc.mask(s[0],DIGIT)) return false;
if (!Cmask(s[0],DIGIT)) return false;
if (!Cmask(s[1],DIGIT)) return false;
if (!Cmask(s[2],DIGIT)) return false;
if (!Cmask(s[3],DIGIT)) return false;
const IdxTy t=atoi(s);
const IdxTy min=atoi(s+2);
if (min>59) return false;
//val=((t-min)*60.0 + min)/60.0;
if (val) *val=(t-min) + (D(min)/60.0);
// on the edge not allowed lol 
if (t==0) return false;
if (t>=2400)  return false;
if (s[5]!='M') return false;
if (s[4]=='P') {  return (t>=1200); } 
if (s[4]=='A') {  return (t<=1200); } 
return false; 
}
else if (len==5)
{
if (!Cmask(s[0],DIGIT)) return false;
if (!Cmask(s[1],DIGIT)) return false;
if (!Cmask(s[4],DIGIT)) return false;
if (!Cmask(s[3],DIGIT)) return false;
const IdxTy min=atoi(s+3);
if (val) *val=atoi(s)+(D(min)/60.0);
return (s[2]==':');
}
return false; 
} // Time
bool Macro(const StrTy & w)
{
const char * s=w.c_str();
if (*s==0) return false;
while (*s!=0)
{
//if (!Super::m_cc.mask(*s,MACROMASK)) return false;
if (!Cmask(*s,MACROMASK)) return false;
++s;
}
return true;
}

bool Cmask(const char c, const IdxTy m)
{ return Super::m_cc.mask(c,m); } 
///if (!Super::m_cc.mask(s[0],DIGIT)) return false;

bool IsIn(const StrTy & w, const DictTy & d, IdxTy * p=0 )
{
auto ii=d.find(w);
const bool found=(ii!=d.end());
if (found) if (p!=0) *p=(*ii).second;
return found; 
//return (d.find(w)!=d.end()) ; // null entries should not exist 
//return false;
}

/*
void xxx()
{
StrTy x= Super::m_hand.serial_days(Super::m_hand.lexi_day());
StrTy y= Super::m_hand.serial_days(Super::m_hand.lexi_days("1 day ago"));
StrTy z= Super::m_hand.serial_days(Super::m_hand.lexi_days("2020-07-20"));
MM_ERR(MMPR3(x,y,z))
}
*/
void Index()
{
m_nouns.index_field(m_dnouns,0,0,0);
m_recipes.index_field(m_drecipes,0,0,0);
m_reserveds.index_field(m_dreserveds,0,0,0);
m_ignores.index_field(m_dignores,0,0,0);
m_cnouns.resize(m_dnouns.size());
MM_LOOP(ii,m_dnouns)
{
IdxTy i=(*ii).second;
const Line & l =m_nouns[i]; 
m_cnouns[i]=Cnoun(l);


} // ii 

} // Index

void Init()
{
m_mask_name=Super::m_cc.uset("_-");

}

//m_form_fn=fn; Load(Super::m_form,m_form_fn);

// members
StrTy m_form_fn, m_nouns_fn,m_reserveds_fn,m_ignores_fn;
Ragged m_reserveds, m_nouns,m_recipes,m_macros,m_ignores;
//Ragged m_class; // parse classification of corresponding thing in m_form. 
DictTy m_dnouns, m_dreserveds,m_dmacros,m_drecipes,m_dates,m_dignores;
CnounVec m_cnouns;
IdxTy m_mask_name;
}; // mjm_diet_diary_form

//////////////////////////////////////////////


////////////////////////////////////////////
#ifdef  TEST_MJM_DIET_DIARY_FORM
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_diet_diary_form <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_DIET_DIARY_FORM "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_diet_diary_form<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
typedef Myt::parse_settings PO;
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="parse") 
{PO po; Myt::parse_state ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}

if (cmd=="blank") 
{PO po(1<<PO::BLANK); Myt::parse_state ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}
if (cmd=="markup") 
{PO po(1<<PO::MARKUP); Myt::parse_state ps; ps.debug_os=&std::cerr;  
x.parse(ps,po);
typedef std::stringstream Ss;
Ss ss;
x.save(ss,*(ps.markup));
MM_ERR(ss.str()) 
}

if (cmd=="load") { x.load(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-form") { x.load_form(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-nouns") { x.load_nouns(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-ignores") { x.load_ignores(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-reserveds") { x.load_reserveds(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="dump") { MM_ERR(x.dump()) }
//if (cmd=="xxx") { x.xxx(); }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DIET_DIARY_FORM_H__ 
