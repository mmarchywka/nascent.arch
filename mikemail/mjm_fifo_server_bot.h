#ifndef MJM_FIFO_SERVER_BOT_H__
#define MJM_FIFO_SERVER_BOT_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#include <mjm_pawnoff.h>
// generalized from wscat, connect a command to fifo's and let it run

// Tue Jan  4 07:47:10 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_fifo_server_bot   
// g++  -Wall -std=gnu++11 -DTEST_MJM_FIFO_SERVER_BOT -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_fifo_server_bot.h  -lpthread -lreadline

template <class Tr>
class mjm_fifo_server_bot 
{
 typedef mjm_fifo_server_bot Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_pawnoff<Tr> Hand;
// needs to use pawn def 
typedef mjm_blob<Tr> Blob;
typedef pthread_t ThreadId;

typedef std::ifstream FifoIn;
typedef std::ofstream FifoOut;

public:
mjm_fifo_server_bot() {Init();}
~mjm_fifo_server_bot() {Free();}

IdxTy kill( const IdxTy flags=0) { return Kill(flags); } 
IdxTy send(const StrTy & cmd, const IdxTy flags=0) { return Send(cmd,flags); } 
StrTy  receive(const IdxTy n, const IdxTy ns,const IdxTy flags=0)
{ return  Receive( n, ns, flags); } 
template <class Ty> IdxTy get_names(Ty & tm, const IdxTy flags=0) { return GetNames(tm,flags); } 
template <class Ty> IdxTy done_names(Ty & tm, const IdxTy flags=0) { return DoneNames(tm,flags); } 
void infifo(const StrTy & nm) { m_fifo1=nm;}
void outinfifo(const StrTy & nm) { m_fifo2=nm;}
FifoIn * in() { return m_ifs;}
FifoOut * out() { return m_ofs;}
int infd() { return fdin;}
int outfd() { return fdout;}
FILE* infdd() { return fddin; }
FILE* outfdd() { return fddout; }

void kill() { Free(); } 
bool isalive() {  return IsAlive(m_pid); } 
bool have_pid() {  return m_pid.length(); } 
StrTy pid() {  return m_pid; } 
IdxTy launch(const StrTy & cmd, const IdxTy flags=0 ) { return Launch(cmd,flags);}

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR3( m_pid, m_fifo1,m_fifo2);
ss<<MMPR4(  m_cmd, m_thread, m_state,fdin);
ss<<MMPR(fdout);
ss<<MMPR(isalive());
return ss.str(); }
typedef mjm_thread_util<Tr> ThreadTy;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

template <class Ty> IdxTy GetNames(Ty & tm, const IdxTy flags) { 
m_fifo1=tm.new_name(flags);
m_fifo2=tm.new_name(flags);
return 0; 
} 

template <class Ty> IdxTy DoneNames(Ty & tm, const IdxTy flags) 
{ 
tm.done_name(m_fifo1,flags);
tm.done_name(m_fifo2,flags);
return 0; 
} 





bool IsAlive(const StrTy & pid)
{
const StrTy res=Exec(StrTy("(ps a | awk -v pid=")+pid+"  '{ if ($1 == pid ) print $0; }') ");
MM_ERR(MMPR(res))
return (res.length()!=0);
}

IdxTy Send(const StrTy & cmd, const IdxTy flags)
{
++m_id_cnt;
StrTy x;
FILE* otf=outfdd();
MM_ERR(MMPR2(otf, cmd))
//MM_ERR(MMPR(wscato(0,0,0)))
StrTy carap=cmd+"\r";
fwrite(carap.c_str(),1,carap.length(),otf);
fflush(otf);
MM_ERR(MMPR2(carap, cmd))
return 0;
} //Send


StrTy  Receive(const IdxTy n, const IdxTy ns,const IdxTy flags)
{
StrTy x; 
FILE* inf=infdd();
if (inf==0) { MM_ERR(" null file pointer "<<MMPR3(inf,m_fifo1,m_fifo2)) }
long unsigned int fsz=1<<20;
long unsigned int fszlim=fsz-4;
char * line= new char[fsz];
IdxTy lines=0;
IdxTy sleeps=0;
IdxTy pos=0;
while (true)
{
int c=fgetc(inf);
if (c!=EOF)
{
line[pos]=c;
++pos;
//MM_ERR(MMPR4(c,char(c),pos,x.length()))
if (pos==fszlim)
{
line[pos]=0;
x+=StrTy(line);
pos=0;
} // pos 
if (c=='\r') ++lines;
else if (c=='\n') ++lines;
} // EOF 
else {
MM_ERR("EOF"<< MMPR3(x,lines,sleeps)) 
if (lines>=n)if ((ns==0)||(sleeps>0)) break;
if (sleeps>=ns) break;
sleep(1);
++sleeps;
continue;
}
//sleep(1);
} // while 
line[pos]=0;
x+=StrTy(line);

delete[] line;
return x;
} // Receive 




StrTy Exec(const StrTy & cmd) 
{
Blob dest,err,data;
// no trailing crtlf
const IdxTy rc=m_hand.fileio(dest,err,data,cmd,1);
MM_ERR(MMPR3(rc,StrTy(dest),StrTy(err)))
return StrTy(dest);
}
//m_mutex_vector = MutexVector(MU_SZ);
class tpclass
{
public:
Myt * p;
StrTy cmd;
}; // tpclass
static void * LaunchBro (void * p)
{
tpclass * tpc=(tpclass*) p;
Myt * pp=tpc->p; // (Myt*) p;
pp->Exec(tpc->cmd);
//Blob dest,err,data;
//pp->m_hand.fileio(dest,err,data,tpc->cmd);
//MM_ERR(MMPR2(StrTy(dest),StrTy(err)))
delete tpc;
return 0;
}
IdxTy Launch(const StrTy & cmd, const IdxTy flags ) 
{ 
// this dettached.. 
StrTy aval=m_pid;
if (aval.length())
{
MM_ERR(" not launching fifo_server  as already a listener "<<MMPR3(cmd,aval,aval.length()))
return ~0; 
}
Exec(StrTy("mkfifo ") +m_fifo1);
Exec(StrTy("mkfifo ") +m_fifo2);
// these block waiting for other end... 
m_cmd=cmd;
// cat /tmp/fifo1 | fifo_server -c ws://127.0.0.1:9222/foo | tee /tmp/fifo2 > /dev/null
// the blocking and eof behavior here is bizarre
StrTy pfx=StrTy("( echo $$ >> ")+m_fifo2+StrTy("  ; cat  ")+m_fifo1+" | " ;
StrTy xcmd=pfx+ cmd +"  2>&1 | tee -a "+m_fifo2+" >/dev/null ) " ;
MM_ERR(MMPR(xcmd))
tpclass* ptpc = new tpclass();
tpclass & tpc=*ptpc;
tpc.p=this;
tpc.cmd=xcmd;
auto tp=ThreadTy::launch(& Myt::LaunchBro,&tpc);
m_thread=tp;
m_state=1;
const bool do_files=false;
// if thread fails these hang... 
// these block waiting for other end... 
MM_ERR(" open fifos ")
if (do_files) {  m_ifs= new FifoIn(m_fifo2); } 
else {
fdin=open(m_fifo2.c_str(),O_RDONLY|O_NONBLOCK);
fddin=fdopen(fdin,"r");
}
//MM_ERR(" open output fifos ")
if (do_files) { MM_ERR(" don e init"<<MMPR2((*m_ifs).eof(),(*m_ifs).good()))
m_ofs= new FifoOut(m_fifo1); }
else
{ fdout=open(m_fifo1.c_str(),O_WRONLY);
fddout=fdopen(fdout,"a");}

//MM_ERR(" don e init"<<MMPR2((*m_ofs).eof(),(*m_ofs).good()))
MM_ERR(" don e init")
//mkfifo(m_fifo.c_str(),0777);
#if 1 
// need streams first... 
// if someone else has this open, it misses the pid... 
std::ifstream& ifs= *m_ifs; // (m_fifo2);
if (do_files) {
MM_ERR(MMPR3(m_pid,ifs.good(),ifs.eof()))
}
else MM_ERR(MMPR3(m_pid,fdin,fdout))
// DevTools listening on ws://127.0.0.1:9222/devtools/browser/4fa153b9-25fd-471f-aa37-73f2a5450262
//while(ifs.good())
if (do_files ){
while(true)
{
if ( ifs.eof()||!ifs.good())
{
MM_ERR(MMPR3(m_pid,ifs.good(),ifs.eof()))
if (0==m_pid.length())
{
sleep(1);
ifs.clear();
}
else break;
} // eof
// this is putting a cr or lf wtf
ifs>>m_pid;
// https://stackoverflow.com/questions/10178700/c-strip-non-ascii-characters-from-string
//m_pid.erase(remove_if(m_pid.begin(),m_pid.end(), __isascii), m_pid.end());  
m_pid=mjm_strings::trim_int(m_pid);
//MM_ERR(MMPR(xx))
if (m_pid.length())
{
MM_ERR(MMPR(m_pid))
return 0;
} //pid.len 
} // while  
} // do_files
else
{
char * line= new char[4096];
while (true)
{
long unsigned int sz=4094;
getline(&line,&sz,fddin);
if (line[0]==0) { sleep(1); }
else { m_pid=line; 
// AUCK
m_pid=mjm_strings::trim_int(m_pid); 
MM_ERR(MMPR2(m_pid,strlen(line))); 
// shoudl wait for connect message too 
// this was crucial for the fetch programmatically after
// launch need something more robust though
sleep(2);
delete  line;  break; } 

} // true 

} // do_files
#endif
return 0;

} // Launch 
void Init()
{
m_id_cnt=0;
m_ifs=0;
m_ofs=0;
m_state=0;
m_thread=0;
m_fifo1="/tmp/fifo1";
m_fifo2="/tmp/fifo2";
fdin=~0;
fdout=~0;
//Exec(StrTy("mkfifo ") +m_fifo1);
//Exec(StrTy("mkfifo ") +m_fifo2);
// these block waiting for other end... 
//MM_ERR(" open fifos ")
//m_ifs= new FifoIn(m_fifo2);
//MM_ERR(" open output fifos ")
//m_ofs= new FifoOut(m_fifo1);
MM_ERR(" don e init")
//mkfifo(m_fifo.c_str(),0777);

} // Init
IdxTy Kill(const IdxTy flags=0)
{
const StrTy pid=m_pid; // FindListener();
MM_ERR(" killing "<< MMPR2(pid.length(),pid))
if (isalive()) sleep(2);
if (pid.length())
{

Exec("kill "+pid);
return 0;
} // pid 
return 1;
} // Kill 


void Free()
{
Kill();
delete m_ifs;
delete m_ofs;
m_ifs=0;
m_ofs=0;
if (fdin!= ~0) close(fdin);
if (fdout!= ~0) close(fdout);
if (m_state&&m_thread)
{
MM_ERR(" not killing thread should die  "<<MMPR2(m_state,m_thread))
// race condition?
//pthread_kill(m_thread,SIGTERM);
m_state=0;
} // m_state

} // Free 

// MEMBERS
Hand m_hand;
StrTy m_pid;
StrTy m_fifo1,m_fifo2;
StrTy m_cmd;
ThreadId m_thread;
IdxTy m_state;
FifoIn *  m_ifs;
FifoOut *  m_ofs;
int fdin,fdout;
FILE * fddin,*fddout;
IdxTy m_id_cnt;
}; // mjm_fifo_server_bot

//////////////////////////////////////////////

template <class Tr>
class mjm_fifo_server_bot_map : public std::map<typename Tr::StrTy, mjm_fifo_server_bot< Tr > >  
{
 typedef mjm_fifo_server_bot_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_fifo_server_bot< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_fifo_server_bot_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_fifo_server_bot_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FIFO_SERVER_BOT
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_fifo_server_bot <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FIFO_SERVER_BOT "<<__DATE__<<" "<<__TIME__<<CRLF;
ss<<" MJM_FIFO_SERVER_BOT "<<"manipulate browser may use "<<CRLF;
ss<<" MJM_FIFO_SERVER_BOT "<<"fifo_server and rapidjson "<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_fifo_server_bot<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }
else if (cmd=="kill") { x.kill(atoi(cip.p1.c_str())); }
else if (cmd=="launch") { x.launch(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="send") { x.send(cip.p1,atoi(cip.p2.c_str())); }
else if (cmd=="rec") { MM_MSG(x.receive(atoi(cip.p1.c_str()),atoi(cip.p2.c_str()))); }
else if (cmd=="dump") { MM_MSG(x.dump(atoi(cip.p1.c_str()))); }
//else if (cmd=="wait") {char * foo= readline("waiting"); delete foo; }
else if (cmd=="wait") {while (x.isalive()){{MM_ERR(MMPR(x.isalive()));} sleep(2); }  }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FIFO_SERVER_BOT_H__ 
