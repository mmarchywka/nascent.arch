#ifndef MJM_MAILPROC_TOOBIB_HANDLER_H__
#define MJM_MAILPROC_TOOBIB_HANDLER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_mailproc_handler.h"
#include "mjm_csv_mmp_form.h"
#include "mjm_global_mailusers.h"
#include "mjm_fifo_server_bot.h"
#include "mjm_temp_man.h"
#include "mjm_mail_logger.h"
#include "mjm_bibtex_entry.h"

/*
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "../mjm_generic_message.h"
#include "mjm_msg_responder.h"
#include "mjm_pawnoff.h"
// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"
*/


// Thu Jun 18 20:35:41 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_mailproc_handler   

//  g++ -std=gnu++11 -DTEST_MJM_MAILPROC_TOOBIB_HANDLER -I. -I.. -I../../../mjm/hlib -I../../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_toobib_handler.h -lboost_filesystem  -lboost_system   -lpthread -lreadline


// g++ -std=gnu++11 -DTEST_MJM_MAILPROC_HANDLER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_handler.h  -lpthread -lreadline

template <class Tr> class mjm_mailproc_toobib_handler : public mjm_mailproc_handler<Tr>
{
 typedef mjm_mailproc_handler<Tr> Super;
 typedef mjm_mailproc_toobib_handler<Tr> Myt;

protected:

 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_msg_responder<Tr> MsgResponder;
//typedef mjm_msg_rules<Tr>  MyRules;
//typedef mjm_msg_jrnl<Tr>  MyJrnl;
//typedef mjm_mailproc_handler<Tr> MyMailHand;
//typedef mjm_mailproc_handler_map<Tr> MyMailHandMap;
typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef  Ragged::Line Rline;
typedef std::regex Regex;

typedef mjm_global_mailusers<Tr> Users;
typedef typename Users::user_desc Ud;


typedef mjm_fifo_server_bot<Tr> FifoServer;
//typedef mjm_temp_man<Tr> TempMan;

//typedef mjm_diet_diary_form<Tr> DietForm;

typedef mjm_mail_logger<Tr> MailLogger;

typedef mjm_bibtex_entry<Tr> BibEntry;
typedef mjm_bibtex_entry_map<Tr> BibEntryMap;




public:

// FIXME doh put this somwhere lol  - canned is a big junk bin 
typedef mjm_canned_methods Canned;
//int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
//int myatoi(const char * c) const { return Canned::myatoi(c); }



// just use this for now 
//typedef _dispatch_vars dispatch_vars;
typedef typename Super::_ctor_vars dispatch_vars;
typedef typename Super::_ctor_vars ctor_vars;
typedef typename Super::proc_io_type proc_io_type;
// for registration 
mjm_mailproc_toobib_handler(const StrTy & nm ) {Super::ptr::name(nm,&Myt::factory());    }
mjm_mailproc_toobib_handler(const StrTy & nm,const ctor_vars & cv ) 
{Super::ptr::name(nm,&Myt::factory(cv));    }
mjm_mailproc_toobib_handler() {Init(ctor_vars());}
mjm_mailproc_toobib_handler(const ctor_vars & cv ) {Init(cv);}
virtual ~mjm_mailproc_toobib_handler() {m_server.send("quit");sleep(2);  }
virtual Myt &  operator()() { return *this; } 
//  static, NOT virtual  need an instance of the derived class 
static  Super * factory() { return  new mjm_mailproc_toobib_handler(); } 
static  Super * factoryc(const ctor_vars & cv) 
{ return  new mjm_mailproc_toobib_handler(cv); } 
static Myt* make(const StrTy & ty, const ctor_vars & cv) 
{ return Make(ty,cv); } 
virtual const StrTy & desc() const { return m_desc; } 
StrTy handle_url(const StrTy & url, const StrTy & modifier, const IdxTy flags)
{return HandleUrl(url, modifier, flags); } 
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud, dispatch_vars & dv) {return Handle(pio,m,ud,dv); }  
virtual IdxTy handle(proc_io_type & pio,const MyMsg & m, Ud & ud, MsgResponder * pr,  dispatch_vars & dv) 
{return Handle(pio,m,ud,pr,dv); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:
static Myt* Make(const StrTy & ty, const ctor_vars & cv) 
{




}
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 


typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


///////////////////////////////////////////////////////
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr, dispatch_vars & dv)
{ return Handle(pio,m,ud,dv); }
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & _m, Ud& ud,dispatch_vars & dv)
{ 
const MyMsg * _pm=&_m;
MM_ERR(" in handler ....")
// how to respond with attach or inline 

// logging levels

// should have structured and verbatim log files
const StrTy & from=_m.from_address(0);
const StrTy text=_m.verbatim();
typename MailLogger::log_entry le; 
le.push_back(from);
m_logger.log(le );
// personalized ad content lol
// this works but the  charter mail  puts a FING apce at the
// F start  
m_logger.log(text );
Ragged r;
{Ss ss;
Ragged sfick;
IdxTy parts=_m.parts();
MM_ERR(MMPR2(_m.mime(),parts))
while (parts)
{
--parts;
_pm=&_m.part(parts);
const StrTy mime=(*_pm).mime();
MM_ERR(MMPR2((*_pm).mime(),parts))
MM_ERR(MMPR((*_pm).decoded_body()))
// want text/plain
int loc=mjm_strings::indexOf(mime.c_str(),"text/plain");
if (loc>=0) break;
} // parts
// read the url's and invoke toobib
// compose a mesage of bibtex responses . 
ss<<(*_pm).decoded_body();
r.load(ss,1);
// this may be html... 
IdxTy cnt=0;
for(IdxTy i=0; i<r.size(); ++i)
{
if (r[i].size()<1) continue;
if (r[i][0]=="toobib") { ++cnt; continue; }
if (r[i].size()<2) continue;
if (r[i][1]=="toobib")
{
Ragged::Line ficker;
for(IdxTy fick=1; fick<r[i].size(); ++fick) ficker.push_back(r[i][fick]); 
sfick.add(ficker);
 ++cnt;

} // STUPID F-ING MAIL  AT  CHARTER IS F 
} // i 
MM_ERR(MMPR(sfick.size()))
if (sfick.size()) r=sfick;
if (cnt==0)
{
MM_ERR(" no requests found try this as html ")
MM_ERR((*_pm).decoded_body()) 
const StrTy fndump=Super::m_temps.new_name("msg.html");
Blob turd;
turd=(*_pm).decoded_body();
turd.save(fndump);
Blob dest,err,data;
StrTy cmd="lynx -dump -force_html -width=\"10000\" "+fndump ;
MM_ERR(MMPR(cmd))
Super::m_hand.fileio(dest,err,data,cmd);
Ss qq;
qq<<StrTy(dest);
r=Ragged();
r.load(qq,1);
Super::m_temps.done_name(fndump);
} // cnt==0

}
//const MyMsg & m= *_pm;
const MyMsg & m= _m;

{Ss ss;
ss<<"here is stuff";
MM_ERR(ss.str())
MsgResponder * p = Super::m_presponder;
if (p!=0)
{

Ss rr; // response stream 
rr<<" Insert banners and content unknown text ads  "<<CRLF;
IdxTy fails=0;
IdxTy somes=0;
MyMsg mc=m; // const  
std::vector<StrTy> fns;
const char *  * attlist;
std::vector<StrTy> attlistfck;
const IdxTy sz=r.size();
attlist= new  const char * [sz+2];
IdxTy j=0;
for(IdxTy i=0; i<sz; ++i) 
{ const auto & l=r.line(i); 
if (l.size()<2) continue;
if ( l[0]!="toobib") continue; 
const StrTy & req=l[1];
if (req=="about")
{

Blob dest,err,data;
StrTy cmd="./mikemail.out -cmd \"about\" -quit ";
MM_ERR(MMPR(cmd))
Super::m_hand.fileio(dest,err,data,cmd);
rr<<StrTy(dest);
//./mikemail.out -cmd "about" -quit 
//toobib.out -cmd "about" -quit 2>/dev/null
cmd="toobib.out -cmd \"about\" -quit"; 
Super::m_hand.fileio(dest,err,data,cmd);
rr<<StrTy(dest);
le.clear();
le.push_back(from);
le.push_back("about cmd");
m_logger.log(le );
continue;
} 
//if (l.size()<3) continue;
const bool ficked_by_charter= (l.size()<3)&&((i+1)<sz);
bool enext=false;
if (ficked_by_charter) if (r[i+1].size()) enext=true;

 StrTy url ="";
if (l.size()>2) url=l[2];
else if (enext) url=r[i+1][0];
MM_ERR(" adding "<<l[0]<<" "<<l[1]<<" "<<url);
le.clear();
le.push_back(from);
le.push_back(url);
m_logger.log(le );
// personalized ad content lol
//const StrTy uflags="";
StrTy mod="";
//StrTy tooc=" -clip";
//if (l[1]=="all") tooc=" -all";
if (req=="all") mod="all";
// TODO FIXME this needs a try catch block for bad url or net activity . 
const StrTy dest=HandleUrl(url,mod,0);
fns.push_back(dest);
// TODO should count number of entries, parse and count and then log ...

BibEntryMap bem;
bem.parse(dest);
Ss sss;
sss<< bem.size();
if( bem.size()==0) ++fails; else ++somes;
le.push_back(sss.str());
m_logger.log(le );
} // i 

// assemble response, as body or attachments 
// a personalized header or ad
rr<<" Insert text ad here based on requests and results "<<CRLF;
rr<<CRLF;
rr<<" People who searced for these also searched for ... index log file "<<CRLF;

rr<<"  "<<CRLF;
// for attachments no assurance each file exists. 
Ss stotal;
MM_LOOP(ii,fns)
{
const StrTy & dest=(*ii);
Blob b;
const IdxTy sz=b.load(dest);
//if (sz) {attlist[j]=dest.c_str(); ++j; } 

// this works, the encoding is great but it puts "other crap"
// in the subject line lol. 
const bool attach_each=false; 
if ( attach_each) if (sz) {attlistfck.push_back(dest); } 

rr<<"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"<<CRLF;
rr<<StrTy(b);
stotal<< rr.str(); // StrTy(b);
}
const StrTy dest=Super::m_temps.new_name("summary.bib");
Blob b2;
b2=stotal.str();
b2.save(dest);
IdxTy b2sz=b2.load(dest);
fns.push_back(dest);
if (b2sz) {attlistfck.push_back(dest); } 

// this does not add anyway doh 
attlist[j]=0;
const StrTy sresp=rr.str();
Ss qq;
qq<<" Toobib results: some results for "<< somes <<" and "<<fails<<" appear to have failed ";
const StrTy ssubj=qq.str();
//p->reply(ss.str(),sresp,attlistfck,mc);
p->reply(sresp,ssubj,attlistfck,mc);
delete [] attlist;
Super::m_temps.done_names(fns,0);
m_logger.log(sresp);
} // p!=0
} // scoping ss
// just hand off to a script...
return 0; 

} // Handle 
IdxTy Unsafe(const StrTy & dest, const StrTy & url, const IdxTy flags)
{
IdxTy rc=0;
Ss ss;
Blob b;
StrTy s = mjm_strings::fancy_to_lower(url);
const char * p=s.c_str();
bool http=(strncmp(p,"http://",7)==0);
bool https=(strncmp(p,"https://",8)==0);
bool file=(strncmp(p,"file:///",8)==0);
int lh = mjm_strings::indexOf(p,"localhost");
int la = mjm_strings::indexOf(p,"192.168");
int lb = mjm_strings::indexOf(p,"127.0");
int dcom = mjm_strings::indexOf(p,".com");
int dedu = mjm_strings::indexOf(p,".edu");
int dorg = mjm_strings::indexOf(p,".org");
int dnet = mjm_strings::indexOf(p,".net");
if ((!http&&!https)||file )
{
ss<<" can not determine safe protocol "<<MMPR4(url,http,https,file)<<CRLF;
rc=1;
}
if ((lh+la+lb)!=(-3))
{
ss<<" host may not be safe  "<<MMPR4(url,lh,la,lb)<<CRLF;
rc|=2;
}
if (rc) { ss<<" ignoring request ";  b=ss.str(); b.save(dest); } 
return rc;
// TODO  good palce to throw ??? 
}
StrTy HandleUrl(const StrTy & url, const StrTy & modifier, const IdxTy flags)
{
// TODO check for safety... 

const StrTy dest=Super::m_temps.new_name("bib");
if (Unsafe(dest,url,flags)) return dest;
//IdxTy iflag=0;
//Ss ss;
//ss<<iflag;
//StrTy flags=ss.str();
StrTy cmd="guess "+url+" "+dest+" "+modifier;

MM_ERR(MMPR(cmd))
//Blob dest,err,data;
//const StrTy cmd="echo \""+url+"\" | myclip -paste ; toobib -clip";
// log time, start , done size, files , etc 
m_server.send(cmd);

// this needs to wait for the prompt to come back... doh
// this can take minutes right now due to problems... 
bool dun=false;
IdxTy iter=0;
StrTy resp="";
while (!dun){
sleep(1);
resp+=m_server.receive(0,0,0);
MM_ERR(MMPR(resp))
const IdxTy resplen=resp.length();
if (resplen>4)
{
const char * p=resp.c_str();
IdxTy x=strcmp("mjm>",p+resplen-4);
MM_ERR(MMPR((p+resplen-4)))
if (x==0) dun=true;
}
if ( iter>120) dun=true;
++iter;
} // while 

return dest;
} // HandleUrl

///////////////////////////////////////////////////////
#if 0 
virtual IdxTy HandleOld(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr, dispatch_vars & dv)
{ return Handle(pio,m,ud,dv); }
virtual IdxTy HandleOld(proc_io_type & pio, const MyMsg & m, Ud& ud,dispatch_vars & dv)
{ 
MM_ERR(" in handler ....")
//typedef typename DietForm::parse_state PS;
//typedef typename DietForm::parse_settings PO;
//PS ps;
//PO po(1<<PO::MARKUP);
//m_df.clear_form();
Ragged r;
{Ss ss;
// read the url's and invoke toobib
// compose a mesage of bibtex responses . 
ss<<m.decoded_body();
//Load(ss,r,1);
r.load(ss,1);
//m_df.load_form(ss);
}
//m_df.parse(ps,po);
//typedef std::stringstream Ss;
{Ss ss;
ss<<"here is stuff";
//m_df.save(ss,*(ps.markup));
MM_ERR(ss.str())
MsgResponder * p = Super::m_presponder;
if (p!=0)
{
Ss rr;
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
MyMsg mc=m; // const  
//p->reply(ss.str(),"",mc);
char ** attlist;
std::vector<StrTy> attlistfck;
const IdxTy sz=r.size();
attlist= new char *[sz+2];
IdxTy j=0;
for(IdxTy i=0; i<sz; ++i) 
{ const auto & l=r.line(i); if (l.size()<3) continue;
if ( l[0]!="toobib") continue; 
MM_ERR(" adding "<<l[0]);
//attlist[j]=(char*)l[0].c_str(); ++j;
// this is the old function
//attlistfck.push_back(l[0]);
// for each url, invoke toobib
// this partsing is fcked .. 
StrTy tooc=" -clip";
if (l[1]=="all") tooc=" -all";
const StrTy url =l[2];
Blob dest,err,data;
//const StrTy cmd="echo \""+url+"\" | myclip -paste ; toobib -clip";
const StrTy cmd="echo \""+url+"\" | myclip -paste ; toobib "+tooc; // -clip";
MM_ERR(MMPR(cmd))
Super::m_hand.fileio(dest,err,data,cmd);
//rr<<StrTy(dest);
//dest.load("aaaa");
dest.load("xxxx");
rr<<StrTy(dest);
}
// this does not add anyway doh 
attlist[j]=0;
const StrTy sresp=rr.str();
//p->reply(ss.str(),sresp,attlistfck,mc);
p->reply(sresp,StrTy(" other crap"),attlistfck,mc);
delete [] attlist;
} // p!=0
} // scoping ss

// just hand off to a script...
return 0; 

} // HandleOld 
#endif



///////////////////////////////////////////////////////


bool LoadInits(IdxTy & d,  const StrTy & key,const ctor_vars & cv ) const
{
StrTy x=cv.get(key);
if (x.c_str()[0]!=0)
{
d=Canned::myatoi(x.c_str());
return true;
} 
return false;
} // LoadInits
void Init(const ctor_vars & cv ) 
{
m_server.get_names(Super::m_temps,0);
m_log_flags=0;
m_response_flags=0;
m_logfile=cv.get("log-file");
m_blobfile=cv.get("blob-file");
m_mode=cv.get("mode");
const bool mode_loud=(m_mode=="loud");
LoadInits(m_log_flags,"log-flags",cv);
LoadInits(m_response_flags,"response-flags",cv);
m_logger.set_log_file(m_logfile);
m_logger.set_blob_file(m_blobfile);
if (mode_loud) m_cmd="toobib.out  ";
else m_cmd="toobib.out -cmd \"quiet\" ";
m_server.launch(m_cmd);

/*
StrTy x=cv.get("noun-file");
if (x.c_str()[0]!=0) m_df.load_nouns(x);
 x=cv.get("ignores-file");
if (x.c_str()[0]!=0) m_df.load_ignores(x);
 x=cv.get("reserves-file");
if (x.c_str()[0]!=0) m_df.load_reserveds(x);
*/

/*
if (cmd=="load") { x.load(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-form") { x.load_form(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-nouns") { x.load_nouns(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-ignores") { x.load_ignores(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-reserveds") { x.load_reserveds(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="dump") { MM_ERR(x.dump()) }

m_desc=cv.get("desc");
m_script=cv.get("script");
m_dump=myatoi(cv.get("dump"));
m_headers=myatoi(cv.get("sane"));
m_bfile=myatoi(cv.get("bfile"));
m_presponder=0;
*/
} // Init
virtual StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<Super::Dump(flags); 
//Ragged m_request;
//FifoServer m_server; 
ss<<MMPR4(m_desc, m_cmd, m_logfile,m_log_flags);
ss<<MMPR(m_response_flags);
//TempMan m_temps;
//ss<<MMPR2(m_script,m_desc)<<CRLF;
return ss.str(); }



void Load(Ragged & r,const StrTy & fn ,  const IdxTy flags)
{std::ifstream is(fn); Load(is,r,flags); }
void Load(IsTy & is , Ragged & r,  const IdxTy flags)
{
const bool csv=Bit(flags,1);
CommandInterpretter li(&is);
li.set_split(6,csv?',':' ');
//m_form.load(li,0);
r.load(li,0);

}

// MEMBERS
protected:
StrTy m_desc;
Ragged m_request;
StrTy m_cmd;
StrTy m_mode;
FifoServer m_server;
StrTy m_logfile,m_blobfile;
IdxTy m_log_flags,m_response_flags;
MailLogger m_logger;
//TempMan m_temps;
//DietForm m_df;
//Hand m_hand;
//StrTy m_script,m_bfile;
//IdxTy m_dump, m_headers;
//MsgResponder * m_presponder;

}; // mjm_mailproc_diet_handler



//////////////////////////////////////////////


////////////////////////////////////////////
#ifdef  TEST_MJM_MAILPROC_TOOBIB_HANDLER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
enum {BAD=~0};

// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_mailproc_toobib_handler <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MAILPROC_TOOBIB_HANDLER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
//typedef mjm_mailproc_handler<Tr>  Myt;
typedef mjm_mailproc_toobib_handler<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="url") { MM_ERR(x.handle_url(cip.p1,cip.p2,0)); }
//StrTy handle_url(const StrTy & url, const StrTy & modifier, const IdxTy flags)
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MAILPROC_HANDLER_H__ 
