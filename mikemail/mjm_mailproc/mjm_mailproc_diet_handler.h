#ifndef MJM_MAILPROC_DIET_HANDLER_H__
#define MJM_MAILPROC_DIET_HANDLER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_mailproc_handler.h"
#include "mjm_diet_diary_form.h"
#include "mjm_read_buffer.h"
/*
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "../mjm_generic_message.h"
#include "mjm_msg_responder.h"
#include "mjm_pawnoff.h"
// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"
*/


// Thu Jun 18 20:35:41 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_mailproc_handler   
// g++ -std=gnu++11 -DTEST_MJM_MAILPROC_HANDLER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_handler.h  -lpthread -lreadline

template <class Tr> class mjm_mailproc_diet_handler : public mjm_mailproc_handler<Tr>
{
 typedef mjm_mailproc_handler<Tr> Super;
 typedef mjm_mailproc_diet_handler<Tr> Myt;

protected:

 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_msg_responder<Tr> MsgResponder;
//typedef mjm_msg_rules<Tr>  MyRules;
//typedef mjm_msg_jrnl<Tr>  MyJrnl;
//typedef mjm_mailproc_handler<Tr> MyMailHand;
//typedef mjm_mailproc_handler_map<Tr> MyMailHandMap;
typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef  Ragged::Line Rline;
typedef std::regex Regex;

typedef mjm_read_buffer<Tr> RdBuff;
typedef mjm_indexed_read_buffer<Tr,char> IRdBuff;
typedef mjm_diet_diary_form<Tr> DietForm;

typedef mjm_global_mailusers<Tr> Users;
typedef typename Users::user_desc Ud;


typedef typename DietForm::parse_state PS;
typedef typename DietForm::parse_settings PO;

public:

// FIXME doh put this somwhere lol  - canned is a big junk bin 
typedef mjm_canned_methods Canned;
//int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
//int myatoi(const char * c) const { return Canned::myatoi(c); }


static int myatoi(const StrTy & s ) { return myatoi(s.c_str()); }
static int myatoi(const char * c) { return ::strtol(c,0,0); }


// just use this for now 
//typedef _dispatch_vars dispatch_vars;
typedef typename Super::_ctor_vars dispatch_vars;
typedef typename Super::_ctor_vars ctor_vars;
typedef typename Super::proc_io_type proc_io_type;
// for registration 
mjm_mailproc_diet_handler(const StrTy & nm ) {Super::ptr::name(nm,&Myt::factory());    }
mjm_mailproc_diet_handler(const StrTy & nm,const ctor_vars & cv ) 
{Super::ptr::name(nm,&Myt::factory(cv));    }
mjm_mailproc_diet_handler() {}
mjm_mailproc_diet_handler(const ctor_vars & cv ) {Init(cv);}
virtual ~mjm_mailproc_diet_handler() {}
virtual Myt &  operator()() { return *this; } 
//  static, NOT virtual  need an instance of the derived class 
static  Super * factory() { return  new mjm_mailproc_diet_handler(); } 
static  Super * factoryc(const ctor_vars & cv) 
{ return  new mjm_mailproc_diet_handler(cv); } 
static Myt* make(const StrTy & ty, const ctor_vars & cv) 
{ return Make(ty,cv); } 
virtual const StrTy & desc() const { return m_desc; } 
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud,dispatch_vars & dv) 
{return Handle(pio,m,ud,dv); }  
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud,MsgResponder * pr,  dispatch_vars & dv) 
{return Handle(pio,m,ud,pr,dv); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:
static Myt* Make(const StrTy & ty, const ctor_vars & cv) 
{




}
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 


typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr, dispatch_vars & dv)
{ return Handle(pio,m,ud,dv); }
// operations could include download, parse submission, append submission
// request template 
typedef std::map<StrTy,IdxTy> Hlutmap;
static const Hlutmap  &  Hlut() 
{
static Hlutmap m;
static bool init=false;
if (!init)
{
init=true;
m["template"]=0; // ==0) return HandleTemplate(m,dv,0);
m["update"]=1; // ==0) return HandleTemplate(m,dv,1);
m["submit"]=2; // ==0) return HandleMarkup(m,dv);
m["commit"]=3; // ==0) return HandleAppend(m,dv);
m["replace"]=4; // ==0) return HandleReplace(m,dv);
m["download"]=5; // )==0) return HandleDownload(m,dv,1);
m["view"]=6; // )==0) return HandleDownload(m,dv,1);
m["report"]=7; // ==0) return HandleReport(m,dv,1,sub,base+1);
m["upload"]=8; // ==0) return HandleReport(m,dv,1,sub,base+1);
} // init
return m;
} // Hlut
virtual IdxTy Handle(proc_io_type & pio,const MyMsg & m, Ud & ud, dispatch_vars & dv)
{ 
MM_ERR(" in handler ....")
// m_df.set_file - need to possibly load the document and
// later save it. 
const StrTy su= (m.hval_lc("Subject:"));
const StrTy fr= (m.hval_lc("From:"));
const StrTy & udir=dv.get("udir"); 
//RdBuff sub;
const char*  sup=su.c_str();
IRdBuff subi(sup,' ');

IdxTy zed=0;
//if (strncmp("Re:",sup,3)==0) zed+=3;
//while (sup[zed]==' ') ++zed;
//sub.split_and_mark(StrTy(sup+zed),' ');
//const IdxTy n=sub.strings();
const IdxTy n=subi.size();
if (n<2) return HandleNull(m,dv);
IdxTy base=0;
//(strcmp(sub[0],"Re:")==0)?1:0;
while ((subi[base][0]==0)||(strcmp(subi[base],"Re:")==0))
{
++base;
if (base>=n) return HandleNull(m,dv);
} 
// diet {template,submit,commit,download,report } [filename]
const char * cmd=subi[base];
//if (n>2) dv.add("_file",sub[2]); else dv.add("_file","default.txt");


// needs to make or use a constrained_file object
// maybe that takes a variety of filenames in one path
// saving streams etc. 
// first word should be diet
// second word is template,
auto ii=Hlut().find(cmd);

IdxTy sw= ~0;
if (ii!=Hlut().end()) sw=(*ii).second;
else 
{
 base=subi.first_of(Hlut());
if (base>=0) 
{
cmd=subi[base];
auto jj=Hlut().find(cmd);
if (jj!=Hlut().end()) sw=(*jj).second;
} // base
} // ii==end 
//if (n>(2+base)) dv.add("_file",sub[2+base]); else dv.add("_file","diet.txt");
dv.add("_file","diet.txt");
const auto fpos= subi["file"];
if (fpos.size())
{
const IdxTy pos=fpos[0];
if ((pos+1)<subi.size())  dv.add("_file",subi[pos+1]);

} // fpos.size()
IdxTy uflags=0;
 IdxTy ufpos=subi.first(StrTy("uflags"));
if (ufpos!=(~0)) 
{
++ufpos;
if (ufpos<n) uflags=myatoi(subi[ufpos]);

}

MM_ERR(MMPR4(subi.size(),sw,cmd,base)<<MMPR(uflags))
switch ( sw) 
{
case 0: {  return HandleTemplate(m,dv,0,uflags); } 
case 1: {  return HandleTemplate(m,dv,1,uflags); } 
// second word is submit,
case 2:{ return HandleMarkup(m,dv); } 
case 3 :{  return HandleAppend(m,dv,0); } 
 case 4 :{  return HandleReplace(m,dv); } 
  case 5  :{ return HandleDownload(m,dv,1); } 
  case 6 :{  return HandleDownload(m,dv,1); }
  case 7 :{ return HandleReport(m,dv,1,subi,base); }
case 8 :{  return HandleAppend(m,dv,1); }  // clear form 
default: MM_ERR(" bad resutl "<<MMPR2(cmd,sw))
} // switch 
//if (strcmp(cmd,"report")==0) return HandleReport(m,dv);


/*
if (strcmp(cmd,"template")==0) return HandleTemplate(m,dv,0);
if (strcmp(cmd,"update")==0) return HandleTemplate(m,dv,1);
// second word is submit,
if (strcmp(cmd,"submit")==0) return HandleMarkup(m,dv);
// second word is commit,
if (strcmp(cmd,"commit")==0) return HandleAppend(m,dv);
if (strcmp(cmd,"replace")==0) return HandleReplace(m,dv);
// second word is download,
if (strcmp(cmd,"download")==0) return HandleDownload(m,dv,1);
if (strcmp(cmd,"view")==0) return HandleDownload(m,dv,1);
if (strcmp(cmd,"report")==0) return HandleReport(m,dv,1,sub,base+1);
//if (strcmp(cmd,"report")==0) return HandleReport(m,dv);
*/

//if (n<2) 
return HandleNull(m,dv);

} // Handle 
 IdxTy HandleNull(const MyMsg & m, dispatch_vars & dv) { 
MsgResponder * p = Super::m_presponder;
if (p!=0)
{
const StrTy su= (m.hval_lc("Subject:"));
Ss ss;
ss<<" the message you sent appears to want action on a diet docuenet"<<CRLF;
ss<<" but no action could be determined from "<<CRLF;
ss<<su<<CRLF;
ss<<" ignored message is :"<<CRLF;
ss<<m.decoded_body();
ss<<CRLF;
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
MyMsg mc=m; // const  
p->reply(ss.str(),"",mc);

} // p!=0

return 0; }  // HandleNull

 IdxTy HandleTemplate(const MyMsg & m, dispatch_vars & dv,const IdxTy flags,const IdxTy uflags) { 
MM_ERR("HandTemplate")
ReloadForm(m_df,dv);
//m_df.clear_form();
Ss ss ; // = new Ss;
if (true) { 
PS ps; PO po(1<<PO::BLANK);
m_df.blank(ps,po);
Ragged * blank=ps.blank;
// this dies when ps goes out of scope 
m_df.save(ss,*blank);

}
else
{
// if there is a markup it will  use it for the template
Ragged * blank=m_df.blank(flags);
m_df.save(ss,*blank);
delete blank;
}
// this does a markup... 
//Ragged * blank=m_df.blank(flags);
// this should be destroyed when ps goes out of scope. 
//Ragged * blank=ps.blank;
//MM_ERR(" try to save "<< MMPR(blank))
//m_df.save("foodoo",*blank);
//MM_ERR(" try to reply ")
//const IdxTy rc= SendAttachedFile(m, StrTy(""), StrTy("find report") ,StrTy("foodoo") );
const IdxTy rc= SendReply(m,ss.str());
//delete ss;
return rc; }  // HandleTemplate

 IdxTy HandleReplace(const MyMsg & m, dispatch_vars & dv) { 
MM_ERR("HandleReplace")
ReloadForm(m_df,dv);
{Ss ss;
ss<<m.decoded_body();
m_df.replace_date(ss.str(),0); 
}
m_df.save_form();
return 0; 
} // HandleReplace


 IdxTy HandleAppend(const MyMsg & m, dispatch_vars & dv,const IdxTy flags) { 
MM_ERR("HandleAppend")
const bool replace=Bit(flags,0);
const bool attached=replace; // true; // Bit(flags,1);
// when replacing don't reload or clear
ReloadForm(m_df,dv,(replace?1:0));
// upload
if ( replace ) m_df.clear_form();


/*
const StrTy & udir=dv.get("udir"); 
m_df.mkpath(udir);
const StrTy ubase=dv.get("_file");
const StrTy ufile=udir+StrTy("/")+ubase;
m_df.set_file(ufile);
m_df.clear_form();
m_df.load_form();
*/
bool use_body=true;
const IdxTy sz=m.parts();
MM_ERR(MMPR(m.parts()))
if (attached&&(sz>1))
{
use_body=false;
for(IdxTy k=0; k<sz; ++k)
{
MM_ERR(MMPR2(k,m.part(k).name()))
}
const MyMsg & ma=m.part(1);
//MM_ERR("original keys "<< MMPR(m.dump_keys()))
//MM_ERR("original  "<< MMPR(m.verbatim()))
MM_ERR(MMPR(ma.dump_keys()))
Ss ss;
ss<<ma.decoded_body();
m_df.load_form(ss);
} // attached

if (use_body)
{
Ss ss;
ss<<m.decoded_body();
m_df.load_form(ss);
}
m_df.save_form();

return 0; }  // HandleAppend
 IdxTy HandleDownload(const MyMsg & m, dispatch_vars & dv, const IdxTy flags) { 
const bool attach=Bit(flags,0);
ReloadForm(m_df,dv,1); // really does not need to load the form 
if (attach) { 
return SendAttachedFile
(m,"the file you requested", " your request is atached", m_df.full());
}
Ss ss; 
std::ifstream is(m_df.full());
ss<<is.rdbuf();
return SendReply(m,ss.str());


#if 0
MsgResponder * p = Super::m_presponder;
if (p!=0)
{
Ss ss;
ss<<" the file you requested "<<CRLF;
typename MsgResponder::attach_list al;
al.push_back(m_df.full());
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
MyMsg mc=m; // const  
p->reply(ss.str(),"your requested file is attached ",al,mc);

} // p!=0
#endif

return 0; 
}  // HandleDownload
typedef typename MsgResponder::attach_list AttList;
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
IdxTy SendAttachedFile(const MyMsg& m, const StrTy & subj, const StrTy & body,const StrTy & fn)
{ 
//typename MsgResponder::attach_list al;
AttList al;
al.push_back(fn);
return SendAttachedFiles(m,subj,body,al); 
} // SendAttachedFile

IdxTy SendAttachedFiles(const MyMsg& m, const StrTy & subj, const StrTy & body,const AttList & al)
{ 
//typename MsgResponder::attach_list al;
MsgResponder * p = Super::m_presponder;
if (p!=0)  {
 Ss ss; ss<<body<<CRLF; 
MyMsg mc=m; // const  
p->reply(ss.str(),subj.c_str(),al,mc);
} // p!=0

return 0; 
} // SendAttachedFile 

IdxTy SendReply(const MyMsg & m, const StrTy & s)
{
MsgResponder * p = Super::m_presponder;
if (p!=0) { MyMsg mc=m;   p->reply(s,"",mc); } // p!=0
return 0; 
} // SendReply
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
//////////////////////////////////////////////////////////////
 
IdxTy HandleReport(const MyMsg & m, dispatch_vars & dv,const IdxTy xflags, IRdBuff & rd, const IdxTy pos)
{
//typedef typename DietForm::parse_state PS;
//typedef typename DietForm::parse_settings PO;
const int n=rd.size(); // trings();
int df=int(pos);
StrTy cmd="eval-week";
++df; if (df<n) cmd=StrTy(rd[df]);
IdxTy flags=0; // atoi(cmdp1.c_str());
++df; if (df<n) flags=atoi(rd[df]);
IdxTy flagout=0; // atoi(cmdp2.c_str());
++df; if (df<n) flagout=atoi(rd[df]);
StrTy daily="dog_daily.txt";
StrTy glob="dog_glob.txt";
StrTy usedd="dog_used.txt";
const bool dump_dmglob=Bit(flagout,0);
const bool dump_rest=Bit(flagout,1);
const bool save_dmglob=Bit(flagout,2);
const bool save_daily=Bit(flagout,3);
const bool save_used=Bit(flagout,4);
StrTy startdate="2000-01-01";
StrTy enddate="9000-01-01";
MM_ERR(MMPR(dv.dump()))
ReloadForm(m_df,dv);
#if 0
IdxTy idx=3;
if (save_dmglob)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") glob=cip.wif(idx); ++idx;  }
if (save_daily)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") daily=cip.wif(idx); ++idx;  }
if (save_used)
{ if (cip.wif(idx)!="") if (cip.wif(idx)!="-") usedd=cip.wif(idx); ++idx;  }
#endif
const bool week=(cmd=="eval-week");
Ss ss;
for(IdxTy jj=0; jj<n; ++jj ) ss<<MMPR2(jj,rd[jj])<<CRLF;
ss<<MMPR(cmd)<< MMPR4(flags,flagout,daily,glob)<<MMPR4(usedd,dump_dmglob,dump_rest, save_dmglob)<<MMPR2(save_daily,save_used);
ss<<CRLF;

MM_ERR(
MMPR4(flags,flagout,daily,glob)<<MMPR4(usedd,dump_dmglob,dump_rest, save_dmglob)<<MMPR2(save_daily,save_used))
//MM_FAULT
PO po(1<<PO::EVAL);
PS ps; ps.debug_os=&std::cerr;
if (!week)
{
po.date_range(startdate,enddate);
MM_ERR(MMPR2(startdate,enddate))
m_df.parse(ps,po);
}else m_df.parse_week(ps,po);
typedef std::stringstream Ss;
if (dump_dmglob) {
Ss ss; ss<<ps.dmglob->dump();
//x.save(ss,*(ps.blank));
MM_ERR("%%%%% dump of dmglob ") MM_ERR(ss.str())
} // dump_dmglob
std::vector<StrTy> no;

typedef mjm_ragged_table Ragged;
Ragged d,used;
// void dog_daily(Ragged & d, Ragged * used,noun_order &no, const IdxTy flags)
ps.dmglob->dog_daily(d, & used, no,flags);
if (dump_rest) {
Ss rr;
rr<<"%%%%% dump of d or daily dog report "<<CRLF ;
d.dump_os(rr,3);
rr<<"%%%%% dump of used or inventory report  "<<CRLF ;
used.dump_os(rr,3);
MM_ERR(rr.str())
 } // dump_rest
IdxTy rc=0;

const bool attach=true;
if (!attach) { 
if (save_dmglob) { ss<<(*(ps.dmglob)).dump(); }
if (save_daily) { d.dump_os(ss,3); }
if (save_used) { used.dump_os(ss,3); }
rc= SendReply(m,  ss.str());
}
else
{
AttList al;
const StrTy body=" generated reports attached";
const StrTy subj=" requested generated reports attached";

const StrTy dir="/tmp/";
const StrTy ts=Super::m_hand.now();
const StrTy fnglob=dir+"dmglob"+ts+".txt";
const StrTy fndaily=dir+"daily"+ts+".txt";
const StrTy fnused=dir+"used"+ts+".txt";
if (save_dmglob) 
{al.push_back(fnglob); std::ofstream f(fnglob);  f<<(*(ps.dmglob)).dump(); }
if (save_daily) {al.push_back(fndaily); std::ofstream f(fndaily);  d.dump_os(f,3); }
if (save_used) {al.push_back(fnused); std::ofstream f(fnused);  used.dump_os(f,3); }
//SendAttachedFiles(const MyMsg& m, const StrTy & subj, const StrTy & body,const AttList & al)

 rc=SendAttachedFiles( m, subj,  body,al);
}


/*
PS ps;
PO po(1<<PO::MARKUP);
m_df.clear_form();
{Ss ss;
ss<<m.decoded_body();
m_df.load_form(ss);
}
m_df.parse(ps,po);
//typedef std::stringstream Ss;
{Ss ss;
m_df.save(ss,*(ps.markup));
MM_ERR(ss.str())
MsgResponder * p = Super::m_presponder;
if (p!=0)
{
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
MyMsg mc=m; // const  
p->reply(ss.str(),"",mc);

} // p!=0

} // scoping ss
*/


return rc; 
} // HandleReport 


//////////////////////////////////////////////////////////////// 
IdxTy HandleMarkup(const MyMsg & m, dispatch_vars & dv)
{

//typedef typename DietForm::parse_state PS;
//typedef typename DietForm::parse_settings PO;
PS ps;
PO po(1<<PO::MARKUP);
m_df.clear_form();
{Ss ss;
ss<<m.decoded_body();
m_df.load_form(ss);
}
m_df.parse(ps,po);
//typedef std::stringstream Ss;
{Ss ss;
m_df.save(ss,*(ps.markup));
MM_ERR(ss.str())
MsgResponder * p = Super::m_presponder;
if (p!=0)
{
// IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
MyMsg mc=m; // const  
p->reply(ss.str(),"",mc);

} // p!=0

} // scoping ss
/*
if (cmd=="parse")
{PO po; Myt::parse_state ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}

if (cmd=="blank")
{PO po(1<<PO::BLANK); Myt::parse_state ps; ps.debug_os=&std::cerr;  x.parse(ps,po);}
if (cmd=="markup")
{PO po(1<<PO::MARKUP); Myt::parse_state ps; ps.debug_os=&std::cerr;
x.parse(ps,po);
typedef std::stringstream Ss;
Ss ss;
x.save(ss,*(ps.markup));
MM_ERR(ss.str())
}


*/



// just hand off to a script...
#if 0 
// IdxTy get_output_with_input(Blob & dest, const Blob & data, const StrTy & cmd)
// may modify 
StrTy cmd=m_script;
if (cmd.length()==0)
{

//MM_ERR(" handler "<<MMPR(m_desc))
MM_ERR(" handler no script  ")
return 0; 
}
bool do_dump=Do(m_dump,"dump",dv);
bool do_sane=Do(m_headers,"sane",dv);
Blob dest,data;
if (do_sane)
{
Ss ss;
ss<<m.sane_headers();
ss<<CRLF;
bool do_body=Do(m_headers,"sane",dv,2);
if (do_body ) { ss<<m.body(); } 
data=ss.str();
bool do_b64=Do(m_headers,"sane",dv,4);
Blob zip;
// the body is a zip file even if content-type is text, my format... 
zip=m_hand.base64(m.body());
zip.save(m_bfile);
}
else data=m.verbatim();
IdxTy rc=m_hand.get_output_with_input(dest,data,cmd);
if (do_dump) { MM_ERR(StrTy(dest)) } 
#endif
return 0; 

} 
/*
bool Do(const IdxTy x, const StrTy & n, dispatch_vars & dv, const IdxTy b=0)
{

IdxTy do_=Bit(x,b);
if (Bit(x,b+1)) {
IdxTy _do=myatoi(dv.get(n));
do_=Bit(_do,b);
}
MM_ERR( MMPR4(n,x,b,dv.get(n))<<MMPR(do_))
return do_;
} */

IdxTy ReloadForm(DietForm & df, dispatch_vars & dv,const IdxTy flags=0) { 
//MM_ERR("HandleAppend")
const bool fn_only=Bit(flags,0);
const StrTy & udir=dv.get("udir"); 
if (!fn_only) df.mkpath(udir);
const StrTy ubase=dv.get("_file");
const StrTy ufile=udir+StrTy("/")+ubase;
df.set_file(ufile);
MM_ERR(" should be reloading from "<<MMPR(ufile))
if (!fn_only){ df.clear_form(); df.load_form(); } 
return 0;
} // ReloadForm

bool U(const StrTy & x) { return (x.c_str()[0]!=0); }
void Init(const ctor_vars & cv ) 
{
m_default_fn="diet.txt";
StrTy x=cv.get("noun-file");
if (U(x)) m_df.load_nouns(x);
 x=cv.get("ignores-file");
if (U(x)) m_df.load_ignores(x);
 x=cv.get("units-file");
if (U(x)) m_df.load_units(x);
 x=cv.get("reserves-file");
if (U(x)) m_df.load_reserveds(x);
 x=cv.get("dir");
if (U(x)) m_df.set_root(x);
 x=cv.get("file");
if (U(x)) m_df.set_file(x);
 x=cv.get("default-file");
if (U(x)) m_default_fn=(x);

/*
if (cmd=="load") { x.load(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-form") { x.load_form(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-nouns") { x.load_nouns(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-ignores") { x.load_ignores(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="load-reserveds") { x.load_reserveds(cip.p1);  MM_ERR("loading "<<MMPR(x.size()))  }
if (cmd=="dump") { MM_ERR(x.dump()) }

m_desc=cv.get("desc");
m_script=cv.get("script");
m_dump=myatoi(cv.get("dump"));
m_headers=myatoi(cv.get("sane"));
m_bfile=myatoi(cv.get("bfile"));
m_presponder=0;
*/
} // Init
virtual StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<Super::Dump(flags); 
//ss<<MMPR2(m_script,m_desc)<<CRLF;
return ss.str(); }

// MEMBERS
protected:
StrTy m_desc;
DietForm m_df;
StrTy m_default_fn;
//Hand m_hand;
//StrTy m_script,m_bfile;
//IdxTy m_dump, m_headers;
//MsgResponder * m_presponder;

}; // mjm_mailproc_diet_handler



//////////////////////////////////////////////
#if 0 
template <class Tr>
class mjm_mailproc_handler_map : public std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr > >  
{
 typedef mjm_mailproc_handler_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_mailproc_handler_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_mailproc_handler_map
#endif




////////////////////////////////////////////
#ifdef  TEST_MJM_MAILPROC_HANDLER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_mailproc_handler <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MAILPROC_HANDLER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_mailproc_handler<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MAILPROC_HANDLER_H__ 
