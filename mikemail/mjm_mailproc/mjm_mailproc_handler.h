#ifndef MJM_MAILPROC_HANDLER_H__
#define MJM_MAILPROC_HANDLER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include <sys/stat.h>
#include <unistd.h>
#include <string>
#include <fstream>
#include <fcntl.h>




#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "../mjm_generic_message.h"
#include "../mjm_global_mailusers.h"
#include "mjm_msg_responder.h"
#include "mjm_pawnoff.h"
// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"

#include "mjm_global_mailusers.h"
#include "mjm_temp_man.h"

// Thu Jun 18 20:35:41 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_mailproc_handler   

//g++ -std=gnu++11 -DTEST_MJM_MAILPROC_HANDLER -I. -I.. -I../../../mjm/hlib -I../../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_handler.h  -lpthread -lreadline


// g++ -std=gnu++11 -DTEST_MJM_MAILPROC_HANDLER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_handler.h  -lpthread -lreadline

template <class Tr> class mjm_mailproc_handler 
{
 typedef mjm_mailproc_handler Myt;

protected:

 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_msg_responder<Tr> MsgResponder;
typedef typename MsgResponder::attach_list Att;
typedef mjm_global_mailusers<Tr> Users;
typedef typename Users::user_desc Ud;
//typedef mjm_msg_rules<Tr>  MyRules;
//typedef mjm_msg_jrnl<Tr>  MyJrnl;
//typedef mjm_mailproc_handler<Tr> MyMailHand;
//typedef mjm_mailproc_handler_map<Tr> MyMailHandMap;
typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef  Ragged::Line Rline;
typedef std::regex Regex;
//typedef mjm_global_mailusers<Tr> UserList;
//typedef typename UserList::user_desc Ud;

typedef mjm_temp_man<Tr> Temps;

public:

// FIXME doh put this somwhere lol  - canned is a big junk bin 
typedef mjm_canned_methods Canned;
int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
int myatoi(const char * c) const { return Canned::myatoi(c); }


class _ctor_vars
{
typedef _ctor_vars Myt;
public:
_ctor_vars() { m_kv[""]=""; }

_ctor_vars(const Rline & line,const IdxTy st)
{
m_kv[""]="";
const IdxTy sz=line.size();
IdxTy i=st;
while (i<sz)
{
const StrTy & k=line[i];
++i;
if (i>=sz) break;
const StrTy & v=line[i];
m_kv[k]=v;
++i;
} // i 

} // ctor
bool has(const StrTy & k) const
{
return m_kv.find(k)!=m_kv.end();

}
// not const will include a blank if not there 
const StrTy & get(const StrTy & k) const
{ 

auto ii=m_kv.find(k);
if (ii==m_kv.end()) ii=m_kv.find("");
return (*ii).second;
//return m_kv[k]; 


} // get

Myt& operator+=(const Myt& that )
{ MM_LOOP(ii,that.m_kv) { m_kv[(*ii).first]=(*ii).second; } return *this; }
Myt& add(const StrTy & k, const StrTy & v) { m_kv[k]=v; return *this;  }  

StrTy dump ( const IdxTy flags=0 )const
{
Ss ss; MM_LOOP(ii,m_kv) { ss<<(*ii).first<<" "<<(*ii).second<<CRLF; } 
return ss.str();
}

std::map<StrTy, StrTy> m_kv;

}; // _ctor_vars


class _dispatch_vars
{


}; // _dispatch_vars



class  ptr{
typedef Myt * (*Fp)( ); 
typedef Myt * (*Fpx)(const _ctor_vars & ); 
public:
ptr() : m_ptr(0) {}
ptr(Myt * p) : m_ptr(p) {}
 ~ptr() { 
//delete m_ptr;

 } 
Myt* operator*() { return m_ptr; } 
Myt &  operator()() { return *m_ptr; } 
static Myt* factory(const StrTy & x ) {
auto ii=mmap().find(x);
if ( ii==mmap().end()) return (Myt*)0; 
 return (*(*ii))(); } 
static Myt* factory(const StrTy & x, const _ctor_vars & cv ) {
auto ii=mmapx().find(x);
if ( ii==mmapx().end()) return (Myt*)0; 
 return (*(*ii).second)(cv); } 

static void name(const StrTy & nm, Fp fp) { mmap()[nm]=fp; } 
static void name(const StrTy & nm, Fpx fp) { mmapx()[nm]=fp; } 
private:
typedef  std::map<StrTy, Fp > M;
typedef  std::map<StrTy, Fpx > Mx;
static  M &  mmap() { static M  m; return m; }
static  Mx &  mmapx() { static Mx  m; return m; }


Myt* m_ptr;

}; // ptr



class ptr_vector : public std::vector<Myt* >
{
//typedef  ptr_vector  Myt;
typedef  std::vector<Myt*> Super;

public:
ptr_vector(const IdxTy n ) : Super(n) {}
ptr_vector( ) : Super() {}
~ptr_vector()
{
MM_LOOP(ii,(*this)) { 
//MM_ERR(MMPR2(((long int)((*ii))),(*ii)->desc()))
delete  (*ii); } 
//MM_ERR(" fcking dtor fck ")
//delete (Super*)(this);
}

}; // ptr_vector
typedef ptr_vector vector;
// should be privtae upper case initials or something 
// in all cases, a "server' error could occur getting
// credentials or something wrong with message etc
// "server" is any external data. 
// download(success,server) , sort(user, new user, blocked,server  ) , dispatch(process, fail( syntax,parameters, server, malicious )),process(fail to start, fail partial, fail to reply or confirm, ), update message[ read flag, folder ]( success, missing folder, server )

class message_processing_progress
{

public:

}; // message_processing_progress

typedef std::map<StrTy, StrTy> proc_io_type;

// just use this for now 
//typedef _dispatch_vars dispatch_vars;
typedef _ctor_vars dispatch_vars;
typedef _ctor_vars ctor_vars;
typedef Ud user_description_type;
// for registration 
mjm_mailproc_handler(const StrTy & nm ) {ptr::name(nm,&Myt::factory());    }
mjm_mailproc_handler(const StrTy & nm,const ctor_vars & cv ) 
{ptr::name(nm,&Myt::factory(cv));    }
mjm_mailproc_handler() {}
mjm_mailproc_handler(const ctor_vars & cv ) {Init(cv);}
virtual ~mjm_mailproc_handler() {}
virtual Myt &  operator()() { return *this; } 
//  static, NOT virtual  need an instance of the derived class 
static  Myt * factory() { return  new mjm_mailproc_handler(); } 
static  Myt * factoryc(const ctor_vars & cv) 
{ return  new mjm_mailproc_handler(cv); } 
static Myt* make(const StrTy & ty, const ctor_vars & cv) 
{ return Make(ty,cv); } 
//typedef mjm_msg_responder<Tr> MsgResponder;
virtual void responder(MsgResponder * p ) { m_presponder=p; } 
virtual const StrTy & desc() const { return m_desc; } 
const StrTy & name() const { return m_name; } 
void name(const StrTy & x )  {  m_name=x; } 
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud,dispatch_vars & dv) {return Handle(pio,m,ud,dv); }  
//virtual IdxTy handle(const MyMsg & m, MsgResponder * pr,  dispatch_vars & dv) 
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr,  dispatch_vars & dv) 
{return Handle(pio,m,ud,pr,dv); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:

IdxTy SendAttachedFile(const MyMsg& m, const StrTy & subj, const StrTy & body,const StrTy & fn)
{ typename MsgResponder::attach_list al;
MsgResponder * p = m_presponder;
if (p!=0) { Ss ss; ss<<body<<CRLF; al.push_back(fn);
MyMsg mc=m; // const  
p->reply(ss.str(),subj.c_str(),al,mc);
} // p!=0 
return 0;
} // SendAttachedFile 
IdxTy SendReply(const MyMsg & m, const StrTy & s)
{
MsgResponder * p = m_presponder;
if (p!=0) { MyMsg mc=m;   p->reply(s,"",mc); } // p!=0
return 0;
} // SendReply

//  this is typedefed abouve FCK 
//typedef typename MsgResponder::attach_list Att;

IdxTy SendAdmin(const StrTy & text, const StrTy & subj, const Att & a,const MyMsg &  msg )
{
MsgResponder * p = m_presponder;
if (!p) return 0; 
return  p->send_admin( text,  subj, a, msg ); 

}




static Myt* Make(const StrTy & ty, const ctor_vars & cv) 
{




}
/// likely common needs here 
// https://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exist-using-standard-c-c11-c
bool Exists(const StrTy & name)
{
 struct stat buffer;   
  return (stat64(name.c_str(), &buffer) == 0);
}

bool Mkdir(const StrTy & dir)
{
if (Exists(dir)) return true;
IdxTy e=mkdir(dir.c_str(), S_IRUSR | S_IWUSR | S_IXUSR);
if (Exists(dir)) return true;
return (e==0);
}




bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 


typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud & ud,dispatch_vars & dv)
//{ return Handle(m,ud,dv); }
{ return Handle(pio,m,ud,0,dv); }
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr, dispatch_vars & dv)
{ 
// just hand off to a script...

// IdxTy get_output_with_input(Blob & dest, const Blob & data, const StrTy & cmd)
// may modify 
// wth sets this in mikemail??? 
// use bit 6 of m_headers and if bit 7 is set, override with value for sane
// in dv if it exists 
bool do_compat=Do(m_headers,"sane",dv,6);
StrTy cmd=m_script;
if (!do_compat) if (cmd.length()==0)
{

//MM_ERR(" handler "<<MMPR(m_desc))
MM_ERR(" handler no script  ")
return 0; 
}
bool do_dump=Do(m_dump,"dump",dv);
bool do_sane=Do(m_headers,"sane",dv);
//MM_ERR(MMPR3(do_compat,do_dump,do_sane))
Blob dest,data;
if (do_sane)
{
Ss ss;
ss<<m.sane_headers();
ss<<CRLF;
bool do_body=Do(m_headers,"sane",dv,2);
if (do_body ) { ss<<m.body(); } 
data=ss.str();
bool do_b64=Do(m_headers,"sane",dv,4);
Blob zip;
// the body is a zip file even if content-type is text, my format... 
zip=m_hand.base64(m.body());
// void base64( char ** result, IdxTy * len, const StrTy & d)
char * b;
IdxTy len;
m_hand.base64(&b,&len,m.body());
zip.adopt(b,len,len);
MM_ERR(" saving zip fil e"<<MMPR2(m_bfile,(zip.size())))
zip.save(m_bfile);
}
else data=m.verbatim();
// mjm 2023-07-22 fixing warning 
IdxTy rc=0;

if (do_compat)
rc=DefaultUnpack(m,ud,dv,pr);
else rc=m_hand.get_output_with_input(dest,data,cmd);

// mjm 2023-07-22 fixing warning  use var in dummy code 
if (false) MM_ERR(MMPR(rc)) 
if (do_dump) { MM_ERR(StrTy(dest)) } 
return 0; 

} 
// by default, want to unzip password protected body, verify a signature
// on each file, and if sucessful execute 
// script.txt which may need a chmod... 
// requres password and public keys for user. 
IdxTy DefaultUnpack(const MyMsg & m, Ud & ud,dispatch_vars & dv, MsgResponder * pr)
{ 
IdxTy rc=0;
MM_ERR(" in unpack ")
const StrTy dir="uz/";
const StrTy tcmd="unzip -t ";
const StrTy & _script=dv.get("script");
const StrTy & pw=dv.get("password");
const bool have_pw=(pw.length()!=0);
StrTy ucmd="unzip -d "+dir+" -B ";
if (have_pw) ucmd=ucmd+StrTy(" -P \"")+pw+"\"";
StrTy lcmd="unzip -d "+dir+" -l ";
if (have_pw) lcmd=lcmd+StrTy(" -P \"")+pw+"\"";


//rc=m_hand.get_output_with_input(dest,data,ucmd+m_bfile);
//rc=m_hand.fileio(dest,err,data,tcmd+m_bfile);
rc=TryOrDie(tcmd+m_bfile,m);
MM_ERR(MMPR(rc))
if(rc) return rc; 
rc=TryOrDie(ucmd+m_bfile,m);
MM_ERR(MMPR(rc))
if(rc) return rc; 
Blob dest,data,err;
rc=m_hand.fileio(dest,err,data,lcmd+m_bfile);
//MM_ERR(MMPR3(rc,StrTy(err),StrTy(dest)))
Ragged r;
Ss ss;
ss.str((StrTy(dest)));
//MM_ERR(MMPR3(rc,StrTy(err),ss.str()))
r.splitter(6);
r.load(ss,false);
std::map<StrTy,IdxTy> files;
bool on=false;
//MM_ERR(MMPR(r.size()))
for(IdxTy i=0; i<r.size(); ++i)
{
const Ragged::Line & l=r[i];
const IdxTy sz=l.size();
if (sz==0) continue;
//MM_ERR(MMPR2(i,l.size()))
if (l[0].c_str()[0]=='-') { on=!on; continue; }
if (!on) continue;
if (sz<4) {  
if (on) MM_ERR(" prolbem parsing zip contents "<<MMPR(ss.str())) ;
continue; } 
files[l[3]]=i;
} // i 
MM_LOOP(ii,files) {MM_ERR("remote zip file "<< MMPR2((*ii).first,(*ii).second))}
// see mail_cmd
// unzip password protected file decoded from body
//unzip -d uz -B -P 
// verify signatures on each file
//f="$REPLY"
//s="$f.sig"
//gpg --verify "$s" "$f" 2>&1 > "$TEMP1"
bool pass=true;
MM_LOOP(ii,files) 
{
MM_ERR("sig check "<<MMPR2((*ii).first,(*ii).second))
const StrTy f1=(*ii).first;
const StrTy f2=f1+".sig";
++ii;
if (ii==files.end()) { pass=false;  break; } 
const StrTy f3=(*ii).first;
if (f2!=f3) { pass=false; MM_ERR(" no sig "<<MMPR3(f1,f2,f3)) break; }
const StrTy cmd= "gpg --verify "+dir+f2+" "+dir+f1; // $s" "$f" 2>&1 > "$TEMP1"
//Blob dest,data,err;
//rc=m_hand.fileio(dest,err,data,cmd;
rc=TryOrDie(cmd,m);
//MM_ERR(MMPR3(rc,StrTy(err),StrTy(dest)))
if (rc) { pass=false; break; }
} // ii 
// fail silently, if valid user can dig into log file... 
// these could be weeded out earlier but trudge on for now 
const bool zip_passes= (pass&&(rc==0)&&(files.size()!=0) );
if (!zip_passes)
{
MM_ERR(" zip fails "<<MMPR3(pass,rc,files.size()))
}
//if (pass&&(rc==0)&&(files.size()!=0) )
if (!zip_passes ) return rc;
{ //scoping
//marchywka@happy:/home/documents/cpp/proj/mikemail/mjm_mailproc/junk$ chmod +111 uz/script.txt
const StrTy script=(_script.length())?_script:StrTy("script.txt");
if (files.find(script)==files.end())
{
// don't execute a stale one. 
MM_ERR(" no script file found in ziup "<<MMPR2(script,_script))
MM_LOOP(ii,files) { MM_ERR(MMPR2((*ii).first,(*ii).second)) } 
rc=~0;
return rc;
}
StrTy cmd=dir+script;
const StrTy cmds="chmod +111 "+cmd;
rc=TryOrDie(cmds,m);
if (rc) return rc;
MM_ERR(" chmod apparently worked now run")
// wtf double execute??? 
//rc=TryOrDie(cmd,m);
Blob dest,data,err;
// wrap the script in stuff to known cd and get input etc
// modified fileio in mjm_pawnoff to not use pipe but redirect
// escept the dir is relative so the script needs to be
// fixed AGAIN 
cmd=StrTy("cd ")+dir+StrTy(" ; ./")+script;
// this executes the script 
rc=m_hand.fileio(dest,err,data,cmd);
MM_ERR(MMPR3(rc,StrTy(err),StrTy(dest)))
MM_ERR(" execution done output above... ")
// only if we got this far reply. 
const IdxTy rcr=SendReply(m,StrTy(err)+StrTy(dest));
rc=rcr;


} //scoping
// execute script.txt if successful -done above 

// acknowledge result to sender only if it was ok  
// -- too late here doh 


return rc; 
} // DefaultUnpack 
IdxTy TryOrDie(const StrTy & s, const MyMsg & msg)
{
Blob dest,data,err;
IdxTy rc=m_hand.fileio(dest,err,data,s);
if (rc!=0)
{
StrTy text="";
Att a;
MM_ERR(MMPR2(StrTy(data),s)<<MMPR4(rc,err.size(),dest.size(),StrTy(dest)))
MM_ERR(MMPR2(rc,StrTy(err)))
const StrTy f= (msg.hval_lc("From:"));
const StrTy rt= (msg.hval_lc("ReplyTo:"));
const StrTy su= (msg.hval_lc("Subject:"));
const StrTy dx=msg.from_address(0);
const StrTy subj="failed script from  "+dx;
Ss ss;
ss<<" SHT";
ss<<MMPR4(f,rt,su,dx)<<CRLF;
ss<<MMPR2(StrTy(data),s)<<CRLF;
ss<<MMPR2(StrTy(err),rc)<<CRLF;
ss<<MMPR(StrTy(dest))<<CRLF;
ss<<" ACK ";
text=text+ss.str();
MM_ERR(" failure message  fck is sht "<<MMPR(text))
// this can be synchronous since this is not a live server :)
SendAdmin( text,  subj, a, msg );

}
return rc; 

} // TryOrDie 


// this checks bit b in x. If bit (b+1) is set, use the value for "n"
// found in dv xxx_regardless_xxx  ( only )  of if it exists  
bool Do(const IdxTy x, const StrTy & n, dispatch_vars & dv, const IdxTy b=0)
{
IdxTy do_=Bit(x,b);
if (Bit(x,b+1)) {
const StrTy& v=dv.get(n);
//IdxTy _do=myatoi(dv.get(n));
if ( v.length()!=0) { IdxTy _do=myatoi(v); do_=Bit(_do,b);
MM_ERR(MMPR2(_do,do_))
 } 
}
MM_ERR(" Do Do "<<  MMPR4(n,x,b,dv.get(n))<<MMPR(do_)<<MMPR(dv.dump()))
return do_;
}




void Init(const ctor_vars & cv ) 
{
m_desc=cv.get("desc");
m_script=cv.get("script");
m_dump=myatoi(cv.get("dump"));
m_headers=myatoi(cv.get("sane"));
//m_bfile=myatoi(cv.get("bfile"));
m_bfile=(cv.get("bfile"));
m_presponder=0;
} // Init
virtual StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR2(m_script,m_desc)<<CRLF;
return ss.str(); }

// MEMBERS
protected:
StrTy m_desc;
StrTy m_name;
Hand m_hand;
StrTy m_script,m_bfile;
IdxTy m_dump, m_headers;
MsgResponder * m_presponder;
Temps m_temps;

}; // mjm_mailproc_handler



//////////////////////////////////////////////

template <class Tr>
class mjm_mailproc_handler_map : public std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr > >  
{
 typedef mjm_mailproc_handler_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_mailproc_handler_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_mailproc_handler_map




////////////////////////////////////////////
#ifdef  TEST_MJM_MAILPROC_HANDLER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
 enum { BAD=~9U};
// typedef typename Tr::MyBlock  MyBlock;
}; // 

#include <string>
#include <fstream>
#include <streambuf>

#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_mailproc_handler <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MAILPROC_HANDLER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_mailproc_handler<Tr>  Myt;
//Myt x(argc,args);
Myt x;
typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_msg_responder<Tr> R;
typedef Myt::user_description_type Ud;
R resp;
resp.add_response_server(R::CONSOLE);
x.responder(&resp);
typedef Myt::dispatch_vars Dv;
Dv dv;
typedef Myt::ctor_vars Cv;
Cv  cv;
MyMsg msg; // header,body,acct
StrTy h,b,a;
Ud ud;
//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

//(const MyMsg & m, Ud & ud, MsgResponder * pr,  dispatch_vars & dv) 
if (cmd=="handle"){ x.handle(msg,ud, &resp,dv);  continue; } 
if (cmd=="x"){ x=Myt(cv); x.responder(&resp); MM_ERR(x.dump());  continue; } 
if (cmd=="cv"){ cv=Cv(li.words(),1);  continue; } 
if (cmd=="dv"){ dv=Dv(li.words(),1);  continue; } 
if (cmd=="dump"){ MM_ERR(cv.dump());MM_ERR(dv.dump());  continue; } 
if (cmd=="msg"){ msg=MyMsg(h,b,a);  continue; } 


if (cmd=="str"){ 
//https://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
std::ifstream t(cip.p1);
std::string str((std::istreambuf_iterator<char>(t)),
                 std::istreambuf_iterator<char>());
if (cip.p2=="h") h=str;
else if (cip.p2=="b") b=str;
else if (cip.p2=="a") a=str;
else MM_ERR(" nothing to do pick one of h,b,a "<<MMPR(cip.p2))
MM_ERR(MMPR3(h,b,a))
continue;
} // str


if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MAILPROC_HANDLER_H__ 
