#ifndef MJM_MAILPROC_USER_HANDLER_H__
#define MJM_MAILPROC_UXER_HANDLER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_mailproc_handler.h"
#include "mjm_read_buffer.h"
//#include "mjm_csv_mmp_form.h"
/*
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "../mjm_generic_message.h"
#include "mjm_msg_responder.h"
#include "mjm_pawnoff.h"
// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"
*/


// Thu Jun 18 20:35:41 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_mailproc_handler   
// g++ -std=gnu++11 -DTEST_MJM_MAILPROC_HANDLER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_mailproc_handler.h  -lpthread -lreadline

template <class Tr> class mjm_mailproc_user_handler : public mjm_mailproc_handler<Tr>
{
 typedef mjm_mailproc_handler<Tr> Super;
 typedef mjm_mailproc_user_handler<Tr> Myt;

protected:

 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_msg_responder<Tr> MsgResponder;
//typedef mjm_msg_rules<Tr>  MyRules;
//typedef mjm_msg_jrnl<Tr>  MyJrnl;
//typedef mjm_mailproc_handler<Tr> MyMailHand;
//typedef mjm_mailproc_handler_map<Tr> MyMailHandMap;
typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;
typedef mjm_ragged_table Ragged;
typedef  Ragged::Line Rline;
typedef std::regex Regex;
typedef mjm_global_mailusers<Tr> Users;
typedef typename Users::user_desc Ud;

typedef mjm_read_buffer<Tr> Rb;


typedef mjm_diet_diary_form<Tr> DietForm;

public:

// FIXME doh put this somwhere lol  - canned is a big junk bin 
typedef mjm_canned_methods Canned;
//int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
//int myatoi(const char * c) const { return Canned::myatoi(c); }



// just use this for now 
//typedef _dispatch_vars dispatch_vars;
typedef typename Super::_ctor_vars dispatch_vars;
typedef typename Super::_ctor_vars ctor_vars;
typedef typename Super::proc_io_type  proc_io_type;
// for registration 
mjm_mailproc_user_handler(const StrTy & nm ) {Super::ptr::name(nm,&Myt::factory());    }
mjm_mailproc_user_handler(const StrTy & nm,const ctor_vars & cv ) 
{Super::ptr::name(nm,&Myt::factory(cv));    }
mjm_mailproc_user_handler() {}
mjm_mailproc_user_handler(const ctor_vars & cv ) {Init(cv);}
virtual ~mjm_mailproc_user_handler() {}
virtual Myt &  operator()() { return *this; } 
//  static, NOT virtual  need an instance of the derived class 
static  Super * factory() { return  new mjm_mailproc_user_handler(); } 
static  Super * factoryc(const ctor_vars & cv) 
{ return  new mjm_mailproc_user_handler(cv); } 
static Myt* make(const StrTy & ty, const ctor_vars & cv) 
{ return Make(ty,cv); } 
virtual const StrTy & desc() const { return m_desc; } 
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud,dispatch_vars & dv) {return Handle(pio,m,ud,dv); }  
virtual IdxTy handle(proc_io_type & pio, const MyMsg & m, Ud & ud, MsgResponder * pr,  dispatch_vars & dv) 
{return Handle(pio,m,ud,pr,dv); }  
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:
static Myt* Make(const StrTy & ty, const ctor_vars & cv) 
{




}
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//IdxTy SendAttachedFile(const MyMsg& m, const StrTy & subj, const StrTy & body,const StrTy & fn)
//IdxTy SendReply(const MyMsg & m, const StrTy & s)

virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud &ud, MsgResponder * pr, dispatch_vars & dv)
{ return Handle(pio,m,ud,dv); }
virtual IdxTy Handle(proc_io_type & pio, const MyMsg & m, Ud & ud,dispatch_vars & dv)
{ 
MM_ERR(" in handler ...."<<MMPR(ud.b4()))
const bool b4=ud.b4();
if (!b4) return HandleNewUser( m, ud, dv);
const MyMsg & msg=m; // m_messages[i];
const StrTy d= (msg.hval_lc("Date:"));
const StrTy f= (msg.hval_lc("From:"));
const StrTy su= (msg.hval_lc("Subject:"));
const StrTy len= (msg.hval_lc("Content-Length:"));
const StrTy from=msg.from_address(0);
Rb rb;
rb.split_and_mark(su,' ');
const IdxTy sz=rb.string_count();
for(IdxTy i=0; i<sz; ++i)
{
if (strcmp(rb[i],"register")==0) return HandleRegister(m,ud,dv); 
} // i 
//Ss ss;
IdxTy rc= Super::SendReply( m,  m_badcmd_text);
return rc; 
} // Handle
 
virtual IdxTy HandleRegister(const MyMsg & m, Ud & ud,dispatch_vars & dv)
{
Ss ss;
ss<<m.decoded_body();
const StrTy & s=ss.str();
Ragged r;
// look at body, see how it compares to registration form

r.load(ss);
Ragged filled;
if ( m_reg.filled_in(&filled,r))
{
ud.set_registered();
Ss ss;
ss<<m_welcome_text;
ss<<CRLF; 
ss<<" filled form is "<<CRLF;
filled.dump_os(ss,3);
IdxTy rc= Super::SendReply( m,  ss.str());
return rc; 
}
// send the blank registration form 
Ss rr;
m_reg.dump_os(rr,3);
IdxTy rc= Super::SendReply( m,  rr.str());
return rc; 

} // HandleRegister

virtual IdxTy HandleNewUser(const MyMsg & m, Ud & ud,dispatch_vars & dv)
{
ud.set_b4();
IdxTy rc= Super::SendReply( m,  m_new_text);
return rc; 
}
bool W(const ctor_vars & cv, const char *  k, StrTy & d)
{const StrTy & x=cv.get(k);
MM_ERR(" W "<<MMPR3(k,d,x))
if (x.c_str()[0]!=0) {  d=x;  return true; } 
return false; 
} // W


IdxTy Load(StrTy & d, const StrTy & fn)
{
Ss ss;
std::ifstream is(fn.c_str()); ss<<is.rdbuf();
d=ss.str();
if (d.length()==0) MM_ERR(" file lenght is zero "<<MMPR2(d,fn))
else MM_ERR("loaded "<< MMPR2(fn,d.length()) )
return 0;
} // Load 

IdxTy Load(Ragged & d, const StrTy & fn)
{
StrTy f;
Load(f,fn);
Ss ss; ss<<f;
d.load(ss);
MM_ERR(MMPR2(d.size(),fn))
return 0;
}

void Init(const ctor_vars & cv ) 
{
if ( W(cv,"new-user-fn",m_new_fn)) { Load(m_new_text,m_new_fn); }  
if ( W(cv,"blacklist-fn",m_black_fn)) { Load(m_black_text,m_black_fn); }  
if ( W(cv,"badcmd-fn",m_badcmd_fn)) { Load(m_badcmd_text,m_badcmd_fn); }  
if ( W(cv,"register-fn",m_reg_fn)) { Load(m_reg,m_reg_fn); }  
if ( W(cv,"welcome-fn",m_welcome_fn)) { Load(m_welcome_text,m_welcome_fn); }  

/*
StrTy x=cv.get("noun-file");
if (x.c_str()[0]!=0) m_df.load_nouns(x);
 x=cv.get("ignores-file");
if (x.c_str()[0]!=0) m_df.load_ignores(x);
 x=cv.get("reserves-file");
if (x.c_str()[0]!=0) m_df.load_reserveds(x);
*/
} // Init

virtual StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<Super::Dump(flags); 
//ss<<MMPR2(m_script,m_desc)<<CRLF;
return ss.str(); }

// MEMBERS
protected:
StrTy m_desc;
StrTy m_new_fn;
StrTy m_new_text;
StrTy m_black_fn;
StrTy m_black_text;
StrTy m_badcmd_fn;
StrTy m_badcmd_text;
StrTy m_reg_fn;
Ragged m_reg;
StrTy m_welcome_fn;
StrTy m_welcome_text;
//DietForm m_df;

}; // mjm_mailproc_diet_handler



//////////////////////////////////////////////
#if 0 
template <class Tr>
class mjm_mailproc_handler_map : public std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr > >  
{
 typedef mjm_mailproc_handler_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_mailproc_handler< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_mailproc_handler_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_mailproc_handler_map
#endif




////////////////////////////////////////////
#ifdef  TEST_MJM_MAILPROC_HANDLER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_mailproc_handler <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MAILPROC_HANDLER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_mailproc_handler<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MAILPROC_HANDLER_H__ 
