#ifndef MJM_MSG_RESPONDER_H__
#define MJM_MSG_RESPONDER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_msg_jrnl.h"

#ifdef HAVE_MIKE_MUTT_SERVER
#include "mjm_mutt_server.h"
#include "mjm_neomutt_interface.h"
#endif

// this should be on the path... 
#include "../mjm_generic_message.h"

#include "mjm_pawnoff.h"

// order is temporary get required includes in righ file 
#include "mjm_cpp_regex.h"

#include "../mjm_message_store.h"
/*

allow a message handler to respond to a message that can not be handled
silently. This may just be a confirmation or a requested form or
need to correct a request

*/



// Fri Jul 24 19:19:52 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_msg_responder   
// g++ -std=gnu++11 -DTEST_MJM_MSG_RESPONDER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_msg_responder.h  -lpthread -lreadline

template <class Tr>
class mjm_msg_responder 
{
 typedef mjm_msg_responder Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef void SrcMsg;

typedef mjm_generic_message<Tr> MyMsg;
typedef std::map<StrTy,SrcMsg *> MsgLut;
typedef std::vector<StrTy> Att;

typedef mjm_pawnoff<Tr> Hand;
typedef typename Hand::blob Blob;

typedef std::vector<IdxTy> TryOrder;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
typedef Att attach_list;
enum { CONSOLE,MUTTINT,MUTTEXT,SENDMAILEXT };
mjm_msg_responder():m_orig(0)  {Init(); }
mjm_msg_responder(SrcMsg * p ): m_orig(p) {Init(); }
~mjm_msg_responder() {}
void add_response_server(const IdxTy n ) { m_tries.push_back(n); } 
void clear_response_server() { m_tries.clear(); } 
void admin(const StrTy & a ) { m_admin=a;}
const StrTy &  admin() { return m_admin;}
void site(const StrTy & a ) { m_site=a;}
const StrTy &  site() { return m_site;}

// should actually look and also check server etc
void add_lut(SrcMsg * p, const StrTy & uid) { m_lut[uid]=p; }
// questionable value but saves space prevents memory leak
// in long term 
void done(const StrTy &  p) {
auto ii=m_lut.find(p); 
if (ii!=m_lut.end()) m_lut.erase(ii); 
}
IdxTy reply(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &msg)
{ return Reply(text,subj,a,msg); } 
IdxTy reply(const StrTy & text, const StrTy & subj, MyMsg &msg)
{ Att a;  return Reply(text,subj,a,msg); } 

IdxTy send_admin(const StrTy & text, const StrTy & subj, const Att & a,const MyMsg &  msg )
{return  SendAdmin( text,  subj, a, msg ); }

StrTy dump(const IdxTy flags=0) { return Dump(flags); }

protected:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }

IdxTy SendAdmin(const StrTy & text, const StrTy & subj, const Att & a,const MyMsg &  msg )
{
// relies on neomutt being set to admin 
const StrTy to=m_admin; // "marchywka@hotmail.com";
MyMsg afck=msg; //not const for some fcking reason 
const IdxTy lbody=msg.body().length();
const IdxTy ltotal=msg.verbatim().length();
const IdxTy nparts=msg.parts();
Ss ss;
ss<<text<<CRLF<<CRLF;
ss<<MMPR3(lbody,ltotal,nparts)<<CRLF;
if (ltotal<(1<<20)) { ss<<msg.verbatim(); }
else 
{
for(IdxTy i=0; i<nparts; ++i) 
{ ss<<" part "<<MMPR2(i,msg.part(i).name())<<CRLF; } 
if( nparts>0) ss<<msg.part(0).body()<<CRLF;
ss<<msg.header()<<CRLF;
} // ltotal> 100000
StrTy _subj;
if (m_site.length()!=0) { _subj=StrTy("[")+m_site+StrTy("]"); }
_subj +=subj;
return  SendMuttExt(ss.str(),_subj, a, afck, to  );

} // SendAdmin 

IdxTy Reply(const StrTy & text, const StrTy & subj, const Att & a, MyMsg & msg)
{ 
const StrTy f= (msg.hval_lc("From:"));
const StrTy uid=msg.server_uuid();
const auto ii=m_lut.find(uid);
const SrcMsg * p=0;
if (ii==m_lut.end()) { MM_ERR(" no oigina entry for "<<MMPR(uid)) } // try to send a reply made up 
else { p= (*ii).second; } 
IdxTy rc=~0;
MM_ERR(" sending reply "<<MMPR(f))
MM_SZ_LOOP(i,m_tries,sztries)
{
switch (m_tries[i])
{
case MUTTINT:{rc= ReplyMuttInt(text,subj,a,p,f);   break; }
case MUTTEXT: { rc= ReplyMuttExt(text,subj,a,msg); break;  } 
case SENDMAILEXT :{rc= ReplySendmail(text,subj,a,msg);  break; }
case CONSOLE :{rc= ReplyConsole(text,subj,a,msg);  break; }
default: MM_ERR(" bad mail sender "<<MMPR2(i,m_tries[i]))
}  // switch 
if (rc==0) break; 
else MM_ERR(" reply failed to "<<MMPR2(m_tries[i],f))
 } // i jh
return rc; 

} 

IdxTy ReplyConsole(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &  msg )
{
IdxTy rc=1; // try the real ones if they are included 
const StrTy f= (msg.hval_lc("From:"));
const StrTy rt= (msg.hval_lc("ReplyTo:"));
const StrTy su= (msg.hval_lc("Subject:"));
const StrTy dx=msg.from_address(0);
MM_ERR(MMPR4(f,rt,su,dx))
MM_ERR(MMPR2(subj,text))
MM_LOOP(ii,a) { MM_ERR(MMPR((*ii))) } 
return rc;
}
//cat diet/diary.txt | mail -s "diet submit" marchywka
//const StrTy f= (msg.hval_lc("From:"));
//const StrTy su= (msg.hval_lc("Subject:"));

IdxTy ReplySendmail(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &  msg )
{
const StrTy f= (msg.hval_lc("From:"));
const StrTy rt= (msg.hval_lc("ReplyTo:"));
const StrTy su= (msg.hval_lc("Subject:"));
const StrTy dx=msg.from_address(0);
Blob data,dest;
data=text; // msg.body();
StrTy attaches="";
MM_LOOP(ii,a) { attaches=attaches+" -a "+(*ii); } 
//char c2[2]; c2[0]=4; c2[1]=0;
// dy=f; // +c2;;
//dy=StrTy("fck");
//IdxTy xrc=m_hand.get_output_with_input(dx,dy,"sed -e 's/.*<//' | sed -e 's/>.*//' " );

const StrTy cmd="mail "+attaches+"  -s \""+su+"\" "+StrTy(dx);
MM_ERR(" try "<<MMPR(cmd))
IdxTy rc=m_hand.get_output_with_input(dest,data,cmd);

return rc;
}

IdxTy ReplyMuttExt(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &  msg )
{
const StrTy f= (msg.hval_lc("From:"));
const StrTy rt= (msg.hval_lc("ReplyTo:"));
const StrTy su= (msg.hval_lc("Subject:"));
const StrTy text2=text+" "+msg.body();
return SendMuttExt(text,subj,a,msg,rt); 
}
IdxTy SendMuttExt
(const StrTy & text, const StrTy & subj, const Att & a,MyMsg &  msg,
const StrTy & to  )
{
Blob dest,data;
data=text; // msg.body();
StrTy cmd="neomutt -s \""+subj+"\" "; // +rt;
if (a.size())
{
cmd=cmd+ StrTy(" -a ");
MM_LOOP(ii,a) { cmd=cmd+StrTy(" ")+(*ii); } 
cmd=cmd+ StrTy(" -- ");
} 
cmd=cmd+" "+to;
MM_ERR(" try "<<MMPR(cmd))
IdxTy rc=m_hand.get_output_with_input(dest,data,cmd);

return rc;
}




IdxTy ReplyMuttInt(const StrTy & text, const StrTy & subj, const Att & a,const SrcMsg* p, const StrTy & to=StrTy())
{
int rcs=~0;
IdxTy j=0;
IdxTy sz=a.size();
const char ** c= new const char*[sz+1];
for (IdxTy i=0; i<sz; ++i)
{
//c[j]=(char*)a[i].c_str();
c[j]=a[i].c_str();
++j;
} // sz
c[j]=0;
const char ** lto=0;
//if(false) 
if (j!=0)
{
MM_ERR(" have files to attach so need no reply add sender")
lto= new const char*[2];
lto[0]=(const char*)"marchywka@hotmail.com";
lto[0]=to.c_str(); // (const char*)"marchywka@hotmail.com";
lto[1]=0;
}
#ifdef HAVE_MIKE_MUTT_SERVER
MM_ERR(" mutt internal send now ")
if (j==0) rcs=mjm_send_via_mutt(lto,( char *)subj.c_str(),( char *)  text.c_str(),0,( Email* )p);
// 2022-02-11 wtf??? TODO 
else rcs=mjm_send_via_mutt(lto,subj.c_str(), text.c_str(),c,( Email* )0);
//else rcs=mjm_send_via_mutt(lto,subj.c_str(), text.c_str(),c,( Email* )p);

#endif
return rcs;
} // ReplyMutt


// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
#ifdef HAVE_MIKE_MUTT_SERVER
typedef mjm_neomutt_interface<Tr> MuttInterface;
#endif

#ifdef HAVE_MIKE_MUTT_SERVER
void xxx()
{
char * subj="subect";
char * text=" message text";
const char ** lto= new const char*[2];
lto[0]="marchywka@hotmail.com";
lto[1]=0;
// the reply function fails but sending new messag ok 
//int rcs=mjm_send_via_mutt(lto,subj, text,0,elist[k]);
//int rcs=mjm_send_via_mutt(lto,subj, text,0,0);
//int rcs=mjm_send_via_mutt(lto,subj, text,0,( Email* )m_orig);
int rcs=mjm_send_via_mutt(0,subj, text,0,( Email* )m_orig);

delete[]  lto;
}
#endif
void Init()
{
m_admin="marchywka@hotmail.com";
m_site="MikeMail DevSite";
}
// members
SrcMsg * m_orig;
MsgLut m_lut;
Hand m_hand;
TryOrder m_tries;
StrTy m_admin,m_site;
}; // mjm_msg_responder

//////////////////////////////////////////////

template <class Tr>
class mjm_msg_responder_map : public std::map<typename Tr::StrTy, mjm_msg_responder< Tr > >  
{
 typedef mjm_msg_responder_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_msg_responder< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_msg_responder_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_msg_responder_map




////////////////////////////////////////////
#ifdef  TEST_MJM_MSG_RESPONDER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_msg_responder <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MSG_RESPONDER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_msg_responder<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MSG_RESPONDER_H__ 
