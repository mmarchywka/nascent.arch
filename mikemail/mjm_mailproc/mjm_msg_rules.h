#ifndef MJM_MSG_RULES_H__
#define MJM_MSG_RULES_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <regex>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include "mjm_collections.h"
// junk bin, need to move myatoi doh 
#include "mjm_canned_methods.h"
#include "../mjm_generic_message.h"
#include "../mjm_global_mailusers.h"
#include "mjm_pawnoff.h"
#include "mjm_cpp_regex.h"
#include "mjm_read_buffer.h"

/*

// Thu Jun 11 18:39:08 EDT 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_msg_rules   
// g++ -std=gnu++11 -DTEST_MJM_MSG_RULES -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_msg_rules.h  -lpthread -lreadline

 g++ -std=gnu++11 -DTEST_MJM_MSG_RULES -I. -I../../../mjm/hlib -I../../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_msg_rules.h  -lpthread -lreadline

*/
template <class Tr>
class mjm_msg_rules 
{
 typedef mjm_msg_rules Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;


typedef mjm_canned_methods Canned;

typedef mjm_generic_message<Tr>  MyMsg;
typedef mjm_pawnoff<Tr> Hand;
typedef mjm_read_buffer<Tr> Rb;

typedef std::regex Regex;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;

typedef mjm_global_mailusers<Tr> Users;
typedef typename Users::user_desc UserDesc;
//../toobib/mjm_bibtex_motif.h:return mjm_cpp_regex::stuff::has(s,m_r,0);
//../toobib/mjm_bibtex_motif.h:if (m_is_regex) m_r = Regex(m_domain);
//../toobib/mjm_bibtex_motif.h:Regex m_r;
static IdxTy bad() { return ~0; } 
// FIXME doh put this somwhere lol  - canned is a big junk bin 
static int myatoi(const StrTy & s ) { return Canned::myatoi(s.c_str()); }
static int myatoi(const char * c)  { return Canned::myatoi(c); }

class msg_rule
{
//typedef std::regex_constants::syntax_option_type SoTy;
typedef std::regex SoTy;
public:
/*
C++11C++14
flag	effects on syntax	notes
icase	Case insensitive	Regular expressions match without regard to case.
nosubs	No sub-expressions	The match_results structure will not contain sub-expression matches.
optimize	Optimize matching	Matching efficiency is preferred over efficiency constructing regex objects.
collate	Locale sensitiveness	Character ranges, like "[a-b]", are affected by locale.
ECMAScript	ECMAScript grammar	The regular expression follows one of these grammars.
One (and only one) of these six grammar flags needs to be set for the bitmask to have a valid value.
basic	Basic POSIX grammar
extended	Extended POSIX grammar
awk	Awk POSIX grammar
grep	Grep POSIX grammar
egrep	Egrep POSIX grammar
*/
typedef std::vector<StrTy> Tvec ; 
typedef std::map<StrTy, IdxTy> NameTable;
enum { };
msg_rule(const StrTy &name, const StrTy &str, const StrTy &loc, const IdxTy & code)
:m_name(name),m_str(str), m_location(loc),m_regex(m_str,SoTy::ECMAScript), m_code( code)
{Init(); }
msg_rule() :m_name(),m_str(), m_location(),m_regex(), m_code(bad())
{Init(); }
typedef std::map<StrTy, IdxTy> HandIndex;
msg_rule(const Tvec & tv,const IdxTy st, const HandIndex & hi ) { Init(tv,st,hi); } 
msg_rule(const Tvec & tv,const IdxTy st) { Init(tv,st); } 
const StrTy & name() const { return m_name; } 
void set_tree(const IdxTy n, const IdxTy t, const IdxTy f)
{ m_n=n; m_true=t; m_false=f; }
IdxTy code() const { return m_code; }  // state number at end of rules list
IdxTy n() const { return m_n; } 
bool test( const MyMsg & m) const  { return Test(m); } 
bool test( const MyMsg & m, const UserDesc & ud) const  { return Test(m,ud); } 
IdxTy branch(const MyMsg& m) const {
//if (m_true==m_false) return m_true; 
 return test(m)?m_true:m_false; }
IdxTy branch(const bool& m) const { return (m)?m_true:m_false; }
IdxTy resolve(const NameTable & nt) { return Resolve(nt); } 
void dump(OsTy & os) const 
{
os<<MMPR4(m_name,m_n,m_str,m_location);
os<<MMPR4(m_code,m_true,m_false,m_mod);
//os<<CRLF;
}
StrTy dump(const IdxTy flags)const { Ss ss; dump(ss); return ss.str(); }

private:
IdxTy Resolve(const NameTable & nt) { 
IdxTy rc=0;
auto ii=nt.find(m_true_name);
if (ii!=nt.end()) m_true=(*ii).second; else ++rc;
ii=nt.find(m_false_name);
if (ii!=nt.end()) m_false=(*ii).second; else ++rc;
ii=nt.find(m_name);
if (ii!=nt.end()) m_n=(*ii).second; else ++rc;

//return Resolve(nt); 
return rc;
} // Resolve

 
bool Test( const MyMsg & m, const UserDesc & ud) const  { 
// could make a case for virtual here but ok for now. 
if (m_location.length()!=0) return Test(m); 
if (m_ubits!=0){
MM_ERR(MMPR(m_ubits))
 return ud.test(m_ubits);
}
if (m_user) return Match(ud.user());

return false;
} 
bool Test( const MyMsg & m) const 
{
typedef std::vector<StrTy> Vvalues;

const Vvalues  & vv=m.hval_vec(m_location);
// now want first,last, anywhere...ZZZZ 
//MM_ERR(" testing "<<MMPR(m.header()))
MM_ERR(" testing "<<MMPR3(m_location, vv.size(),m_str))
MM_LOOP(ii,vv)
{
//const bool has= m_exact?(Exact(m_str.c_str(),(*ii).c_str(),m_str.length())!=(~0)):(Has(*ii,m_regex)); 
const bool has=Match(*ii);
MM_ERR(" test val "<<MMPR2((*ii),has))
//if (Has(*ii,m_regex)) return true; 
if (has) return true; 
}
return false;
}

bool Match(const StrTy & s) const 
{
const bool has= m_exact?
	(Exact(m_str.c_str(),s.c_str(),m_str.length())!=(~0))
	:(Has(s,m_regex)); 
return has;
} 
bool Has(const StrTy & s, const Regex & r) const 
{
return mjm_cpp_regex::stuff::has(s.c_str(),r,0);
}
void Init()
{
m_n=bad();
m_true=bad();
m_false=bad();
m_mod= SoTy::ECMAScript;
m_ubits=0;
m_exact=false;
m_user=false;
}
IdxTy Exact(const char * probe, const char * s, const IdxTy len) const
{
const int slen=strlen(s);
const int smax= 1+slen-int(len);
for(IdxTy i=0; i<smax; ++i)
{
if (strncmp(probe,s+i,len)==0) return true;
}
return ~0;
} // Exact
bool U(StrTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{ ++i; if (i>=sz) return false; x=(l[i]); return true; }
bool Uz(StrTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{  if (i>=sz) return false; x=(l[i]); ++i;  return true; }
bool U(IdxTy & x, const Line & l, IdxTy & i, const IdxTy sz)
{ ++i; if (i>=sz) return false; x=myatoi(l[i]); return true; }
bool U(IdxTy & x, const Line & l, IdxTy & i, const IdxTy sz, const HandIndex & hi)
{ ++i; if (i>=sz) return false; 
const auto ii=hi.find(l[i]);
if (ii==hi.end()) {
 x=myatoi(l[i]); 
MM_ERR(" handler not found  as name use number "<<MMPR2(l[i],x))

return true; } 
x=(*ii).second; // myatoi(l[i]); 
return true; }



//bool U(bool & x, const Line & l, IdxTy & i, const IdxTy sz)
//{ ++i; if (i>=sz) return false; x=myatoi(l[i]); return true; }


// canned is a dumb header doh
int myatoi(const StrTy & s ) const { return Canned::myatoi(s.c_str()); }
int myatoi(const char * c) const { return Canned::myatoi(c); }

bool  UserBits(IdxTy & d, const Line & l, IdxTy & i, const IdxTy sz)
{
++i; if (i>=sz) return false;
Rb rb; 
rb.split_and_mark(l[i],',');
for(IdxTy j=0; j<rb.string_count(); ++j)
{
IdxTy bm=UserDesc::bit_def((rb[j]));
MM_ERR(MMPR2(bm,rb[j]))
if (bm!=(~0)) d|=(1<<bm);
else MM_ERR(" no user meaning for "<<MMPR4(j,i,l[i],rb[j]))

} // j 
MM_ERR(" ubits "<<MMPR(d))
return true; 
}
void Init( const Tvec & tv,const IdxTy st) 
{ Init(tv,st,HandIndex()); } 
void Init(const Tvec & tv,const IdxTy _st, const HandIndex & hi ) 
{
Init(); m_code=bad();
IdxTy st=_st;
const IdxTy sz=tv.size();
Uz(m_name,tv,st,sz); // m_name=tv[i+1]; // not used, rule name 
for(IdxTy i=st; i<sz; i+=1)
{
const StrTy&  v=tv[i];
MM_ERR(MMPR3(i,v,tv[(i+1)%sz]))
//if(v=="name") U(m_name,tv,i,sz); // m_name=tv[i+1]; // not used, rule name 
if(v=="str") U(m_str,tv,i,sz); //  m_str=tv[i+1]; // regex query string 
else if(v=="location") U(m_location,tv,i,sz); //  m_location=tv[i+1]; // header to query 
else if(v=="loc") U(m_location,tv,i,sz); //  m_location=tv[i+1]; // header to query 
else if(v=="code") U(m_code,tv,i,sz,hi); //  m_code=myatoi(tv[i+1]); // classification if this is the last rule 
else if(v=="handler") U(m_code,tv,i,sz,hi); //  m_code=myatoi(tv[i+1]); // classification if this is the last rule 
//else if(v=="n") U(m_n,tv,i,sz); //  m_n=myatoi(tv[i+1]); // not used 
else if(v=="n") {  MM_ERR(" n is obsolete "<<MMPR3(i,v,m_name)); }//  m_n=myatoi(tv[i+1]); // not used 
//else if(v=="true") U(m_true,tv,i,sz); //  m_true=myatoi(tv[i+1]); // next state if rule met
else if(v=="true") U(m_true_name,tv,i,sz); //  m_true=myatoi(tv[i+1]); // next state if rule met
// oor values terminate rule tree and "state" is returned as "code"
//else if(v=="false") U(m_false,tv,i,sz); // m_false=myatoi(tv[i+1]); // next state if rule fails
else if(v=="false") U(m_false_name,tv,i,sz); // m_false=myatoi(tv[i+1]); // next state if rule fails
else if(v=="exact") m_exact=true; // m_false=myatoi(tv[i+1]); // next state if rule fails
else if(v=="user") m_user=true; // m_false=myatoi(tv[i+1]); // next state if rule fails
else if (v=="ubits")
	  UserBits(m_ubits, tv,  i, sz);
// this needs to have our own codes etc. 
else if(v=="mode"){U(m_mod,tv,i,sz); //  m_mod=myatoi(tv[i+1]); // regex modifiers 
MM_ERR(" mode will not work right ")
}
else MM_ERR(" ignoring "<<v)
}
if (m_mod==0) m_mod=SoTy::ECMAScript;
if (m_str.length()!=0) {
m_regex=Regex(m_str.c_str(),m_mod);
// what the afck is a fcking ecmascript???? FICL 
m_regex=Regex(m_str.c_str());
} // regex 
} // Init
 
StrTy m_name;
StrTy m_str;
StrTy m_location;
Regex m_regex;
IdxTy m_code;
IdxTy m_n,m_true,m_false;
StrTy m_true_name,m_false_name;
IdxTy m_mod;
IdxTy m_ubits;
bool m_exact,m_user;
}; // msg_rule

typedef msg_rule Rule;
typedef std::vector<Rule> Rules;


typedef std::map<StrTy, IdxTy> HandIndex;
public:
mjm_msg_rules() {}
mjm_msg_rules(const Ragged  & r, const IdxTy st) {Config(r,st);}
~mjm_msg_rules() {}

void config(const Ragged  & r, const IdxTy st) {Config(r,st);}
void config(const Ragged  & r, const IdxTy st,const HandIndex & hi) 
{m_index=hi; Config(r,st);}
void config(const Line  & rline, const IdxTy st=0) {Config(rline,st);}
void clear() { Clear(); } 
// the result of executing the rules on m 
IdxTy code(const MyMsg & m , const IdxTy flags) { return Code(m,flags); } 
IdxTy code(const MyMsg & m , UserDesc & ud, const IdxTy flags) 
{ return Code(m,ud,flags); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
IdxTy Code(const MyMsg & m , const IdxTy flags)
{
IdxTy pc=0;
IdxTy code=bad();
const IdxTy sz=m_rules.size();
while (pc<sz)
{
const Rule & r=m_rules[pc];
const bool tf=r.test(m);
if (tf) code=r.code();
pc=r.branch(tf);
MM_ERR(MMPR4(code,pc,sz,r.dump(0)))
}
return code;
} // Code 2 param 

IdxTy Code(const MyMsg & m , UserDesc & ud, const IdxTy flags) 
{
MM_ERR(MMPR(dump(0)))
IdxTy pc=0;
IdxTy code=bad();
const IdxTy sz=m_rules.size();
while (pc<sz)
{
const Rule & r=m_rules[pc];
const bool tf=r.test(m,ud);
//if (tf) 
code=r.code();
IdxTy pco=pc;
pc=r.branch(tf);
MM_ERR("xxxxxxxxxxxxxxxxxxx "<<MMPR4(pco,pc,tf,code))
MM_ERR(MMPR(ud.user())<<MMPR4(code,pc,sz,r.dump(0)))
}
if (true) return code;
return Code(m,flags); 
} // Code 3 param

bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  
MM_LOOP(ii,m_rules) ss<<(*ii).dump(0)<<CRLF ;
return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Config(const Line & rline, const IdxTy st)
{

Rule rule(rline,st,m_index);
// this is dumb, names better. 
//const IdxTy n=rule.n();
//if (m_rules.size()<=n) m_rules.resize(n+1);
//m_rules[n]=rule; 
const IdxTy n=m_rules.size();
m_rules.push_back(rule); 
m_rule_index[rule.name()]=n;

}
void Config(const Ragged & r, const IdxTy st)
{
m_config=r;
const IdxTy sz=m_config.size();
for(IdxTy i=st; i<sz; ++i)
{
const Ragged::Line & line=m_config.line(i);
if (line.size()<1) continue;
if (line[0]=="rule")
{
Config(line,1);
/*
Rule rule(line,1);
const IdxTy n=rule.n();
if (m_rules.size()<=n) m_rules.resize(n+1);
m_rules[n]=rule; 
*/


//MM_ERR(MMPR3(i,n,rule.dump(0)))
} // rule
} // for i 
MM_LOOP(ii,m_rules) { (*ii).resolve(m_rule_index); } 
MM_LOOP(ii,m_rules) {MM_ERR(MMPR( (*ii).dump(0))); } 
} // Config 


void Clear() { m_rules.clear(); m_rule_index.clear(); } 
// MEMBER

Ragged m_config;
Rules m_rules;
HandIndex m_index; // These are handler names and numbers
HandIndex m_rule_index; // These are rule or state names and numbers
}; // mjm_msg_rules

//////////////////////////////////////////////

template <class Tr>
class mjm_msg_rules_map : public std::map<typename Tr::StrTy, mjm_msg_rules< Tr > >  
{
 typedef mjm_msg_rules_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_msg_rules< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_msg_rules_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_msg_rules_map




////////////////////////////////////////////
#ifdef  TEST_MJM_MSG_RULES
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_msg_rules <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_MSG_RULES "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_msg_rules<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_MSG_RULES_H__ 
