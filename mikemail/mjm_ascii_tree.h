#ifndef MJM_ASCII_TREE_H__
#define MJM_ASCII_TREE_H__

#include "mjm_globals.h"
#include <vector>
#include <map>



// Sat May 11 13:24:14 EDT 2019
// generated by -classhdr mjm_ascii_tree  


template <class Tr>
class mjm_ascii_node 
{
 typedef mjm_ascii_node Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
 typedef typename Tr::MyBlock  MyBlock;

typedef Myt Node;
typedef Myt NodeTy;
typedef std::vector<NodeTy*> Kids;
typedef std::vector<NodeTy*> Parents;
typedef StrTy Label;

public:
mjm_ascii_node() {}
~mjm_ascii_node() {}
void label(const StrTy & n) { m_lbl=n; }
const Label & name () const { return m_lbl; }  
const Label & label () const { return m_lbl; }  
void add_parent(Node * p)
{
//(*p).m_kids.push_back(this);
m_parents.push_back(p);

}
void add_child(Node * p)
{
//(*p).m_parents.push_back(this);
m_kids.push_back(p);

}
Kids & kids() { return m_kids; } 

private:
Kids m_kids;
Parents m_parents;
Label  m_lbl;
void Init()
{


}
void Release()
{


}


}; // mjm_ascii_node

template <class Tr, class Tnode=mjm_ascii_node<Tr> >
class mjm_ascii_tree 
{
 typedef mjm_ascii_tree Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
 typedef typename Tr::MyBlock  MyBlock;

class layout_state
{

public:
layout_state(): lvl(0) {}
StrTy space() const { return StrTy("    "); } 
IdxTy lvl;
}; // layout_state

public:
typedef Tnode Node;
typedef std::map<Node*,StrTy> Index;


mjm_ascii_tree() {}
~mjm_ascii_tree() {Release(); }
Node & add_root(const StrTy & name)
{
Node* p= new Node();
(*p).label(name);
m_roots[p]=name;
m_index[p]=name;
return *p;
} // add_root
Node & add_kid(Node & parent, const StrTy & name)
{
Node* p= new Node();
(*p).label(name);
m_index[p]=name;
// either one is ok if the node adds the other. 
(*p).add_parent(&parent);
(parent).add_child(p);
return *p;
} // add_root


StrTy ascii()  const
{
Ss ss;
layout_state s;
MM_LOOP(ii,m_roots)
{
s.lvl=0;
ascii(ss, *(*ii).first,s);
} // ii 
return ss.str();

} // ascii

void  ascii(Ss & ss, Node& p, layout_state & s) const
{
const IdxTy lvl=s.lvl;
for (IdxTy i=0; i<s.lvl; ++i) ss<<s.space(); 
ss<<p.label()<<CRLF;
MM_LOOP(jj, p.kids())
{
s.lvl=lvl+1;
ascii(ss,*(*jj),s);

}

} // ascii 




private:
void Init()
{
}
void Release()
{
MM_LOOP(ii,m_index) { delete (*ii).first; } 

}

Index m_index;
Index m_roots;

}; // mjm_ascii_tree

#endif // MJM_ASCII_TREE_H__ 
