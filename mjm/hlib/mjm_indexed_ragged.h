#ifndef MJM_INDEXED_RAGGED_H__
#define MJM_INDEXED_RAGGED_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_wovdb.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_loo_parsing.h"
//#include "mjm_choices_abbrv.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Feb 26 13:27:46 EST 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_indexed_ragged   
// g++  -Wall -std=gnu++11 -DTEST_MJM_INDEXED_RAGGED -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_indexed_ragged.h  -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_indexed_ragged("mjm_indexed_ragged"
, "  ");

template <class Tr>
class mjm_indexed_ragged 
{
 typedef mjm_indexed_ragged Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_wovdb<Tr,StrTy> WovDB;
typedef typename WovDB::vector_type Vt;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_ragged_cursor RaggedCursor;

typedef mjm_blob<Tr> Blob;
typedef mjm_pawnoff<Tr> Hand;

typedef std::vector<StrTy> Names;
typedef std::vector<StrTy> Values;
typedef std::vector<IdxTy> Entries;
typedef std::map<StrTy, Entries > IdxMap;
typedef std::map<StrTy, IdxMap > IndexMaps;
typedef std::map<Names, Entries > VectorIndexMaps;
typedef std::map<StrTy, StrTy  > QueryMap;


public:
mjm_indexed_ragged() {Init();}
~mjm_indexed_ragged() {}
typedef Names names_type;
StrTy  dump_ssv(const IdxTy flags=9) { return m_r.dump_ssv(); }  
IdxTy merge(const Myt & that, const IdxTy flags) { return Merge(that,flags); } 

IdxTy load(const StrTy fn, const Names& nidx, const IdxTy flags)
{ return Load(fn,nidx,flags); } 
IdxTy load(const Ragged & r, const Names& nidx, const IdxTy flags)
{ m_r=r; return Load(r,nidx,flags); } 


const IdxTy size() const { return m_r.size(); } 
Values find(QueryMap & midx, const IdxTy flags)
{ return Find(midx,flags); } 

Values find(const StrTy & v1,  const IdxTy flags)
{
if (m_names.size()<1)
{
MM_ERR(" not enough names loaded for query "<<MMPR(m_names.size()))
MM_LOOP(ii,m_names) { MM_ERR(MMPR((*ii))) }
}

QueryMap m;
m[m_names[0]]=v1;
return find(m,flags);

} // find


Values find(const StrTy & v1, const StrTy & v2, const IdxTy flags)
{
if (m_names.size()<2)
{
MM_ERR(" not enough names loaded for query "<<MMPR(m_names.size()))
MM_LOOP(ii,m_names) { MM_ERR(MMPR((*ii))) }
return Values();
}

QueryMap m;
m[m_names[0]]=v1;
m[m_names[1]]=v2;
return find(m,flags);

} // find

Values find(const StrTy & v1, const StrTy & v2, const StrTy & v3,const IdxTy flags)
{
if (m_names.size()<3)
{
MM_ERR(" not enough names loaded for query "<<MMPR(m_names.size()))
MM_LOOP(ii,m_names) { MM_ERR(MMPR((*ii))) }
}

QueryMap m;
m[m_names[0]]=v1;
m[m_names[1]]=v2;
m[m_names[2]]=v3;
return find(m,flags);

} // find





StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

int  MergeLines(Line & d, const Line & s, const IdxTy ns)
{
for(IdxTy i=ns; i<s.size(); ++i) d.push_back(s[i]); 
return int(s.size())-int(ns);
}
IdxTy Merge(const Myt & that, const IdxTy flags) 
{
MM_ERR(" MERGING "<<MMPR2(that.m_vector_map.size(),m_vector_map.size()))
MM_ERR(" MERGING "<<MMPR4(that.m_data_idx,m_data_idx,that.m_vals,m_vals))
MergeFwd(that,0);
MergeBack(that,0);
//that.MergeBack(*this,1);

return 0;
}
IdxTy MergeFwd(const Myt & that, const IdxTy flags) 
{
const bool back=false; // Bit(flags,0);
const bool idx_ok=(m_data_idx==that.m_data_idx);
if (!idx_ok)
{
{MM_ERR( "unsable to merge "<<MMPR4(m_data_idx,that.m_data_idx,m_vals,that.m_vals)) ; } 
return ~0;
}
// also need to update dest vals without source... 
typedef mjm_loo_parsing<Tr>  Loo;
MM_LOOP(ii,m_vector_map)
{
const Entries & these=(*ii).second;
if (these.size()!=1)
{
MM_ERR(" non unque key "<<MMPR2(these.size(),Loo::Dump((*ii).first)))
continue; // return ~0; 
}
const Entries & those=that.Find((*ii).first,0); 
const IdxTy ths=those.size();
const bool okths=(ths==1)&&!back;
if (okths)
{
//const IdxTy nthat = that.m_vals;
//for(IdxTy i=0; i<nthat; ++i) m_r[these[0]].push_back("0"); 
MergeLines(m_r[these[0]],that.m_r[those[0]],m_data_idx); 
} else
{
//MM_ERR(" non unque key "<<MMPR3(back,those.size(),Loo::Dump((*ii).first)))
const IdxTy nthat = that.m_vals;
for(IdxTy i=0; i<nthat; ++i) m_r[these[0]].push_back("0"); 
//MergeLines(m_r[these[0]],that.m_r[those[0]],m_data_idx); 
continue; 
}// ths 
} // ii 
// now need missing keys from source...
return 0; 
} // MergeFwd

IdxTy MergeBack(const Myt & that, const IdxTy flags) 
{
//const bool back=Bit(flags,0);
const bool idx_ok=(m_data_idx==that.m_data_idx);
if (!idx_ok)
{
{MM_ERR( "unsable to merge "<<MMPR4(m_data_idx,that.m_data_idx,m_vals,that.m_vals)) ; } 
return ~0;
}
// also need to update dest vals without source... 
typedef mjm_loo_parsing<Tr>  Loo;
// this is to get keesp from that ... 
MM_LOOP(ii,that.m_vector_map)
{
const Entries & these=(*ii).second;
if (these.size()!=1)
{
MM_ERR(" non unque key "<<MMPR2(these.size(),Loo::Dump((*ii).first)))
continue; // return ~0; 
}
const Entries & those=Find((*ii).first,0); 
const IdxTy ths=those.size();
const bool okths=(ths==0);
if (okths)
{
Line lnew;
for(IdxTy i=0; i<m_data_idx; ++i) lnew.push_back(that.m_r[these[0]][i]); 
for(IdxTy i=0; i<m_vals; ++i) lnew.push_back("0"); 
// need to index too 
Line vkey;
for(IdxTy i=0; i<m_data_idx; ++i) vkey.push_back(lnew[i]); 
m_vector_map[vkey].push_back(m_r.size()); 
m_r.add(lnew);
MergeLines(m_r[m_r.size()-1],that.m_r[these[0]],m_data_idx); 
MM_ERR(" adding missing key  key "<<MMPR2(those.size(),Loo::Dump((*ii).first)))
continue;
} else
{
//MM_ERR(" non unque key "<<MMPR2(those.size(),Loo::Dump((*ii).first)))
continue; 
}// ths 
} // ii 
// now need missing keys from source...
return 0; 
} // MergeBack



const Entries &  NoEntries( ) const 
{
static Entries s;
return s; 
}
const Entries &  Find( const Line & x, const IdxTy flags) const 
{
if (m_vector_map.size())
{
std::vector<StrTy> vkey;
for(IdxTy i=0; i<m_data_idx; ++i) vkey.push_back(x[i]); 
auto ii=m_vector_map.find(vkey);
if (ii==m_vector_map.end()) return NoEntries();
return (*ii).second;
}

return NoEntries();

} // Find 

Values Find(QueryMap & midx, const IdxTy flags)
{
std::vector<Entries> e;
if (false) { MM_LOOP(ii,midx) { StrTy x=(*ii).second; x=StrTy(".")+x+StrTy(".");  MM_ERR(MMPR3((*ii).first,(*ii).second,x)) }
}

MM_LOOP(ii,midx)
{
const StrTy &mn=(*ii).first;
const StrTy &va=(*ii).second;
if (m_maps.find(mn)==m_maps.end()) 
{ Ss ss; ss<<"Missing "<<MMPR2(mn,va); MM_ERR(MMPR(ss.str()))  throw ss.str(); } 
auto jj=m_maps[mn].find(va);
if (jj!=m_maps[mn].end()) e.push_back((*jj).second);
else return Values(); // nothing there... 
} // ii 

return AndEntries(e);
}
Values AndEntries(const std::vector<Entries> & e)  const
{
Values v;
const IdxTy sz=e.size();
MM_ERR("entries size "<< MMPR(sz))
if (sz==0) return v; 
std::vector<IdxTy> pos;
IdxTy szmin=~0;
for(IdxTy i=0; i<sz; ++i) {
const IdxTy szi=e[i].size(); 
if (szi<szmin) szmin=szi;  pos.push_back(0); 
MM_ERR(MMPR3(szi,i,szmin))
} // i 
//for(IdxTy i=0; i<szmin; ++i) {
while (true) {
// see if the current pos is in all of them... 
const IdxTy vc=e[0][pos[0]];
IdxTy j=1;
for(; j<sz; ++j) {
while (e[j][pos[j]]<vc) { MM_ERR(MMPR4(j,pos[j],e[j][pos[j]],vc))  ++pos[j]; if (pos[j]>=e[j].size()) return v;; } 
if (e[j][pos[j]]>vc) { break; }  // this loop is futile 
} // j 
if (j==sz) v.push_back(m_r[vc][m_data_idx]);
MM_ERR(" matches "<< MMPR3(j,sz,v.size()))
++pos[0];
if (pos[0]>=e[0].size()) break; 
} // true  // i 
return v;
} // AndEntries

// TODO FIXME  this really needs tokenized indicies ... 
IdxTy Load(const Ragged & r, const Names nidx, const IdxTy flags)
{
const IdxTy ns=nidx.size();
const bool index_maps=!Bit(flags,0);
const bool index_vector=Bit(flags,1);
if (index_vector)
{
MM_SZ_LOOP(j,r,sz)
{
std::vector<StrTy> vkey;
const IdxTy len=r[j].size();
if (len>m_vals) m_vals=len; 
if (len<ns) continue;
for(IdxTy i=0; i<ns; ++i) vkey.push_back(r[j][i]); 
m_vector_map[vkey].push_back(j); 
} // j 
//m_vals=m_vals-ns;
} // index_Vector
m_data_idx=ns;
IdxTy pos=0;

if (index_maps)
{
MM_LOOP(ii,nidx)
{
const StrTy & nm=(*ii);
//MM_ERR(" index "<<MMPR(nm))
auto & m=m_maps[nm];
MM_SZ_LOOP(j,r,sz)
{
const auto & l=r[j];
//if (l.size()<=pos) continue;
//MM_ERR(MMPR2(l.size(),m_data_idx))
const IdxTy len=l.size();
if (len>m_vals) m_vals=len; 
if (len<=m_data_idx) continue;
m[l[pos]].push_back(j);
//MM_ERR(" indexed "<<MMPR3(l[pos],pos,j))
} // j 

//MM_ERR(" done load "<<MMPR2(pos,m.size()))
++pos;
} // ii 
} // index_maps;
if (m_vals) m_vals=m_vals-ns;
m_names=nidx;
MM_ERR(" done load "<<MMPR2(m_vals, m_maps.size()))
return 0;
} // Load



IdxTy Load(const StrTy fn, const Names nidx, const IdxTy flags)
{
// load as nidx parsed fields followed by a literal data filed
const IdxTy ns=nidx.size();
MM_ERR(MMPR2(ns,fn))
m_r.load_params(ns,1," ");
m_r.load(fn,0);
MM_ERR(MMPR(m_r.dump()))
return Load(m_r,nidx,flags); 
} // Load


void Init()
{
m_data_idx=0;
m_vals=0;
} 
// MEMBERS

Ragged m_r;
IndexMaps m_maps;
VectorIndexMaps m_vector_map;
Names m_names;
IdxTy m_data_idx,m_vals;
}; // mjm_indexed_ragged

//////////////////////////////////////////////

template <class Tr>
class mjm_indexed_ragged_map : public std::map<typename Tr::StrTy, mjm_indexed_ragged< Tr > >  
{
 typedef mjm_indexed_ragged_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_indexed_ragged< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_indexed_ragged_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_indexed_ragged_map




////////////////////////////////////////////
#ifdef  TEST_MJM_INDEXED_RAGGED
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_indexed_ragged <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_INDEXED_RAGGED "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_indexed_ragged<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
std::vector<StrTy>  names;
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load(cip.p1,names,0); }
else if (cmd=="name") { names.push_back(cip.p1); }
else if (cmd=="query") {
std::vector<StrTy> xx;
for(IdxTy i=1; i<li.words().size(); ++i) xx.push_back(li.word(i)); 
std::map<StrTy, StrTy> m;
for(IdxTy i=0; i<xx.size(); ++i) m[names[i]]=xx[i];
auto ff= x.find(m,0); 
MM_LOOP(ii,ff) {MM_ERR(MMPR((*ii))); } 
}
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_INDEXED_RAGGED_H__ 
