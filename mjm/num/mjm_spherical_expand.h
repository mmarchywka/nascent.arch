#ifndef MJM_SPHERICAL_EXPAND_H__
#define MJM_SPHERICAL_EXPAND_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_legendre_stuff.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun Jan  5 14:54:37 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_spherical_expand   
// g++ -std=gnu++11 -DTEST_MJM_SPHERICAL_EXPAND -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_spherical_expand.h  -lpthread -lreadline

template <class Tr>
class mjm_spherical_expand 
{
 typedef mjm_spherical_expand Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef D Coef ;

class term_coef
{
public:
term_coef(const IdxTy _l, const int _m, const Coef & _g, const Coef & _h)
:l(_l),m(_m),g(_g),h(_h) {}
IdxTy l;
int m;
Coef g,h;

}; // term_coef
typedef term_coef TermCoef;
typedef std::vector<TermCoef> TermCoefs;

public:
mjm_spherical_expand() {}
~mjm_spherical_expand() {}
void push_term(const IdxTy _l, const int _m, const Coef & _g, const Coef & _h)
{m_terms.push_back( term_coef(_l,_m, _g, _h)) ; } 
void set_scale(const Coef & a) { m_a=a; } 
void clear_terms() { m_terms.clear(); } 
template <class Tleg>
Coef term(const TermCoef & tc, const Coef & r, const Coef & theta, const Coef & phi, Tleg & leg)
{
return Term(tc, r,  theta,  phi,leg);
}

template <class Tleg>
Coef point( const Coef & r, const Coef & theta, const Coef & phi, Tleg & leg)
{ return Point( r,  theta,  phi,leg); }

template <class Tleg>
IdxTy  field( D & b_r, D & b_theta, D & b_phi,  const Coef & r, const Coef & theta, const Coef & phi, Tleg & leg)
{ return Field(b_r,b_theta,b_phi, r,  theta,  phi,leg); }



StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
template <class Tleg>
Coef Term(const TermCoef & tc, const Coef & r, const Coef & theta, const Coef & phi, Tleg & leg)
{
Coef d=0;
const IdxTy l=tc.l;
const int m=tc.m;
const Coef cp=cos(m*phi);
const Coef sp=sin(m*phi);
// all this crap factors out for arrays of points doh. 
const Coef phcs=tc.g*cp+tc.h*sp;
Coef ar=pow(m_a/r,l+1);
Coef le=leg.eval(theta,l,m,0);
return d*m_a*ar*le*phcs;
}
template <class Tleg>
Coef Point( const Coef & r, const Coef & theta, const Coef & phi, Tleg & leg)
{
Coef d=0;
MM_LOOP(ii,m_terms) d+=Term((*ii),r,theta,phi,leg);
return d;
}

/*
// for earth, copied from the geomag70.c download from
//stefan.maus@noaa.gov
IGRF12 is the twelfth generation standard main field model adopted 
by the International Association of Geomagnetism and Aeronomy (IAGA).  
This is a degree and order 10 model from 1900 to 1995 and a degree and
order 13 model from 2000 to 2015, providing estimates of the main field 
for dates between January 1, 1900 and January 1, 2015. For more information 
on the IGRF and IAGA, visit the IAGA Working Group V-MOD Web site at:
        http://www.ngdc.noaa.gov/IAGA/vmod/
WMM2010 is the standard model for the U.S. and U.K. Departments of Defense  
and for NATO, also used widely in civilian navigation systems. This is a 
degree and order 12 main field model for 2010.0 and degree and order 12 
secular variation model for 2010 - 2015. For more information on the WMM or 
to download the Technical Report, visit the WMM Web site at:
        http://www.ngdc.noaa.gov/geomag/WMM/
*/

void EllipsoidCorrection( D & _r, D & _st, D & _ct, const Coef & rin, const Coef & theta, const Coef & phi)
{
// this matches better but soe did pix=90 lol. 
const D pix=M_PI/2.0;
MM_ONCE(" stupid radius kluge is on doh ",)
Coef _stc=sin(pix-theta);
Coef _ctc=cos(pix-theta);
_r=rin;
const D Arad=6371.2;
const D a2 = 40680631.59;            /* WGS84 */
const D   b2 = 40408299.98;            /* WGS84 */
D elev= _r -Arad;
D clat=_ctc;
D slat=_stc;
D aa = a2 * clat * clat;
 D     bb = b2 * slat * slat;
 D     cc = aa + bb;
 D     argument = cc;
 D     dd = sqrt( argument );
      argument = elev * (elev + 2.0 * dd) + (a2 * aa + b2 * bb) / cc;
      _r = sqrt( argument );
     D cd = (elev + dd) / _r;
D      sd = (a2 - b2) / dd * slat * clat / _r;
      aa = slat;
      slat = slat * cd - clat * sd;
      clat = clat * cd + aa * sd;
// these are now the colatitude values, 
// angle in radians - TODO something more clever here doh 
D fudd=atan2(slat,clat);
// convert back to co-latitutde 
_st=sin(pix-fudd); // slat;
_ct=cos(pix-fudd); // clat;
// angle in radians

}
///////////////////////////////////////////////////////////////////


template <class Tleg>
IdxTy  Field( D & b_r, D & b_theta, D & b_phi,  const Coef & rin, const Coef & theta, const Coef & phi, Tleg & leg)
{ 

b_r=0;
b_theta=0;
b_phi=0;
// this is a waste right now if the correction is used
// although using trig identity not so bad... 
Coef _st=sin(theta);
Coef _ct=cos(theta);
Coef _r=rin;
// these apparently need to be corrected for ellipsoid, not sure
// what that does to C^2 + S^2 =1 wtf 
// copy from the geomag70 code AFAICT,
const bool radius_kluge=true;
// this code apparently works on LATITUTDE NOT co-latitutde 
if (radius_kluge)
{ 
EllipsoidCorrection( _r, _st, _ct, rin,  theta,  phi);

}
else { MM_ONCE(" stupid eliipsoid  radius kluge is off doh ",) } 

const Coef st=_st;
const Coef ct=_ct;
const Coef r=_r;
const Coef sc=m_a/r;
MM_LOOP(ii,m_terms)
{
const TermCoef & tc=(*ii);
const IdxTy l=tc.l;
const int m=tc.m;
// need to sort terms and cache these things.. 
const Coef cp=cos(m*phi);
const Coef sp=sin(m*phi);
Coef le=leg.eval(ct,st,l,m,0);
Coef legr=leg.eval(ct,st,l,m,1);

const Coef ar=pow(sc,l+1);
const Coef tphi=tc.g*cp+tc.h*sp;
const Coef dtphi=-m*tc.g*sp+m*tc.h*cp;
// MM_ERR(MMPR3(ar,tphi,dtphi)<<MMPR4(cp,sp,le,legr))
b_r+= -ar*tphi*le*(l+1)/r;
b_phi+=ar*dtphi*le/(r*st);   
b_theta+=ar*tphi*legr/r;
}
b_r*=m_a;
b_theta*=m_a;
b_phi*=m_a;
return 0; 
} // Field




//////////////////////////////////////////////////////////////////
template <class Tleg>
IdxTy  FieldOld( D & b_r, D & b_theta, D & b_phi,  const Coef & rin, const Coef & theta, const Coef & phi, Tleg & leg)
{ 

b_r=0;
b_theta=0;
b_phi=0;
Coef _st=sin(theta);
Coef _ct=cos(theta);
Coef _r=rin;
// these apparently need to be corrected for ellipsoid, not sure
// what that does to C^2 + S^2 =1 wtf 
// copy from the geomag70 code AFAICT,
const bool radius_kluge=true;
// this code apparently works on LATITUTDE NOT co-latitutde 
if (radius_kluge)
{ 
// this matches better but soe did pix=90 lol. 
const D pix=M_PI/2.0;
MM_ONCE(" stupid radius kluge is on doh ",)
Coef _stc=sin(pix-theta);
Coef _ctc=cos(pix-theta);
// _r=rin;
const D Arad=6371.2;
const D a2 = 40680631.59;            /* WGS84 */
const D   b2 = 40408299.98;            /* WGS84 */
D elev= _r -Arad;
D clat=_ctc;
D slat=_stc;
D aa = a2 * clat * clat;
 D     bb = b2 * slat * slat;
 D     cc = aa + bb;
 D     argument = cc;
 D     dd = sqrt( argument );
      argument = elev * (elev + 2.0 * dd) + (a2 * aa + b2 * bb) / cc;
      _r = sqrt( argument );
     D cd = (elev + dd) / _r;
D      sd = (a2 - b2) / dd * slat * clat / _r;
      aa = slat;
      slat = slat * cd - clat * sd;
      clat = clat * cd + aa * sd;
// these are now the colatitude values, 
// angle in radians - TODO something more clever here doh 
D fudd=atan2(slat,clat);
// convert back to co-latitutde 
_st=sin(pix-fudd); // slat;
_ct=cos(pix-fudd); // clat;
// angle in radians

}
else { MM_ONCE(" stupid eliipsoid  radius kluge is off doh ",) } 

const Coef st=_st;
const Coef ct=_ct;
const Coef r=_r;
const Coef sc=m_a/r;
MM_LOOP(ii,m_terms)
{
const TermCoef & tc=(*ii);
const IdxTy l=tc.l;
const int m=tc.m;
// need to sort terms and cache these things.. 
const Coef cp=cos(m*phi);
const Coef sp=sin(m*phi);
//Coef le=leg.eval(theta,l,m,0);
//Coef legr=leg.eval(theta,l,m,1);

Coef le=leg.eval(ct,st,l,m,0);
Coef legr=leg.eval(ct,st,l,m,1);

const Coef ar=pow(sc,l+1);
const Coef tphi=tc.g*cp+tc.h*sp;
const Coef dtphi=-m*tc.g*sp+m*tc.h*cp;
// MM_ERR(MMPR3(ar,tphi,dtphi)<<MMPR4(cp,sp,le,legr))
b_r+= -ar*tphi*le*(l+1)/r;
b_phi+=ar*dtphi*le/(r*st); // too big? 
//b_phi+=ar*dtphi*le/(r*sin(theta)); // too big? 
b_theta+=ar*tphi*legr/r;
}
// d+=Term((*ii),r,theta,phi,leg);
b_r*=m_a;
b_theta*=m_a;
b_phi*=m_a;
return 0; 
//return Field(b_r,b_theta,b_phi, r,  theta,  phi,leg); 
} // Field





bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }


TermCoefs m_terms;
Coef m_a;

}; // mjm_spherical_expand

//////////////////////////////////////////////

template <class Tr>
class mjm_spherical_expand_map : public std::map<typename Tr::StrTy, mjm_spherical_expand< Tr > >  
{
 typedef mjm_spherical_expand_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_spherical_expand< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_spherical_expand_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_spherical_expand_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SPHERICAL_EXPAND
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SPHERICAL_EXPAND "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_spherical_expand<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SPHERICAL_EXPAND_H__ 
