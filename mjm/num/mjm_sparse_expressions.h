#ifndef MJM_SPARSE_EXPRESSIONS_H__
#define MJM_SPARSE_EXPRESSIONS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_string_tokenizer.h"


#include "mjm_rods_array.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <unordered_map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri Jan 10 18:34:49 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_sparse_expressions   
// g++ -std=gnu++11 -DTEST_MJM_SPARSE_EXPRESSIONS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_sparse_expressions.h  -lpthread -lreadline


// should move the legendre hermite etc here or somewhere for rational
// classes... 
template <class Tr, class Tcoef=double>
class mjm_numerical_expansions 
{
 typedef mjm_numerical_expansions Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// note this could be rational or infinite integers,  make things simple 
typedef  Tcoef Coef;

class coef_tri_index{
public:
typedef Coef data_type;
// FIXME this is not right but seems to work leave gaps
// although l==0 seems to find something valid wtf?
static IdxTy size(const IdxTy lmax)  { return ((lmax+1)*(lmax+2))>>1; }
static IdxTy index(const IdxTy l,const int  m)
{ return  size(l)+(~m); }  // signed arthimetic, bacward store offset lol. 
}; // coef_tri_index
typedef mjm_rods_array<Tr,coef_tri_index> tri_cache_base;

class tri_cache : public tri_cache_base 
{
typedef tri_cache_base Super;
public:
typedef typename Super::data_type data_type;
data_type &  operator()(const IdxTy l, const int m )
{return ((Super*)(this))->operator()(coef_tri_index::index(l,m)); }
data_type &  operator()(const IdxTy n )
{ return ((Super*)(this))->operator()(n); } 
StrTy dump(const IdxTy flags)
{
Ss ss;
ss<< "Called the right code "<<Super::used()<<CRLF;
// why the FUDD can't it find this shot 
const IdxTy sz=Super::used();
for(IdxTy i=0; i<sz; ++i)
{
ss<<i<<" "<<(*this)(i).to_string()<<CRLF;
}
return ss.str();
}
}; // tri_cache
static IdxTy bi_cache_size() { static IdxTy sz=50; return sz; } 
static tri_cache & bi_cache()
{
static tri_cache x;
static IdxTy lmax=bi_cache_size();
static bool inited=false;
if (!inited)
{
x.size(coef_tri_index::size(lmax),1<<2);
for(IdxTy l=0; l<=lmax; ++l)
{
Coef res=1;
for(IdxTy m=0; m<=l; ++m)
{
x(l,m)=res;
res=res*(l-m)/(m+1);
} // m 
}
inited=true;
}

return x;
}



public:

// expand Cos^m(theta)Sin^n(theta) into a polynomial frequencies
// to allow analysis and easy integration. Note in general if n or m is
// odd, the things should integrate easily but this general case here
// does not care. For integrals often only the lower frequencies or DC
// will be nonzero and the rest is a waste
// 0 \leq l \leq m , 0 \leq j \leq n , w=l+j-(m+n)/2
// normalization ( 2^(n+m)(i)^n )^(-1) with sign intact
// but odd powers of i left to the user to deal with. 
Coef cmsn_norm(const IdxTy m, const IdxTy n ) { return CmsnNorm(m,n); }

Coef cmsn_w(const int twow, const IdxTy m, const IdxTy n )
{ return CmsnW(twow,m,n); } 

private:
Coef CmsnW(const int twow, const IdxTy m, const IdxTy n )
{
Coef c=Coef(0);
const int sum=m+n;
const int ssum=twow+m+n;
//const bool has_dc=((sum&1)==0);
// these are not fast for multi precision.but these are int doh . 
const bool has_dc=(((m|n)&1)==0);
const bool is_zer=((ssum&1)!=0);
//const bool is_zer=(((twow^sum)&1)!=((twow<0)?1:0));
//MM_ERR(MMPR4(is_zer,has_dc,m,n)<<MMPR(twow))
if (is_zer) return 0;
const int ssum1=ssum>>1;
int min=0;
int max=n;
int lmin=ssum1-max;
//if ( lmin<0) max-=lmin;
if ( lmin<0) max+=lmin;
int lmax=ssum1-min;
if (lmax>m) min+=lmax-m;
for(int j=min; j<=max; ++j)
{
int l=ssum1-j;
bool minus=(((n-j)&1)!=0);
const Coef dc=MyBi(n,j)*MyBi(m,l);
if (minus) c-=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
else c+=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
//MM_ERR(MMPR4(twow,m,n,minus)<<MMPR4(j,c,l,dc))

}
//if ((m+n)==0){  MM_ERR(" zero input returns "<<MMPR4(n,m,c,twow))}
return c;

} // CmsnW

#if 0 
Coef CmsnW_old(const int twow, const IdxTy m, const IdxTy n )
{
Coef c=Coef(0);
const int sum=m+n;
const bool has_dc=((sum&1)==0);
const bool is_zer=(((twow^sum)&1)!=0);
//const bool is_zer=(((twow^sum)&1)!=((twow<0)?1:0));
MM_ERR(MMPR4(is_zer,has_dc,m,n)<<MMPR(twow))
if (is_zer) return 0;
const int min12=twow+m-n;
const int max12=twow+m+n;
const int min1=SignExtend(min12,1); // (min12<0)?0:((min12)>>1);
const int max1=SignExtend(max12,1); // (max12<(0))?0:(max12>>1) ; // (twow+m+n)>>1;
const int min=(min1<0)?0:min1;
const int max=(max1>n)?n:max1;
//MM_ERR(MMPR4(min1,max1,min,max))
for(int j=min; j<=max; ++j)
{
bool minus=(((n-j)&1)!=0);
const int b1=((twow+sum)>>1)-j;
const Coef dc=MyBi(n,j)*MyBi(m,b1);
if (minus) c-=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
else c+=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
//MM_ERR(MMPR4(j,c,b1,dc))

}
if ((m+n)==0){  MM_ERR(" zero input returns "<<MMPR4(n,m,c,twow))}
return c;

} // CmsnW

#endif


int SignExtend(const int x, const IdxTy b)
{
if (x==0) return 0 ;
if (x>0) return x>>b;
return (x>>b)|(~(~0)>>b);

}
// I hate writing like this if there will be rationals... 
Coef CmsnNorm(const IdxTy m, const IdxTy n ) { 
if ((n+m)==0) return 1;
//if ((n&2)==0) return  ::pow(.5,n+m); 
//else return  -::pow(.5,n+m); 
if ((n&2)==0) return  Coef2n(n+m); 
else return  -Coef2n(n+m); 
}

Coef & Coef2n(const IdxTy p)
{
static std::vector<Coef> p2;
if (p2.size()==0) p2.push_back(Coef(1));
while (p>=p2.size())
{ p2.push_back(p2.back()/2); }

return p2[p];
}


/// uh, this is n chose k so n is bigger than k... 
Coef MyBi(const int n, const int k)
{
if (n<=bi_cache_size()) { return bi_cache()(n,k); } 
const int k2=n-k;
int max=(k2>k)?k2:k;
if (max==0) max=1;
const int min=(k2<k)?k2:k;
Coef p=Coef(1);
//for(int j=max; j<=k; ++j) p=p*j;
for(int j=max+1; j<=n; ++j) p=p*j;
Coef d=Coef(1);
for(int j=2; j<=min; ++j) d=d*j;
//MM_ERR(MMPR4(n,k,(p/d),p))
return p/d;

}


}; //  mjm_numerical_expansions 

template <class Tr, class Tcoef=double>
class mjm_sparse_expressions 
{
 typedef mjm_sparse_expressions Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// note this could be rational or infinite integers,  make things simple 
typedef  Tcoef Coef;

typedef mjm_numerical_expansions<Tr,Coef> Expander;

typedef string_tokenizer Tokenizer;
typedef std::map<IdxTy,Coef> NomialValues;
typedef std::map<IdxTy,IdxTy> RefCounts;

public:
class special_case_flags
{
typedef  special_case_flags Myt;
typedef std::vector<IdxTy> Vars;
typedef std::vector<int> Counts;
typedef std::vector<StrTy> VarNames;
typedef string_tokenizer St;
public:
special_case_flags(const IdxTy code) : m_code(code),m_create(code>CREATE_BASE),m_stp(0) {}
IdxTy special_case() const { return m_code; } 
IdxTy code() const { return m_code; } 
int var(const IdxTy i) const { return m_vars[i]; } 
int count(const IdxTy i) const { return m_counts[i]; } 
Myt & push_count(const int i ) { m_counts.push_back(i); return *this; } 
const StrTy  var_name(const IdxTy i) const { return m_var_names[i]; } 
Myt & push_var(const IdxTy i ) { m_vars.push_back(i); return *this; } 
Myt & push_var(const StrTy & i ) { m_var_names.push_back(i); return *this; } 
const IdxTy var_size() const { return m_vars.size();  }
const IdxTy names_size() const { return m_var_names.size();  }
bool create() const { return m_create; } 
St * st() { return m_stp;} 
void  st(St * s) { m_stp=s;} 

enum {
TRIG_POLY_ZERO_PI,
TRIG_POLY_ZERO_2PI,
GTRIG_POLY_ZERO_PI,
GTRIG_POLY_ZERO_2PI,


CREATE_BASE,
CREATE_MSIN_POLY,
EOE
};
StrTy dump()
{
Ss ss;

return ss.str();
}
private:

IdxTy m_code;
VarNames m_var_names;
Vars m_vars;
bool m_create;
Counts m_counts;
St * m_stp;

}; // special_case_flags

typedef special_case_flags SpecParams;
private:
// this should use a string tokenizer but normally speed or size not 
// a factor, it is annoying to use strings ... 
#include "mjm_nomial_term_nodef.h"
#if 0 
}; // nomial_term
#endif

typedef nomial_term Term;

#include "mjm_term_heap_nodef.h"
#if 0 
}; // term_heap
#endif

typedef term_heap<Term>  TermHeap;

#include "mjm_multinomial_thing_nodef.h"
#if 0 
}; // multinomial_thing

#endif

typedef multinomial_thing Nomials;

#include "mjm_nomial_group_nodef.h"
#if 0 
class nomial_group
}; // nomial_group
#endif

typedef nomial_group MyMultiNomials;
typedef nomial_families MyMultiNomialFamilies;
public:
mjm_sparse_expressions() {}
~mjm_sparse_expressions() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; ss<<m_mn.dump(flags);  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
public:
 MyMultiNomials m_mn;
MyMultiNomialFamilies m_families;
}; // mjm_sparse_expressions

//////////////////////////////////////////////

template <class Tr>
class mjm_sparse_expressions_map : public std::map<typename Tr::StrTy, mjm_sparse_expressions< Tr > >  
{
 typedef mjm_sparse_expressions_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_sparse_expressions< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_sparse_expressions_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_sparse_expressions_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SPARSE_EXPRESSIONS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SPARSE_EXPRESSIONS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef double D;
typedef mjm_sparse_expressions<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.m_mn.dump(cip.myatoi(cip.p1))) }
if (cmd=="refs") { MM_ERR(x.m_mn.dump_refs(0)) }
if (cmd=="add") { 
//std::map<StrTy, unsigned int > vv;
std::map<StrTy, int > vv;
const StrTy & nomial=cip.p1;
const D coef=atof(cip.p2.c_str());
IdxTy i=4;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=cip.myatoi(cip.words()[i].c_str());  i+=2; }
 x.m_mn.add_term(nomial.c_str(),vv,coef);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="eval") { 
std::map<StrTy, double > vv;
const StrTy & nomial=cip.p1;
//const D coef=atof(cip.p2.c_str());
IdxTy i=3;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=atof(cip.words()[i].c_str());  i+=2; }
MM_ERR(MMPR( (x.m_mn.evaluate(nomial.c_str(),vv))));
//MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="evaled") { 
std::map<StrTy, double > vv;
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
//const D coef=atof(cip.p2.c_str());
IdxTy i=4;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=atof(cip.words()[i].c_str());  i+=2; }
//MM_ERR(MMPR( (x.m_mn.evaluated(srcnomial.c_str(),vv))));
x.m_mn.evaluate_to(destnomial.c_str(),srcnomial.c_str(),vv);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="diffint") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & var=cip.wif(3);
const IdxTy flags =cip.myatoi(cip.wif(4));
//MM_ERR(MMPR( (x.m_mn.evaluated(srcnomial.c_str(),vv))));
x.m_mn.diff_int(destnomial.c_str(),srcnomial.c_str(),var.c_str(),flags);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="+") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.add(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="-") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.subtract(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="*") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.multiply(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }

//void  substitute(const char * d, const char * s, const char * var, const char * sv, const IdxTy flags )
if (cmd=="sub") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & var=cip.wif(3);
const StrTy & src2nomial=cip.wif(4);
const IdxTy flags =cip.myatoi(cip.wif(5));
x.m_mn.substitute(destnomial.c_str(),srcnomial.c_str(),var.c_str(),src2nomial.c_str(),flags);
MM_ERR(x.m_mn.dump(0))
 }

//void diff_int(const char *d , const char *s, const char *var, const IdxTy flags)
if (cmd=="?") { 
std::ostream &  os=std::cout;
os<<" dump flags "<<CRLF;
os<<" refs "<<CRLF;
os<<" add nomial coef var val var val ...  "<<CRLF;
os<<" eval nomial var val var val ...  "<<CRLF;
os<<" evaled destnomial srcnomial var val var val ...  "<<CRLF;
os<<" diffint destnomial srcnomial var flags  "<<CRLF;
os<<" + destnomial srcnomial src2nomial  "<<CRLF;
os<<" - destnomial srcnomial src2nomial  "<<CRLF;
os<<" * destnomial srcnomial src2nomial  "<<CRLF;
os<<" sub destnomial srcnomial var exprnomial  "<<CRLF;
}

//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SPARSE_EXPRESSIONS_H__ 
