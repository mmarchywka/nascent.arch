#ifndef MJM_LEG_INTEGRALS_H__
#define MJM_LEG_INTEGRALS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_legendre_stuff.h"
#include "mjm_sparse_expressions.h"

#include "mjm_tabulated_functions.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <unordered_map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Jan  9 05:07:38 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_leg_integrals   
// g++ -std=gnu++11 -DTEST_MJM_LEG_INTEGRALS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_leg_integrals.h  -lpthread -lreadline

template <class Tr,class Tdata=double,class Tcoef=double>
class mjm_leg_integrals 
{
 typedef mjm_leg_integrals Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
//typedef double Coef;
typedef mjm_tab_data_spec<Tr> OutSpec ;
typedef Tcoef Coef;
typedef std::vector<Coef> CoefVec;
class argsx {
public:
Coef theta,phi,ctheta,cphi,stheta,sphi,x,d_dot_r;

}; // args
typedef std::vector<argsx> ArgCache;
//typedef mjm_legendre_stuff<Tr,double>  Legendres;
typedef mjm_legendre_stuff<Tr,Tdata>  Legendres;

typedef mjm_sparse_expressions<Tr,Coef> SpEx;
typedef typename SpEx::special_case_flags SpFlags;

typedef mjm_tabulated_functions<Tr,Coef> FuncTab;
typedef typename FuncTab::Ragged Ragged;
typedef mjm_eval_var_cache<Tr,Coef> EvalVarBase;
//class mjm_leg_integrals; 
class eval_var : public EvalVarBase
{
typedef eval_var Myt;
typedef EvalVarBase Super;
//typedef mjm_leg_integrals Iface;
typedef Legendres Iface;
public:
eval_var(Iface * iface, string_tokenizer * stp, CoefVec * p ) : Super(stp),m_iface(iface)
, m_r0_vec(p) {}
virtual Coef scale_factor(const IdxTy l, const int m,const int gh ) 
{ 
return (*m_r0_vec)[l-1];

//return Coef(1); 
} 


Iface * m_iface;
CoefVec * m_r0_vec;
}; // eval_var

typedef eval_var EvalVar;

public:

mjm_leg_integrals(Legendres & l ):m_leg(l),m_eval_var(&m_leg,m_func_tab.st(),&m_r0_powers)  {Init(); }
~mjm_leg_integrals() {}
// for fitting coefs to a displaced oriented dipole source responsible
// for all model coefs
void set_dipole(const Coef & d, const Coef & alpha, const Coef & beta)
{ SetDipole(d,alpha,beta); } 
//Coef m_r0, m_gamma,m_delta;
void get_offset(Coef & d,  Coef & alpha,  Coef & beta)
{d= m_r0;alpha= m_gamma; beta=m_delta; } 
void get_dipole(Coef & d,  Coef & alpha,  Coef & beta)
{d= m_d;alpha= m_alpha; beta=m_beta; } 

void set_offset(const Coef & d, const Coef & alpha, const Coef & beta)
{ SetOffset(d,alpha,beta); } 
void points(const IdxTy ntheta, const IdxTy nphi, const Coef & theta0, 
const Coef & phi0)
{
m_ntheta=ntheta; m_nphi=nphi; m_theta0=theta0; m_phi0=phi0;
}
void cache_points(const IdxTy flags )  { CachePoints(); CacheEvalVar(flags); }
void cache_values(const IdxTy lmax,const IdxTy flags){  CacheValues( lmax,flags) ; }

Coef evaluate_g(const IdxTy lp, const IdxTy mp,const bool gnoth)
{ return EvaluateG(lp,mp,gnoth); } 
Coef evaluate_g_a(const IdxTy lp, const IdxTy mp,const bool gnoth)
{ return EvaluateGA(lp,mp,gnoth); } 
Coef evaluate_g_tab(const IdxTy lp, const IdxTy mp,const bool gnoth)
{ return EvaluateGTab(lp,mp,gnoth); } 


//Coef IntegrateACache(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
Coef evaluate_g_a_piece(OsTy& os, OutSpec & outs, const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp,const IdxTy piece)
{ return IntegrateACachePiece(os,outs,l,m,lp,mp,piece); } 

void load_func_tab(Ragged & r, const IdxTy flags) {m_func_tab.load(r,flags); }
void cache_families_from_func_tab(const IdxTy lmax, const IdxTy flags )
{ CacheFamiliesFromFuncTab(lmax, flags ); }

StrTy print_multi(const StrTy & fam, const IdxTy lp,const int mp, const IdxTy flags )
{ return PrintMulti(fam, lp, mp, flags); }

template <class Td, class Tc, class Tp>
void evaluate_gradients( Td & res, Tc& coefs, Tp & points)
{ EvaluateGradients(  res, coefs, points); }
template <class Tc> 
void evaluate_gradients( Coef & dr, Coef & dtheta, Coef & dphi,  const Coef & r,const  Coef & theta, const  Coef & phi, Tc& coefs) { 
EvaluateGradients(  dr,  dtheta,  dphi,   r, theta,  phi, coefs);
}

template <class Td, class Tc, class Tp>
void evaluate_pot( Td & res, Tc& coefs, Tp & points)
{ EvaluatePot(  res, coefs, points); }
//template < class Tc>
template < class Tc>
void evaluate_pot( Coef & pos,const Coef & r, const Coef & theta, const Coef & phi,  const Tc& coefs)
{ EvaluatePot(  pos, r, theta,  phi, coefs); }
template < class Tc>
Coef evaluate_pot( const Coef & r, const Coef & theta, const Coef & phi,  const Tc& coefs)
{Coef pos=0;  EvaluatePot(  pos, r, theta,  phi, coefs); return pos; }


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// this is used with my models, there is other code for the 
// internaiotnal model files but they should be the same at this point 
template <class Td, class Tc, class Tp>
void EvaluateGradients( Td & res, Tc& coefs, Tp & points)
{

// this is dumb for now, points can cache a lot of trigs
MM_LOOP(ii,points)
{
Coef gr=0;
Coef gtheta=0;
Coef gphi=0;
MM_LOOP(jj,coefs)
{
EvaluateDGradient
(gr, gtheta, gphi, (*ii).r, (*ii).theta, (*ii).phi, (*jj).l, (*jj).m, (*jj).g, (*jj).h);

} // jj coefs
typename Td::value_type p;
p.gr=gr;
p.gtheta=gtheta;
p.gphi=gphi;

//res.push_back(typename Td::value_type(gr,gtheta,gphi));
res.push_back(p);
} // ii  points

} // EvaluateGradients

template <class Tc> 
void EvaluateGradients( Coef & dr, Coef & dtheta, Coef & dphi,  const Coef & r,const  Coef & theta, const  Coef & phi, Tc& coefs)
{
Coef gr=0;
Coef gtheta=0;
Coef gphi=0;
MM_LOOP(jj,coefs)
{
EvaluateDGradient
(gr, gtheta, gphi, r, theta, phi, (*jj).l, (*jj).m, (*jj).g, (*jj).h);

} // jj coefs
//typename Td::value_type p;
dr=gr;
dtheta=gtheta;
dphi=gphi;

} // EvaluateGradients




template <class Td, class Tc, class Tp>
void EvaluatePot( Td & res, Tc& coefs, Tp & points)
{

// this is dumb for now, points can cache a lot of trigs
MM_LOOP(ii,points)
{
Coef pot=0;
//EvaluatePot(pot,  (*ii).r, (*ii).theta, (*ii).phi, coefs);
MM_LOOP(jj,coefs)
{
EvaluatePot
(pot, (*ii).r, (*ii).theta, (*ii).phi, (*jj).l, (*jj).m, (*jj).g, (*jj).h);

} // jj coefs
typename Td::value_type p;
p=pot;
//p.gr=gr;
//p.gtheta=gtheta;
//p.gphi=gphi;
//res.push_back(typename Td::value_type(gr,gtheta,gphi));
res.push_back(p);
} // ii  points

} // EvaluatePot

template < class Tc>
void EvaluatePot( Coef & pot,const Coef & r, const Coef & theta, const Coef & phi,  const Tc& coefs)
{
MM_LOOP(jj,coefs)
{
EvaluatePot
(pot, r, theta, phi, (*jj).l, (*jj).m, (*jj).g, (*jj).h);

} // jj coefs


} // EvaluatePot

// 1/r^(l+1)
void EvaluateDGradient(Coef & gr, Coef & gtheta, Coef & gphi, const Coef & r
, const Coef & theta, const Coef & phi,const IdxTy l, const IdxTy m , const Coef & g, const Coef & h)
{
// theta, l,m,der
const Coef P=m_leg.eval(theta,l,m,0);
const Coef dPdx=m_leg.eval(theta,l,m,1);
const Coef cp=cos(m*phi);
const Coef sp=sin(m*phi);
const Coef xphi=g*cp+h*sp;
const Coef dxphi=m*(h*cp-g*sp);
const Coef xr=::pow(r,-(l+1));
const Coef dxr=-xr/r*(l+1); // *xphi*P;
gr+=dxr*xphi*P;
gtheta+=dPdx*xphi*xr/r;
gphi+=dxphi*P*xr/r/sin(theta);
//MM_ERR(MMPR4(dxr,xphi,P,r))

} 
void EvaluatePot(Coef & pot,  const Coef & r
, const Coef & theta, const Coef & phi,const IdxTy l, const IdxTy m , const Coef & g, const Coef & h)
{
//MM_ERR(" SHOT FUDD ASS "<<MMPR3(theta,l,m))
// theta, l,m,der
const Coef P=m_leg.eval(theta,l,m,0);
//const Coef dPdx=m_leg.eval(theta,l,m,1);
const Coef cp=cos(m*phi);
const Coef sp=sin(m*phi);
const Coef xphi=g*cp+h*sp;
//const Coef dxphi=m*(h*cp-g*sp);
const Coef xr=::pow(r,-(l+1));
//MM_ERR(" SHOT FUDD ASS "<<MMPR3(xr,xphi,cp))
pot+=xr*xphi*P;
//const Coef dxr=-xr/r*(l+1); // *xphi*P;
//gr+=dxr*xphi*P;
//gtheta+=dPdx*xphi*xr/r;
//gphi+=dxphi*P*xr/r/sin(theta);
//MM_ERR(MMPR4(dxr,xphi,P,r))

} 



Coef Integrate(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
{
Coef I=0;
const Coef dtr=M_PI/180.0;
Coef kluge=.5;
Coef da=2*kluge*M_PI*M_PI/(m_ntheta*m_nphi);
//Coef nm=((m==0)? .5:.25)*(2*l+1);
//Coef nm=((mp==0)? .5:.25)*(2*lp+1);
// phi integration adds another half for dc 
Coef nm=(.25)*(2*lp+1);
// TODO check that this is right for the assumptions... 
Coef s= m_leg.schmidt_normalization(lp,mp);
if ((l+1)>=m_r0_powers.size())
{MM_ERR(" not enough powers "<<MMPR2(l,m_r0_powers.size())) }
// this seems to produce .666 for dipole 1 at origin... 
// forgot the normalizations doh 
Coef  N=da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//MM_ERR(MMPR4(l,m,lp,mp))

MM_LOOP(ii,m_cache)
{
const auto & z=(*ii);
const auto & x=z.x;
const auto & cost=z.ctheta;
const auto & sint=z.stheta;
//MM_ERR(MMPR3(x,z.theta,z.phi))
// this is the - summing over l here allows prior l
// value to become l-1 in next iterartion.. 
const Coef t1=m_leg.eval_no_sine(x,l,1);
// when l==1, this is not valid. 
const Coef t2=(l==1)?0:m_leg.eval_no_sine(x,l-1,1);
const Coef t3=m_leg.eval(cost,sint,lp,mp,0);
// this needs to use c_M_phi doh... 
// AND commute the points with l,m summation... 
const Coef dI=sint*(gnoth?cos(mp*dtr*z.phi):sin(mp*dtr*z.phi))*(z.d_dot_r*t1-d_dot_r0*t2)*t3;
//MM_ERR(MMPR3(dI,x,l)<<MMPR3(t1,t2,t3))
I+=dI;
}
//MM_ERR(MMPR3((I*N),I,N)<<MMPR4(l,m,lp,mp))
return I*N;
} // Integrate
/////////////////////////////////////////////////////////
StrTy PrintMulti(const StrTy & fam, const IdxTy lp,const int mp, const IdxTy flags )
{
auto & spex=m_spex.m_families;
return spex.multinomial(fam.c_str(),lp,mp).dump(flags);
}

void CacheFamilies(const IdxTy lmax, const IdxTy flags )
{
typedef std::vector<Coef> InPoly;
typedef std::map<StrTy,int> PowMap;
const bool avoid_schmidt=Bit(flags,2);
auto & spex=m_spex.m_families;
spex.clear_scratch();
MM_ERR("making msinp mcosp cache "<<MMPR(avoid_schmidt))
for(int mp=0; mp<=lmax; ++mp)
{
spex.clear_scratch();
SpFlags sp_scphi(SpFlags::CREATE_MSIN_POLY);
sp_scphi.push_var(StrTy("cphi"));
sp_scphi.push_var(StrTy("sphi"));
sp_scphi.push_count(mp); 
spex.ad_hoc("mcosp","msinp",&sp_scphi);
spex.multinomial("mcosp",mp,0)=spex.multinomial("mcosp");
spex.multinomial("msinp",mp,0)=spex.multinomial("msinp");

}
PowMap pm_x; // ,pm_st2,pm_x;
spex.multinomial("ddr").clear();
pm_x.clear();
pm_x["cost"]=1;
pm_x["ca"]=1;
spex.add_term("ddr",pm_x,1);
pm_x.clear();
pm_x["st"]=1;
pm_x["sphi"]=1;
// these trig pairs can be combined but leave like this for testing
pm_x["sa"]=1;
pm_x["sb"]=1;
spex.add_term("ddr",pm_x,1);
pm_x.clear();
pm_x["st"]=1;
pm_x["cphi"]=1;
pm_x["cb"]=1;
pm_x["sa"]=1;
spex.add_term("ddr",pm_x,1);
spex.multinomial("pfx",0,0)=spex.multinomial("ddr");
spex.multinomial("x").clear();
pm_x.clear();
pm_x["cost"]=1;
pm_x["cg"]=1;
spex.add_term("x",pm_x,1);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
pm_x["sd"]=1;
pm_x["sg"]=1;
spex.add_term("x",pm_x,1);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
pm_x["cd"]=1;
pm_x["cg"]=1;
spex.add_term("x",pm_x,1);
spex.multinomial("x",0,0)=spex.multinomial("x");


for(int l=1; l<=lmax; ++l)
{
//MM_ERR("making  cache "<<MMPR( l ))
//spex.clear_scratch();
const InPoly & p1 = m_leg.poly_no_sine(l,1);
spex.multinomial("p1").clear();
spex.add_polynomial("p1","x",p1,0);
//Coef  N=da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//spex.multiply("p1","p1",m_r0_powers[l-1]);
spex.multinomial("leg1",l,1)=spex.multinomial("p1");
// the c/s angles should be valid but evaluate later
// d factors out 
//spex.multiply("a","p1","ddr");
spex.multinomial("a").clear();
spex.substitute("a","p1","x","x",0);
spex.multinomial("leg1x",l,1)=spex.multinomial("a");
spex.multiply("a","a","ddr");
spex.multinomial("leg1xddr",l,1)=spex.multinomial("a");

} // l

MM_ERR("making  cache for lp mp  ")
for(int lp=1; lp<=lmax; ++lp)
{
//MM_ERR("making  cache "<<MMPR( lp ))

for(int mp=0; mp<=lp; ++mp)
{

const InPoly & p2 = m_leg.poly_no_sine(lp,mp);
spex.multinomial("p2").clear();
spex.add_polynomial("p2","cost",p2,0);
PowMap pm_x;
//pm_x.clear();
// one is for the differential, the second misisng from the legendre p3
pm_x["st"]=((mp&1)==1)?2:1;
//pm_st.clear();
spex.multinomial("pref").clear();
spex.add_term("pref",pm_x,1);
spex.multiply("p2","p2","pref");
if (!avoid_schmidt)
{
Coef s= m_leg.schmidt_normalization(lp,mp);
//Coef nm=((mp==0)? .5:.25)*(2*lp+1);
// phi integration changes this, see the Evaluate for Tab should
// apply here too 
Coef nm=(.25)*(2*lp+1);
spex.multiply("p2","p2",s*nm/M_PI);
}
//Coef da=1;
//Coef  N=da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);


spex.multinomial("p2mc")=spex.multinomial("p2")*spex.multinomial("mcosp",mp,0);
spex.multinomial("p2ms")=spex.multinomial("p2")*spex.multinomial("msinp",mp,0);
// get sin ^ x and the phi terms 

spex.multinomial("c1",lp,mp)=spex.multinomial("p2mc");
spex.multinomial("s1",lp,mp)=spex.multinomial("p2ms");

} // mp 
} // lp 
//} // l 
MM_ERR("done with leg cache  ")

}// CacheFamilies
void CacheFamiliesFromFuncTab(const IdxTy lmax, const IdxTy flags )
{
const bool print_sizes=Bit(flags,0);
auto & spex=m_spex.m_families;
const IdxTy lpmax=lmax; // m_lmax;
EvalVar*  ev= & m_eval_var;
ev->lmax(lmax);
typedef std::vector< std::map<StrTy,int> > Tm;
typedef std::vector< Coef > Tc;
MM_ERR(" caching "<<MMPR(lpmax))
for(IdxTy lp=1; lp<=lpmax; ++lp)
{
for(int  mp=0; mp<=lp; ++mp)
{
{ Tm d; Tc c;
m_func_tab.extract(d,c,ev,lp,mp,0,flags); 
spex.multinomial("glm",lp,mp).set(d,c);
if (print_sizes) { MM_ERR("g"<<MMPR2(d.size(),c.size())) } 
}

{ Tm d; Tc c;
m_func_tab.extract(d,c,ev,lp,mp,1,flags); 
spex.multinomial("hlm",lp,mp).set(d,c);
if (print_sizes) { MM_ERR("h"<<MMPR2(d.size(),c.size())) } 
}

} // mp
} // lp


} // CacheFamiliesFromFuncTab


// this does not work and indeed the caching seems slow.. 
Coef IntegrateACacheX(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
{
//typedef std::map<StrTy,int> PowMap;
auto & spex=m_spex.m_families;
spex.clear_scratch();
SpFlags sp_theta(SpFlags::TRIG_POLY_ZERO_PI);
SpFlags sp_phi(SpFlags::TRIG_POLY_ZERO_2PI);
sp_theta.push_var(StrTy("cost"));
sp_theta.push_var(StrTy("st"));
sp_phi.push_var(StrTy("cphi"));
sp_phi.push_var(StrTy("sphi"));

spex.multinomial("a")= spex.multinomial("leg1xddr",l,1);
spex.multiply("a","a",m_d);

if (l>1) {
spex.multinomial("I")= spex.multinomial("leg1x",l-1,1);
spex.multiply("I","I",-d_dot_r0);
}
spex.add("I","I","a");
//spex.multiply("I","I",m_r0_powers[l-1]);
if (gnoth)
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("c1",lp,mp);
else
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("s1",lp,mp);

//spex.substitute("I","I","x","x",0);

spex.ad_hoc("Itheta","I",&sp_phi);
spex.ad_hoc("Iphi","Itheta",&sp_theta);

std::map<StrTy,Coef> novars;
novars["sa"]=salpha;
novars["sb"]=sbeta;
novars["sg"]=sgamma;
novars["sd"]=sdelta;
novars["ca"]=calpha;
novars["cb"]=cbeta;
novars["cg"]=cgamma;
novars["cd"]=cdelta;

Coef rv= spex.evaluate("Iphi",novars);
return rv*m_r0_powers[l-1];

} // IntegrateACacheX

Coef IntegrateACachePieceOld(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const IdxTy piece)
{

const bool gnoth=Bit(piece,0);

typedef std::map<StrTy,int> PowMap;
auto & spex=m_spex.m_families;
spex.clear_scratch();
SpFlags sp_theta(SpFlags::TRIG_POLY_ZERO_PI);
SpFlags sp_phi(SpFlags::TRIG_POLY_ZERO_2PI);
sp_theta.push_var(StrTy("cost"));
sp_theta.push_var(StrTy("st"));
sp_phi.push_var(StrTy("cphi"));
sp_phi.push_var(StrTy("sphi"));

// only one piece is selected, r term is dropped...
// there are only 4 types here, jjjjjjjjjjjjjjjjjj
PowMap pm_x; // ,pm_st2,pm_x;
pm_x.clear();
pm_x["cost"]=1;
spex.add_term("x",pm_x,cgamma);
pm_x.clear();
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.add_term("x",pm_x,sdelta*sgamma);
pm_x.clear();
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.add_term("x",pm_x,cdelta*sgamma);
pm_x.clear();
pm_x["cost"]=1;
spex.add_term("ddr",pm_x,m_d*calpha);
pm_x.clear();
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.add_term("ddr",pm_x,m_d*salpha*sbeta);
pm_x.clear();
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.add_term("ddr",pm_x,m_d*cbeta*salpha);


//spex.multinomial("a")= spex.multinomial("leg1",l,1);
spex.multinomial("a")= spex.multinomial("leg1",l,m);
MM_ERR(MMPR4(l,m,lp,mp)<<" "<<spex.dump("a",1))
spex.multiply("a","a","ddr");
// these are isolated integrals not a complete solution
if (l>1) {
//spex.multinomial("I")= spex.multinomial("leg1",l-1,1);
//spex.multiply("I","I",-d_dot_r0);
}
spex.add("I","I","a");
//spex.multiply("I","I",m_r0_powers[l-1]);
if (gnoth)
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("c1",lp,mp);
else
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("s1",lp,mp);

spex.substitute("I","I","x","x",0);

MM_ERR(MMPR4(l,m,lp,mp)<<" "<<spex.dump("I",1))


if (false)
{
// see if changing order helps, phi eliminates a lot 
spex.ad_hoc("Itheta","I",&sp_theta);
//MM_ERR(spex.m_mn.dump("Itheta",1))
spex.ad_hoc("Iphi","Itheta",&sp_phi);
}
else
{
spex.ad_hoc("Itheta","I",&sp_phi);
spex.ad_hoc("Iphi","Itheta",&sp_theta);
}

std::map<StrTy,Coef> novars;
Coef rv= spex.evaluate("Iphi",novars);
//return rv*m_r0_powers[l-1];
return rv; // *m_r0_powers[l-1];


} // IntegrateACachePieceOld

// this is used to make tables or code for various integral pairs without
// irrational normalizaitons although pi may occur in evaluations. 
Coef IntegrateACachePiece(OsTy& os, OutSpec & outs, const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const IdxTy piece)
{
m_cm.mark("piece");
const bool gnoth=Bit(piece,0);
const bool dumps=Bit(piece,1);
const bool do_timing=Bit(piece,2);
const bool save_pi=Bit(piece,3);
const bool output_empty_terms=!Bit(piece,4);
//MM_ERR(MMPR4(gnoth,dumps,do_timing,save_pi)<<MMPR(putput_empty_terms))
static const Coef unity=Coef(1);
//Coef IntegrateA(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
//{
//MM_ERR(MMPR4(l,m,lp,mp))
SpEx spex;
// needs to derive from m_cache in m_leg;
typedef std::vector<Coef> InPoly;
typedef std::map<StrTy,int> PowMap;
InPoly zep;
SpFlags sp_theta(SpFlags::TRIG_POLY_ZERO_PI);
SpFlags sp_phi(SpFlags::TRIG_POLY_ZERO_2PI);
SpFlags sp_scphi(SpFlags::CREATE_MSIN_POLY);
sp_theta.push_var(StrTy("cost"));
sp_theta.push_var(StrTy("st"));
sp_phi.push_var(StrTy("cphi"));
sp_phi.push_var(StrTy("sphi"));

// generate the cos(m phi) equivalent polynomials,
// reduce to cos^n(phi) to do integration 
sp_scphi.push_var(StrTy("cphi"));
sp_scphi.push_var(StrTy("sphi"));
sp_scphi.push_count(mp); 
spex.m_mn.ad_hoc("mcosp","msinp",&sp_scphi);
//MM_ERR(MMPR(mp)<<spex.m_mn.dump("mcosp",1))
//MM_ERR(MMPR(mp)<<spex.m_mn.dump("msinp",1))
// TODO l and l-1 should be same m which shoudl be 1 but not different 
const InPoly & p1 = m_leg.poly_no_sine(l,m);
const bool have_p2=(l>1);
//const InPoly & p2 = (have_p2)?m_leg.poly_no_sine(l-1,1):zep;
const InPoly & p2 = (have_p2)?m_leg.poly_no_sine(l-1,m):zep;
// for now, add in the odd sine() term later... 
const InPoly & p3 = m_leg.poly_no_sine(lp,mp);
spex.m_mn.add_polynomial("p1","x",p1,0);
if (have_p2)spex.m_mn.add_polynomial("p2","x",p2,0);
// this was being done before adding doh 
{
PowMap pm_ddr;
pm_ddr["ddr"]=1;
spex.m_mn.add_term("ddrxxx",pm_ddr,unity);

}
//if (have_p2) spex.m_mn.multiply("p2","p2", -d_dot_r0);
if (have_p2) spex.m_mn.multiply("p2","p2", "ddrxxx");


spex.m_mn.add_polynomial("p3","cost",p3,0);
if (dumps) { 
MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p1",1)))
if (have_p2){ MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p2",1))) }
}
//MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p3",1)))
PowMap pm_st,pm_st2,pm_x;
//pm_st["st"]=1;
//pm_st2["st"]=2;
//spex.m_mn.add_term("st",pm_st,1);
//spex.m_mn.add_term("st2",pm_st2,1);
//pm_st.clear();
//pm_st["cost"]=1;
//spex.m_mn.add_term("cost",pm_st,1);

pm_st.clear();
spex.m_mn.add_term("I",pm_st,unity);
//MM_ERR(spex.m_mn.dump("I",1))
spex.m_mn.multiply("I","I","p3");
//MM_ERR(MMPR4(l,m,lp,mp)<<" p3*1 "<< MMPR(spex.m_mn.dump("I",1)))
// dipole 
//const Coef dtr=M_PI/180.0;
/*
*/
// polynomial x needs to be saved it is an arg of rhe integrand
pm_x.clear();
pm_x["cost"]=1;
pm_x["cgamma"]=1;
//spex.m_mn.add_term("x",pm_x,cgamma);
spex.m_mn.add_term("x",pm_x,unity);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
pm_x["sdelta"]=1;
pm_x["sgamma"]=1;
//spex.m_mn.add_term("x",pm_x,sdelta*sgamma);
spex.m_mn.add_term("x",pm_x,unity);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
pm_x["cdelta"]=1;
pm_x["sgamma"]=1;
//spex.m_mn.add_term("x",pm_x,cdelta*sgamma);
spex.m_mn.add_term("x",pm_x,unity);

if (dumps) { MM_ERR(MMPR4(l,m,lp,mp)<<" x "<< MMPR(spex.m_mn.dump("x",1))) } 

pm_x.clear();
pm_x["cost"]=1;
pm_x["calpha"]=1;
//spex.m_mn.add_term("ddr",pm_x,m_d*calpha);
spex.m_mn.add_term("ddr",pm_x,unity);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
pm_x["salpha"]=1;
pm_x["sbeta"]=1;
//spex.m_mn.add_term("ddr",pm_x,m_d*salpha*sbeta);
spex.m_mn.add_term("ddr",pm_x,unity);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
pm_x["salpha"]=1;
pm_x["cbeta"]=1;
//spex.m_mn.add_term("ddr",pm_x,m_d*cbeta*salpha);
spex.m_mn.add_term("ddr",pm_x,unity);

if (dumps) { MM_ERR(MMPR4(l,m,lp,mp)<<" ddr "<< MMPR(spex.m_mn.dump("ddr",1))) }

spex.m_mn.multiply("ddr","ddr","p1");
if (have_p2) spex.m_mn.add("ddr","ddr","p2");
if (dumps) { MM_ERR(spex.m_mn.dump("ddr",1)) } 

pm_x.clear();
// one is for the differential, the second misisng from the legendre p3
pm_x["st"]=((mp&1)==1)?2:1;
//pm_st.clear();
spex.m_mn.add_term("pref",pm_x,unity);
spex.m_mn.multiply("pref","pref",gnoth?"mcosp":"msinp");


spex.m_mn.multiply("I","I","pref");
if (dumps) { MM_ERR(spex.m_mn.dump("I",1)) } 
spex.m_mn.multiply("I","I","ddr");
if (dumps) { MM_ERR(MMPR4(l,m,lp,mp)<<" "<< spex.m_mn.dump("I",1)) } 
//void  substitute(const char * d, const char * s, const char * var, const char * sv, const IdxTy flags )

// substitute, integrate etc need to be optimized and probably
// prune as many terms as early as possible. 
m_cm.mark("subs");
spex.m_mn.substitute("I","I","x","x",0);
m_cm.cumdel("substotal","subs");

if (dumps) { 
MM_ERR(spex.m_mn.dump("I",1))
MM_ERR(MMPR4(l,m,lp,mp)<<" "<< spex.m_mn.dump("I",1))
}

m_cm.mark("integrate");
//if (save_pi) { sp_theta.st(m_stp); sp_phi.st(m_stp); } 
if (save_pi) spex.m_mn.ad_hoc_general("Itheta","I",&sp_theta);
else spex.m_mn.ad_hoc("Itheta","I",&sp_theta);

if (dumps) { MM_ERR(spex.m_mn.dump("Itheta",1)) } 

if (save_pi) spex.m_mn.ad_hoc_general("Iphi","Itheta",&sp_phi);
else spex.m_mn.ad_hoc("Iphi","Itheta",&sp_phi);


if (dumps) { 
MM_ERR(spex.m_mn.dump("x",1))
MM_ERR(spex.m_mn.dump("Iphi",1))
MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("Iphi",1)))
}
// need a better way to label output 
///typedef mjm_tab_data_spec<Tr> OutSpec ;
//OutSpec outs;
Ss ss;
//ss<<l<<" "<<m<<" "<<lp<<" "<<mp<<" "<<(gnoth?"g":"h");
ss<<l<<" "<<m<<" "<<lp<<" "<<mp<<" "<<(gnoth?"0":"1");
outs.prefix(ss.str());
if (dumps) {
MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("Iphi",3+(1<<16))))
}
auto & mip= spex.m_mn.multinomial("Iphi");
if ((mip.fudd()!=0)||( output_empty_terms))  mip.output(os,outs);
//spex.m_mn.multinomial("Iphi").output(os,outs);


m_cm.cumdel("integratetotal","integrate");
m_cm.cumdel("piecetotal","piece");
if (do_timing ) { m_cm.dump("times",std::cerr); }
//std::map<StrTy,Coef> novars;
Coef rv=0 ; //  spex.m_mn.evaluate("Iphi",novars);
//Coef s= m_leg.schmidt_normalization(lp,mp);
//Coef nm=((mp==0)? .5:.25)*(2*lp+1);
//Coef da=1;
//Coef  N=1; // da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//Coef  N=da*s/(1.0)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//MM_ERR(MMPR4(l,m,lp,mp)<<MMPR4(rv,s,N,l)<<MMPR((rv*N)))
//MM_ERR(MMPR4(l,m,lp,mp)<<MMPR(rv)<<MMPR((rv)))
return rv;
//return rv*N;


} // IntegrateACachePiece


// matches the trapezoidal integration pretty well and 
// speed ok 
Coef IntegrateACache(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
{
typedef std::map<StrTy,int> PowMap;
auto & spex=m_spex.m_families;
spex.clear_scratch();
SpFlags sp_theta(SpFlags::TRIG_POLY_ZERO_PI);
SpFlags sp_phi(SpFlags::TRIG_POLY_ZERO_2PI);
sp_theta.push_var(StrTy("cost"));
sp_theta.push_var(StrTy("st"));
sp_phi.push_var(StrTy("cphi"));
sp_phi.push_var(StrTy("sphi"));

PowMap pm_x; // ,pm_st2,pm_x;

pm_x.clear();
pm_x["cost"]=1;
spex.add_term("x",pm_x,cgamma);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.add_term("x",pm_x,sdelta*sgamma);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.add_term("x",pm_x,cdelta*sgamma);
pm_x.clear();
pm_x["cost"]=1;
spex.add_term("ddr",pm_x,m_d*calpha);
pm_x.clear();
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.add_term("ddr",pm_x,m_d*salpha*sbeta);
pm_x.clear();
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.add_term("ddr",pm_x,m_d*cbeta*salpha);

spex.multinomial("a")= spex.multinomial("leg1",l,1);
spex.multiply("a","a","ddr");
//MM_ERR(spex.dump("a",1))
if (l>1) {
spex.multinomial("I")= spex.multinomial("leg1",l-1,1);
spex.multiply("I","I",-d_dot_r0);
}
spex.add("I","I","a");
//MM_ERR(spex.dump("I",1))
//MM_ERR(spex.dump("I",1))
//spex.multiply("I","I",m_r0_powers[l-1]);
if (gnoth)
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("c1",lp,mp);
else
spex.multinomial("I")=spex.multinomial("I")*spex.multinomial("s1",lp,mp);
//MM_ERR(spex.dump("I",1))

spex.substitute("I","I","x","x",0);

if (false)
{
// see if changing order helps, phi eliminates a lot 
spex.ad_hoc("Itheta","I",&sp_theta);
//MM_ERR(spex.m_mn.dump("Itheta",1))
spex.ad_hoc("Iphi","Itheta",&sp_phi);
}
else
{
spex.ad_hoc("Itheta","I",&sp_phi);
spex.ad_hoc("Iphi","Itheta",&sp_theta);
}
//MM_ERR(spex.dump("Itheta",1))

std::map<StrTy,Coef> novars;
Coef rv= spex.evaluate("Iphi",novars);
const Coef &  N=m_r0_powers[l-1];
//if (rv!=0) { MM_ERR("non-zero "<<MMPR4(l,m,lp,mp)<<MMPR2(rv,N)<<MMPR((rv*N))) } 
//return rv*m_r0_powers[l-1];
return rv*N;

} // IntegrateACache

Coef IntegrateA(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp, const bool gnoth)
{
//MM_ERR(MMPR4(l,m,lp,mp))
SpEx spex;
// needs to derive from m_cache in m_leg;
typedef std::vector<Coef> InPoly;
typedef std::map<StrTy,int> PowMap;
InPoly zep;
SpFlags sp_theta(SpFlags::TRIG_POLY_ZERO_PI);
SpFlags sp_phi(SpFlags::TRIG_POLY_ZERO_2PI);
SpFlags sp_scphi(SpFlags::CREATE_MSIN_POLY);
sp_theta.push_var(StrTy("cost"));
sp_theta.push_var(StrTy("st"));
sp_phi.push_var(StrTy("cphi"));
sp_phi.push_var(StrTy("sphi"));

// generate the cos(m phi) equivalent polynomials,
// reduce to cos^n(phi) to do integration 
sp_scphi.push_var(StrTy("cphi"));
sp_scphi.push_var(StrTy("sphi"));
sp_scphi.push_count(mp); 
spex.m_mn.ad_hoc("mcosp","msinp",&sp_scphi);
//MM_ERR(MMPR(mp)<<spex.m_mn.dump("mcosp",1))
//MM_ERR(MMPR(mp)<<spex.m_mn.dump("msinp",1))

const InPoly & p1 = m_leg.poly_no_sine(l,1);
const bool have_p2=(l>1);
const InPoly & p2 = (have_p2)?m_leg.poly_no_sine(l-1,1):zep;
// for now, add in the odd sine() term later... 
const InPoly & p3 = m_leg.poly_no_sine(lp,mp);
spex.m_mn.add_polynomial("p1","x",p1,0);
if (have_p2)spex.m_mn.add_polynomial("p2","x",p2,0);
// this was being done before adding doh 
if (have_p2) spex.m_mn.multiply("p2","p2", -d_dot_r0);
spex.m_mn.add_polynomial("p3","cost",p3,0);
//MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p1",1)))
//if (have_p2){ MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p2",1))) }
//MM_ERR(MMPR4(l,m,lp,mp)<<" "<< MMPR(spex.m_mn.dump("p3",1)))
PowMap pm_st,pm_st2,pm_x;
//pm_st["st"]=1;
//pm_st2["st"]=2;
//spex.m_mn.add_term("st",pm_st,1);
//spex.m_mn.add_term("st2",pm_st2,1);
//pm_st.clear();
//pm_st["cost"]=1;
//spex.m_mn.add_term("cost",pm_st,1);

pm_st.clear();
spex.m_mn.add_term("I",pm_st,1);
//MM_ERR(spex.m_mn.dump("I",1))
spex.m_mn.multiply("I","I","p3");
//MM_ERR(MMPR4(l,m,lp,mp)<<" p3*1 "<< MMPR(spex.m_mn.dump("I",1)))
// dipole 
const Coef dtr=M_PI/180.0;
/*
const Coef calpha=cos(dtr*m_alpha);
const Coef salpha=sin(dtr*m_alpha);
const Coef cbeta=cos(dtr*m_beta);
const Coef sbeta=sin(dtr*m_beta);
// r0
const Coef cgamma=cos(dtr*m_gamma);
const Coef sgamma=sin(dtr*m_gamma);
const Coef cdelta=cos(dtr*m_delta);
const Coef sdelta=sin(dtr*m_delta);
*/
// polynomial x needs to be saved it is an arg of rhe integrand
pm_x.clear();
pm_x["cost"]=1;
spex.m_mn.add_term("x",pm_x,cgamma);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.m_mn.add_term("x",pm_x,sdelta*sgamma);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.m_mn.add_term("x",pm_x,cdelta*sgamma);

//MM_ERR(MMPR4(l,m,lp,mp)<<" x "<< MMPR(spex.m_mn.dump("x",1)))

pm_x.clear();
pm_x["cost"]=1;
spex.m_mn.add_term("ddr",pm_x,m_d*calpha);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["sphi"]=1;
spex.m_mn.add_term("ddr",pm_x,m_d*salpha*sbeta);
pm_x.clear(); 
pm_x["st"]=1;
pm_x["cphi"]=1;
spex.m_mn.add_term("ddr",pm_x,m_d*cbeta*salpha);

//MM_ERR(MMPR4(l,m,lp,mp)<<" ddr "<< MMPR(spex.m_mn.dump("ddr",1)))

spex.m_mn.multiply("ddr","ddr","p1");
if (have_p2) spex.m_mn.add("ddr","ddr","p2");
//MM_ERR(spex.m_mn.dump("ddr",1))

pm_x.clear();
// one is for the differential, the second misisng from the legendre p3
pm_x["st"]=((mp&1)==1)?2:1;
//pm_st.clear();
spex.m_mn.add_term("pref",pm_x,1);
spex.m_mn.multiply("pref","pref",gnoth?"mcosp":"msinp");


spex.m_mn.multiply("I","I","pref");
//MM_ERR(spex.m_mn.dump("I",1))
spex.m_mn.multiply("I","I","ddr");
//MM_ERR(MMPR4(l,m,lp,mp)<<" "<< spex.m_mn.dump("I",1))
//void  substitute(const char * d, const char * s, const char * var, const char * sv, const IdxTy flags )

spex.m_mn.substitute("I","I","x","x",0);
//MM_ERR(spex.m_mn.dump("I",1))
//MM_ERR(MMPR4(l,m,lp,mp)<<" "<< spex.m_mn.dump("I",1))

spex.m_mn.ad_hoc("Itheta","I",&sp_theta);
//MM_ERR(spex.m_mn.dump("Itheta",1))
spex.m_mn.ad_hoc("Iphi","Itheta",&sp_phi);

//MM_ERR(spex.m_mn.dump("x",1))
//MM_ERR(spex.m_mn.dump("Iphi",1))

std::map<StrTy,Coef> novars;
Coef rv= spex.m_mn.evaluate("Iphi",novars);
Coef s= m_leg.schmidt_normalization(lp,mp);
//Coef nm=((mp==0)? .5:.25)*(2*lp+1);
// see the Evaluate for Tab code= phi integration and DC vs cos^ initegral 
Coef nm=(.25)*(2*lp+1);
Coef da=1;
Coef  N=da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//Coef  N=da*s/(1.0)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
if (rv!=0) { MM_ERR("non-zero "<<MMPR4(l,m,lp,mp)<<MMPR4(rv,s,N,l)<<MMPR((rv*N))) } 
return rv*N;

#if 0 
//MM_ERR(spex.m_mn.dump(1))
Coef I=0;
//const Coef dtr=M_PI/180.0;
Coef da=2*M_PI*M_PI/(m_ntheta*m_nphi);
// mp???
Coef nm=((m==0)? .5:.25)*(2*l+1);
// TODO check that this is right for the assumptions... 
Coef s= m_leg.schmidt_normalization(lp,mp);
if ((l+1)>=m_r0_powers.size())
{MM_ERR(" not enough powers "<<MMPR2(l,m_r0_powers.size())) }
// this seems to produce .666 for dipole 1 at origin... 
// forgot the normalizations doh 
Coef  N=da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
//MM_ERR(MMPR4(l,m,lp,mp))

MM_LOOP(ii,m_cache)
{
const auto & z=(*ii);
const auto & x=z.x;
const auto & cost=z.ctheta;
const auto & sint=z.stheta;
//MM_ERR(MMPR3(x,z.theta,z.phi))
// this is the - summing over l here allows prior l
// value to become l-1 in next iterartion.. 
const Coef t1=m_leg.eval_no_sine(x,l,1);
// when l==1, this is not valid. 
const Coef t2=(l==1)?0:m_leg.eval_no_sine(x,l-1,1);
const Coef t3=m_leg.eval(cost,sint,lp,mp,0);
// this needs to use c_M_phi doh... 
// AND commute the points with l,m summation... 
const Coef dI=sint*(gnoth?cos(mp*dtr*z.phi):sin(mp*dtr*z.phi))*(z.d_dot_r*t1-d_dot_r0*t2)*t3;
I+=dI;
}
//MM_ERR(MMPR3((I*N),I,N)<<MMPR4(l,m,lp,mp))
return I*N;
#endif

} // IntegrateA

///////////////////////////////////////////////////////
Coef EvaluateG(const IdxTy lp, const IdxTy mp,const bool gnoth)
{
Coef g=0;
// this needs to be commuted into the integral to save 
// some multiplies... 
//for(IdxTy l=1; l<=m_lmax; ++l)
for(IdxTy l=1; l<=m_lmax; ++l)
{
//for(IdxTy m=0; m<=l ; ++m) { g+=Integrate(l,m,lp,mp); } // m 
for(IdxTy m=1; m<=1 ; ++m) { g+=Integrate(l,m,lp,mp,gnoth); } // m 

} // l 
return g;
}
Coef EvaluateGA(const IdxTy lp, const IdxTy mp,const bool gnoth)
{
//MM_ERR(" analytical part")
Coef g=0;
// this needs to be commuted into the integral to save 
// some multiplies... 
//for(IdxTy l=1; l<=m_lmax; ++l)
for(IdxTy l=1; l<=m_lmax; ++l)
{
//for(IdxTy m=0; m<=l ; ++m) { g+=Integrate(l,m,lp,mp); } // m 
//for(IdxTy m=1; m<=1 ; ++m) { g+=IntegrateA(l,m,lp,mp,gnoth); } // m 
for(IdxTy m=1; m<=1 ; ++m) { g+=IntegrateACache(l,m,lp,mp,gnoth); } // m 
//for(IdxTy m=1; m<=1 ; ++m) { g+=IntegrateACacheX(l,m,lp,mp,gnoth); } // m 

} // l 
return g;
} // EvaluateGA

Coef EvaluateGTab(const IdxTy lp, const int  mp,const bool gnoth)
{
//  spex.m_mn.evaluate("Iphi",novars);
m_eval_var.lmax(m_lmax);
Coef c= m_func_tab.evaluate(&m_eval_var,lp,mp,gnoth?0:1,0);
if (c==Coef(0)) return c; 
Coef s= m_leg.schmidt_normalization(lp,mp);
// this needs to be checked carefully, see the other cases TODO FIXME 
//Coef nm=((mp==0)? .5:.25)*(2*lp+1);
// for m==0, the phi integration gives 2pi NOT pi 
Coef nm=((mp==0)? .5:.25)*(2*lp+1);
// this is due to the phi integration... 
if (mp==0) nm=nm*.5;
//Coef da=1;
//Coef  N=1; // da*s/(M_PI)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);
Coef  N=s/(M_PI)*nm; // pow(m_r0,l+1);
//Coef  N=da*s/(1.0)*m_r0_powers[l-1]*nm; // pow(m_r0,l+1);

//m_eval_var;
c=c*N*m_d;

return c;
}
void CacheEvalVar(const IdxTy flags)
{
// need to setup the ddr and angle things from the members
// this needs a map of variables and max powers.
std::map<StrTy, Coef> vars;
// the caller can apply the schmidt qn at the end up the internal sum over l
// needs the r^l terms. 
vars["calpha"]=calpha;
vars["salpha"]=salpha;
vars["sbeta"]=sbeta;
vars["cbeta"]=cbeta;
vars["cgamma"]=cgamma;
vars["sgamma"]=sgamma;
vars["cdelta"]=cdelta;
vars["sdelta"]=sdelta;
vars["pi"]=Coef(M_PI);
vars["\\pi"]=Coef(M_PI);
MM_ONCE(" d_dot_r0 kluge, moved to source of calculation ",)

//if (m_r0!=0) vars["ddr"]=-d_dot_r0/m_r0;
//else vars["ddr"]=0; // -d_dot_r0;
// except this won't scale right with m_d now doh...
 vars["ddr"]= -d_dot_r0;
if (m_d==0) vars["ddr"]= 0;
else  vars["ddr"]= -d_dot_r0/m_d;
m_eval_var.load(vars, m_func_tab.vpm(),flags);
//MM_LOOP(ii, m_func_tab.vpm())
//{ MM_ERR(MMPR3((*ii).first, m_func_tab.m_st((*ii).first),(*ii).second)) }

//d_dot_r0=m_d*m_r0*(calpha*cgamma+salpha*sgamma*(sbeta*sdelta +cbeta*cdelta));
// done in ctor 
//m_r0_powers[0]=1;

// get the powers of r and the schmidt qn terms.



}

void SetDipole(const Coef & d, const Coef & alpha, const Coef & beta)
{KillCache(); m_d=d; m_alpha=alpha; m_beta=beta; }
void SetOffset(const Coef & d, const Coef & alpha, const Coef & beta)
{KillCache(); m_r0=d; m_gamma=alpha; m_delta=beta; }

void CacheValues(const IdxTy lmax,const IdxTy flags)
{
const bool fams=Bit(flags,0);
const bool sqn=Bit(flags,1);
m_lmax=lmax;
m_r0_powers.resize(lmax+2);
m_r0_powers[0]=1;
for(IdxTy i=1; i<(lmax+2);++i) { m_r0_powers[i]=m_r0*m_r0_powers[i-1]; }
if (sqn) m_leg.make_cache(lmax,1); // schmidt quasi  normalizaion 
else m_leg.make_cache(lmax,0); // default, no normalizaion 
MM_ERR(" made cache to at least "<<MMPR(lmax))
if (fams) CacheFamilies( lmax,flags );
else MM_ERR(" skipping family cache ")
} // CacheValues

void KillCache() { m_r0_powers.clear();  m_cache.clear(); }

void CachePoints()  { 
//m_cache.clear();
KillCache();
//CachePoints();
Coef theta=m_theta0;
const Coef dtheta=(Coef(180)-m_theta0)/m_ntheta;
const Coef dphi=(Coef(360)-m_phi0)/m_nphi;
const Coef dtr=M_PI/180.0;
// dipole 
/*
const Coef calpha=cos(dtr*m_alpha);
const Coef salpha=sin(dtr*m_alpha);
const Coef cbeta=cos(dtr*m_beta);
const Coef sbeta=sin(dtr*m_beta);
// r0
const Coef cgamma=cos(dtr*m_gamma);
const Coef sgamma=sin(dtr*m_gamma);
const Coef cdelta=cos(dtr*m_delta);
const Coef sdelta=sin(dtr*m_delta);
*/
 calpha=cos(dtr*m_alpha);
 salpha=sin(dtr*m_alpha);
 cbeta=cos(dtr*m_beta);
 sbeta=sin(dtr*m_beta);
// r0
 cgamma=cos(dtr*m_gamma);
 sgamma=sin(dtr*m_gamma);
 cdelta=cos(dtr*m_delta);
 sdelta=sin(dtr*m_delta);

MM_ONCE(" d_dot_r0 norm may be wrong ",)

//d_dot_r0=m_d*m_r0*(calpha*cgamma+salpha*sgamma*(sbeta*sdelta +cbeta*cdelta));
d_dot_r0=m_d*(calpha*cgamma+salpha*sgamma*(sbeta*sdelta +cbeta*cdelta));
if (m_r0==0) d_dot_r0=0;

Coef cphi[m_nphi],sphi[m_nphi];
Coef phi=m_phi0;
for(IdxTy j=0; j<m_nphi; ++j)
{
cphi[j]=cos(dtr*phi);
sphi[j]=sin(dtr*phi);
phi+=dphi;
}
for(IdxTy i=0; i<m_ntheta; ++i)
{

Coef phi=m_phi0;
Coef ct=cos(dtr*theta);
Coef st=sin(dtr*theta);
for(IdxTy j=0; j<m_nphi; ++j)
{
// x is r_hat dot r0_hat
//Coef theta,phi,ctheta,cphi,stheta,sphi,x,d_dot_r;
argsx z;
z.theta=theta;
z.phi=phi;
z.ctheta=ct; // cos(dtr*theta);
z.stheta=st; // cos(dtr*theta);
z.cphi=cphi[j]; // cos(dtr*phi);
z.sphi=sphi[j]; // st;
z.x=cgamma*ct+sgamma*sdelta*st*z.sphi +sgamma*cdelta*st*z.cphi;
z.d_dot_r=m_d*(calpha*ct+salpha*st*(sbeta*z.sphi +cbeta*z.cphi));

m_cache.push_back(z);
phi+=dphi;
} // j 
theta+=dtheta; // erros accumulate but ok 
} // i 

MM_ERR(" made point cache to at least "<<MMPR(m_cache.size()))
} // CachePoints

StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<MMPR4(m_lmax,m_d,m_alpha,m_beta);
ss<<MMPR3(m_r0,m_gamma,m_delta);
ss<<MMPR4(m_r0_powers.size(),d_dot_r0,m_ntheta,m_nphi);
ss<<MMPR3(m_theta0,m_phi0,m_cache.size());

return ss.str(); }
void Init()
{
m_d=0;
m_alpha=0;
m_beta=0;
m_r0=0;
m_gamma=0;
m_delta=0;
d_dot_r0=0;
m_ntheta=10;
m_nphi=10;
m_theta0=0;
m_phi0=0;
}

Legendres &  m_leg;
IdxTy m_lmax;
SpEx m_spex;

// theta and phi for dipole direction 
Coef m_d, m_alpha,m_beta;
// theta and phi for offset direction
Coef m_r0, m_gamma,m_delta;
CoefVec m_r0_powers;
Coef d_dot_r0;
Coef calpha,salpha,cbeta,sbeta,cgamma,sgamma,cdelta,sdelta;

IdxTy m_ntheta,  m_nphi;
Coef  m_theta0, m_phi0;

FuncTab m_func_tab;
EvalVar m_eval_var;

ArgCache m_cache;
CounterMap m_cm;

}; // mjm_leg_integrals

//////////////////////////////////////////////

template <class Tr>
class mjm_leg_integrals_map : public std::map<typename Tr::StrTy, mjm_leg_integrals< Tr > >  
{
 typedef mjm_leg_integrals_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_leg_integrals< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_leg_integrals_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_leg_integrals_map




////////////////////////////////////////////
#ifdef  TEST_MJM_LEG_INTEGRALS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_LEG_INTEGRALS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_leg_integrals<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_LEG_INTEGRALS_H__ 
