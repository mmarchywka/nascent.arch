#ifndef MJM_LEGENDRE_STUFF_H__
#define MJM_LEGENDRE_STUFF_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_integrals.h"
#include "mjm_closed_families.h"
#include "mjm_rods_array.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Jan  4 18:20:12 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_legendre_stuff   
// g++ -std=gnu++11 -DTEST_MJM_LEGENDRE_STUFF -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_legendre_stuff.h  -lpthread -lreadline



template <class Tr, class _CoefTy=double>
class mjm_legendre_stuff 
{
 typedef mjm_legendre_stuff Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef _CoefTy Coef; // want to allow rationals and arb precision int 
typedef std::vector<Coef> Poly;
typedef mjm_integrals Mi;

class desc
{
public:
// ASSFUDDING editor fudd sthi 
desc(const IdxTy l, const int m, const Poly & r,const Poly & rp, Mi * mip)
: m_l(l),m_d(1),m_m(m),m_odd((m&1)!=0), m_r(r),m_r_prime(rp), mi(mip) {}
desc()
: m_l(~0),m_d(0),m_m(~0),m_odd(false), m_r(),m_r_prime(), mi(0) {}
//desc():mi(0) {} // should only be a dummy... 
const Poly & poly() const  { return m_r;}
Coef at_x(const Coef & x) const 
{
Coef r=(*mi).evaluate_polynomial(m_r,x);
// need support for non-double Coef... 
if (m_odd) { r=r*sqrt(1-x*x); } 
return r; 
}
Coef at_theta(const Coef & ct, const Coef & st, const IdxTy der) const
{
switch (der)
{
case 0: return at_theta(ct,st);
case 1: return der_at_theta(ct,st);
default: MM_ERR(" not imple "<<MMPR3(ct,st,der))
}; 
return 0; 
}
Coef at_theta(const Coef & ct, const Coef & st) const
{
Coef r=(*mi).evaluate_polynomial(m_r,ct);
if (m_odd) { r=r*st; } 
return r;
}
// in this case, the sine on m odd cancels with something
// else 
Coef at_theta_no_sine(const Coef & ct) const
{
Coef r=(*mi).evaluate_polynomial(m_r,ct);
//if (m_odd) { r=r*st; } 
return r;
}



Coef der_at_theta(const Coef & ct, const Coef & st) const 
{
// this is wrt x
Coef rp=(*mi).evaluate_polynomial(m_r_prime,ct);
if (m_odd) 
{
// 
Coef r=(*mi).evaluate_polynomial(m_r,ct);
// r=-st*r*ct; 
//rp=rp*st*st;
//return r-rp;
//return -st*(r*ct+rp*st);
return r*ct-st*rp*st;
} 
return rp*(-st);

}
StrTy shot_fudd()const  { return to_string(); } 
StrTy to_string() const 
{
Ss ss;
ss<<MMPR4(m_l,m_d,m_m,m_odd);
if (mi!=0) { ss<<MMPR2((*mi).print_polynomial(m_r,0,"x")
,(*mi).print_polynomial(m_r_prime,0,"x")); } 
return ss.str();

}

// these may be schmidt normalized but that is nor a rational
// result need to find a way to keep that separate... 
// d is number of cos ders
IdxTy m_l,m_d;
int m_m;
bool m_odd;
// this only works for non-der case need 2D poly 
Poly  m_r, m_r_prime;
Mi*  mi;
};

typedef desc Desc;
//class leg_index{
template <class Td> class tri_index{
public:
// ordering is m=l, m=l-1, etc for ease of indexing... 
//typedef Desc data_type;
typedef Td data_type;
// FIXME this is not right but seems to work leave gaps
// although l==0 seems to find something valid wtf?
static IdxTy size(const IdxTy lmax)  { return ((lmax+1)*(lmax+2))>>1; } 
static IdxTy index(const IdxTy l,const int  m)  
{ return  size(l)+(~m); }  // signed arthimetic, bacward store offset lol. 
}; // tri_index

typedef tri_index<Desc> leg_index;

/*
template <class Td,int N=2> class ntri_index{
public:
// ordering is m=l, m=l-1, etc for ease of indexing... 
//typedef Desc data_type;
typedef Td data_type;
// FIXME this is not right but seems to work leave gaps
// although l==0 seems to find something valid wtf?
static IdxTy size(const IdxTy lmax)  { return (N*(lmax+1)*(lmax+2))>>1; } 
static IdxTy index(const IdxTy l,const int  m)  
{ return  size(l)+(~m); }  // signed arthimetic, bacward store offset lol. 
}; // ntri_index

*/


typedef  leg_index Tindex;
typedef mjm_rods_array<Tr,Tindex> TyCacheBase;

class cache_thing : public TyCacheBase
{
typedef TyCacheBase Super;
public:
// why the FUDD
typedef typename Super::data_type data_type; // FUDD

data_type &  operator()(const IdxTy l, const int m )
//{return (*this)(Tindex::index(l,m)); } 
{return ((Super*)(this))->operator()(Tindex::index(l,m)); } 
data_type &  operator()(const IdxTy n )
//{return (*this)(Tindex::index(l,m)); } 
{
// this is a fudding ass fudd, it was making a new fudding
// use the old fudding cast syntax why the FUDD would you call the
// ctor to do a fcuking cast??? FUDD 
// return Super(*this)(n); 
return ((Super*)(this))->operator()(n);  
} 
StrTy dump(const IdxTy flags)
{
Ss ss;
ss<< "Called the right code "<<Super::used()<<CRLF;
// why the FUDD can't it find this shot 
const IdxTy sz=Super::used();
for(IdxTy i=0; i<sz; ++i)
{
ss<<i<<" "<<(*this)(i).to_string()<<CRLF;
}
return ss.str();
}
}; // cache_thing

typedef cache_thing TyCache;

/* Finally a table based system in which integrals can be computer
exactly and multiplied by variable parameters. Right now this is
the integral of a schmidt-quasi normalized function l' m' left
unnormalized, multiplied by l 1 also unnormalized. These are done
almost exactly depending on how pi is eventually handled.

This usage is not right though, it needs an expandable storage
like std::vector with the caching used for indexing. The cache
points to the index entries which point to the internal vector  

Moved to abulate_functions.h

*/

/*
class tab_term
{

public:
enum { BAD=~0};
IdxTy bad() const { return BAD; } 
tab_term(const IdxTy l, const IdxTy m, const IdxTy lp, const IdxTy mp,
const IdxTy gh,
const Coef c) : m_l(l),m_m(m),m_lp(lp),m_mp(mp),m_gh(gh),m_c(c) {}
void var(const IdxTy v, const IdxTy p) { m_map[v]+=p; }
IdxTy pow(const IdxTy v) { return m_map[v]; } 

// links integrated into data type...
IdxTy next() const { return m_next; } 
StrTy dump() const
{
 Ss ss;
ss<<MMPR4(m_l,m_m,m_lp,m_mp);
ss<<MMPR4(m_c,m_prior,m_here,m_next); 
MM_LOOP(ii,m_map) { ss<<MMPR2((*ii).first, (*ii).second); } 
return ss.str(); 
}

// keep all info even if indexed for later asserts. 
IdxTy m_l,m_m,m_lp,m_mp,m_gh;
// coef and powers map
Coef m_c;
typedef std::map<IdxTy, IdxTy> VarPowMap;

VarPowMap m_map;
IdxTy m_prior,m_here,m_next;

}; // tab_term 

typedef tab_term TabTerm;
class tab_list_index_entry
{
enum { BAD=~0};
public:
tab_list_index_entry():m_first(BAD),m_last(BAD),m_lp(BAD),m_mp(BAD),m_gh(BAD) {}
IdxTy bad() const { return BAD; } 

IdxTy add_link(const IdxTy loc, const IdxTy lp, const int mp, const int gh )
{

if (m_lp==BAD) m_lp=lp;
if (m_mp==BAD) m_mp=mp;
if (m_gh==BAD) m_gh=gh;
if ( (m_lp==lp ) && (m_mp==mp ) && (m_gh==gh ))
{
}else MM_ERR(" index mismatch "<<MMPR3(m_lp,m_mp, m_gh)<<MMPR4(lp,mp,gh,loc))
const IdxTy rv=m_last;
if (m_first=BAD){  m_first=loc; m_last=loc; } 
else { m_last=loc; } 
return m_last;

}

IdxTy m_first, m_last;
IdxTy m_lp,m_mp,m_gh;

}; // tab_list_index_entry
typedef tab_list_index_entry  TabListIndexEntry;


typedef ntri_index<TabListIndexEntry,2> TabTermIndex;
typedef mjm_rods_array<Tr,TabTermIndex> TabTermBase;



class tab_term_cache : public TabTermBase
{
typedef TabTermBase Super;
typedef std::vector<TabTerm> TabTermVector;
public:
typedef TabTerm tab_term; 
// why the FUDD
typedef typename Super::data_type data_type; // FUDD
tab_term_cache() : m_state(0) {}
void add(const tab_term & t) {
if (m_state!=0) { MM_ERR(" already compiled "<<t.dump()) }
 m_vec.push_back(t); } 
bool  next( tab_term & t) 
{
IdxTy n =t.next();
if (n==t.bad()) return false;
t=m_vec[n];
return true; 
}
bool  operator()(tab_term & t, const IdxTy lp, const int mp, const int gh )
//{return (*this)(Tindex::index(l,m)); } 
{
if (m_state==0) { MM_ERR(" not compiled "<<MMPR3(lp,mp,gh)<<t.dump()) }
data_type & idx= ((Super*)(this))->operator()(Tindex::index(lp,gh+(mp<<1))); 
if ( idx.first==idx.bad()) return false;
t= m_vec[idx.m_first];
return true; 
} 
IdxTy operator()( const IdxTy lp, const int mp, const int gh )
{ return ((Super*)(this))->operator()(Tindex::index(lp,gh+(mp<<1)));  } 

data_type &  operator()(const IdxTy n )
{
return ((Super*)(this))->operator()(n);  
} 
void compile()
{
const IdxTy sz=m_vec.size();
for(IdxTy i=0; i<sz; ++i)
{
tab_term & t= m_vec[i];
IdxTy loc=(*this)(t.m_lp,t.m_mp,t.m_gh);
data_type & ie=(*this)(loc);
const IdxTy last=ie.add_link(i,t.m_lp,t.m_mp,t.m_gh);
t.m_here=i;
if (last!=ie.bad())
{
m_vec[last].m_next=i; 
t.m_prior=last;
}

} // i 
m_state=1;

} // compile


StrTy dump(const IdxTy flags)
{
Ss ss;
ss<< "Called the right code "<<Super::used()<<CRLF;
// why the FUDD can't it find this shot 
const IdxTy sz=Super::used();
for(IdxTy i=0; i<sz; ++i)
{
ss<<i<<" "<<(*this)(i).to_string()<<CRLF;
}
return ss.str();
}
TabTermVector m_vec;
IdxTy m_state;
}; // tab_term_cache 

typedef tab_term_cache TabTermCache;
*/

// typedef typename Tr::MyBlock  MyBlock;
public:
typedef Poly Polynomial ;
//typedef std::vector<Coef> Polytype;
// need to fix this no reason for it 
typedef Polynomial PolyType;
mjm_legendre_stuff() {}
~mjm_legendre_stuff() {}

// return just the polynomial part 
// P_l^m(x) =(-1)^m/ 2^l /l! (1-x^2)^(m/2) (d/dx)^(l+m)(x^2-1)^l
// leaving the (1-x^2)^(m/2)
Poly leg_piece(const IdxTy l, const int  m, const IdxTy flags=0) {return LegPiece( l,  m, flags ) ; } 
Coef eval(const Coef & cost, const Coef & sint,const IdxTy l, const int m, const IdxTy der) 
{  return Eval(cost,sint,l,m,der ); }
Coef eval(const D & theta,const IdxTy l, const int m, const IdxTy der) 
{  return Eval(theta,l,m,der ); }
Coef eval_no_sine(const D & cost,const IdxTy l, const int m) 
{  return EvalNoSine(cost,l,m); }

const PolyType & poly_no_sine( const IdxTy l, const int m) //  const 
{return  PolyNoSine( l, m) ; } 


void make_cache(const IdxTy lmax, const IdxTy flags) { MakeCache(lmax,flags); }
StrTy print(const Poly & p)
{ return m_mi.print_polynomial(p,0,"x"); }
Coef schmidt_normalization( const IdxTy l, const IdxTy m )
{ return  SchmidtNormalization(  l,  m ); } 


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
void MakeCache(const IdxTy lmax, const IdxTy flags) {
m_cache.size(Tindex::size(lmax),1<<2); 
for(IdxTy l=0; l<=lmax; ++l)
{
for(IdxTy m=0; m<=l; ++m)
{
//MM_ERR(" making "<<MMPR2(l,m))
LegPiece(l,m,flags);
//MM_ERR(" made "<<MMPR3(l,m,m_desc.to_string()))
// this won't work because we assume an ordering, need to call
//m_cache.append(m_desc);
// I guess a subclass would be better :)
//m_cache(Tindex::index(l,m))=m_desc;
//MM_ERR(" had  "<<MMPR(m_cache(0).to_string()))
m_cache(l,m)=m_desc;
//MM_ERR(" stored s  "<<MMPR3(l,m,m_cache(l,m).to_string()))
} // m 

} // l 


}// MakeCache

Coef Eval(const D & theta, const IdxTy l, const int m, const IdxTy der) 
{
const D c=cos(theta);
const D s=sin(theta);
return Eval(c,s,l,m,der);
}
Coef Eval(const Coef & cost, const Coef & sint, const IdxTy l, const int m, const IdxTy der) 
{
// there is no const paren operator now. 
const Desc & d= m_cache(l,m);
//MM_ERR(" eval "<<MMPR3(l,m,d.shot_fudd()))
return d.at_theta(cost,sint,der);
}

Coef EvalNoSine(const Coef & cost, const IdxTy l, const int m) 
{
// there is no const paren operator now. 
const Desc & d= m_cache(l,m);
//MM_ERR(" eval "<<MMPR3(l,m,d.shot_fudd()))
return d.at_theta_no_sine(cost);
}
const PolyType & PolyNoSine( const IdxTy l, const int m) //  const 
{ 
const Desc & d= m_cache(l,m);
return d.poly();
}

Coef SchmidtNormalization( const IdxTy l, const IdxTy m )
{
if (m==0) return Coef(1);
Coef c=1;
//if (odd) c=-c;
if ((m&1)!=0) c=-c;
Coef f=.5;
// this junk could be cached except normally the result is
// cacned anyway. 
for(IdxTy i=(1+l-m); i<=(l+m); ++i) if (i!=0) f=f*i;
c=c/sqrt(f);
return c;
}

// leaving behind sqrt term but taking the int part of that, 
// P_l^m(x) =(-1)^m / 2^l /l! [ ---  (1-x^2)^(m/2) --- ] (d/dx)^(l+m)(x^2-1)^l
// P_l^m(x) =(-1)^m / 2^l /l! [ ---  (1-x^2)^(1/2) --- ] (d/dx)^(l+m)(x^2-1)^l
// this is a polynomial in x, NOT cos(\theta)
Poly LegPiece(const IdxTy l, const int  m,const IdxTy flags) {
const bool norm_schmidt=Bit(flags,0);
if (m<0) { MM_ERR(" negative m not work, "<<MMPR2(l,m)) } 
Poly p,q;
// x^2-1
q.push_back(-1);
q.push_back(0);
q.push_back(1);
m_mi.power_polynomial(p,q,l);
m_mi.differentiate_polynomial(q,p,l+m);
//MM_ERR(MMPR4(print(p),print(q),l,m))
p=q;
const int mf=m&~1; 
// get any of the sin terms leaving just a possible 1/2 power
// there is (1-x^2)^(m/2) leading term, 
Poly s,r,t;
t.push_back(1);
t.push_back(0);
t.push_back(-1);
// floor(m/2)
m_mi.power_polynomial(s,t,m>>1);
m_mi.multiply_polynomials(r,s,q);

 bool odd=(mf!=m);
Coef lfac=1;
// this and 2^l should be coordinate with the factiriuals in the
// differentiation. 
for(IdxTy i=2; i<=l; ++i) lfac*=i; 
Coef c=odd?(-1):1;
//MM_ERR(MMPR4(m,mf,c,odd))
// this needs a Coef specific impl and hopefully the negative thing
// is implemented and save a division lol. 
//c=c*pow(Coef(2),-Coef(l))/lfac;
//c=c*pow(Coef(2),-(l))/lfac;
// predictably this failed with Coef double and l uint lol doh... 
c=c*dumpow(Coef(2),-int(l))/lfac;
//MM_ERR(MMPR3(c,l,lfac))
if (norm_schmidt&&(m!=0))
{
if (odd) c=-c;
Coef f=.5;
//for(IdxTy i=(l-m); i<(l+m); ++i) if (i!=0) f=f*i;
for(IdxTy i=(1+l-m); i<=(l+m); ++i) if (i!=0) f=f*i;
c=c/sqrt(f);
}

// instead of multiplying entire thing, just get the seeds 
m_mi.multiply_polynomial_nz(q,r,c);
m_mi.trim_polynomial(q);
//desc(const IdxTy l, const int m, const Poly & r,const Poly & rp, Mi * mip)
//: m_l(l),m_d(1),m_m(m),m_odd((m&1)!=0) m_r(r),m_r_prime(rp), mi(mip) {}
// the description also contains room for a derivative so include that 
Poly qp;
m_mi.differentiate_polynomial(qp,q);
m_mi.trim_polynomial(qp);
m_desc=Desc(l,m,q,qp,&m_mi);
//MM_ERR(" fudding done now "<<MMPR(m_desc.to_string()))
return q ; 

} 
Coef pow(const D & x, const int p) { return ::pow(x,D(p)); } 
Coef dumpow(const Coef & x, const int p) {
Coef c=Coef(1);
int pa=(p<0)?(-p):p;
while (pa>0) { c=c*x; --pa; }
if (p<0) return Coef(1)/c;
// return ::pow(x,D(p));
return c;

 } 

//m_mutex_vector = MutexVector(MU_SZ);
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const IdxTy flags=0) {Ss ss;  
ss<<" called wrong code";
ss<<m_cache.dump(flags);

return ss.str(); 
}
Desc m_desc;
TyCache m_cache;
//TabTermCache m_tab_cache;
Mi m_mi;

}; // mjm_legendre_stuff

//////////////////////////////////////////////

template <class Tr>
class mjm_legendre_stuff_map : public std::map<typename Tr::StrTy, mjm_legendre_stuff< Tr > >  
{
 typedef mjm_legendre_stuff_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_legendre_stuff< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_legendre_stuff_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_legendre_stuff_map




////////////////////////////////////////////
#ifdef  TEST_MJM_LEGENDRE_STUFF
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_LEGENDRE_STUFF "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_legendre_stuff<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_LEGENDRE_STUFF_H__ 
