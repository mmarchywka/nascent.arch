#ifndef MJM_SPARSE_EXPRESSIONS_H__
#define MJM_SPARSE_EXPRESSIONS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_string_tokenizer.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri Jan 10 18:34:49 EST 2020
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_sparse_expressions   
// g++ -std=gnu++11 -DTEST_MJM_SPARSE_EXPRESSIONS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_sparse_expressions.h  -lpthread -lreadline


// should move the legendre hermite etc here or somewhere for rational
// classes... 
template <class Tr, class Tcoef=double>
class mjm_numerical_expansions 
{
 typedef mjm_numerical_expansions Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// note this could be rational or infinite integers,  make things simple 
typedef  Tcoef Coef;
public:

// expand Cos^m(theta)Sin^n(theta) into a polynomial frequencies
// to allow analysis and easy integration. Note in general if n or m is
// odd, the things should integrate easily but this general case here
// does not care. For integrals often only the lower frequencies or DC
// will be nonzero and the rest is a waste
// 0 \leq l \leq m , 0 \leq j \leq n , w=l+j-(m+n)/2
// normalization ( 2^(n+m)(i)^n )^(-1) with sign intact
// but odd powers of i left to the user to deal with. 
Coef cmsn_norm(const IdxTy m, const IdxTy n ) { return CmsnNorm(m,n); }

Coef cmsn_w(const int twow, const IdxTy m, const IdxTy n )
{ return CmsnW(twow,m,n); } 

private:
Coef CmsnW(const int twow, const IdxTy m, const IdxTy n )
{
Coef c=Coef(0);
const int sum=m+n;
const bool has_dc=((sum&1)==0);
const bool is_zer=(((twow^sum)&1)!=0);
if (is_zer) return 0;
const int min12=twow+m-n;
const int max12=twow+m+n;
const int min1=SignExtend(min12,1); // (min12<0)?0:((min12)>>1);
const int max1=SignExtend(max12,1); // (max12<(0))?0:(max12>>1) ; // (twow+m+n)>>1;
const int min=(min1<0)?0:min1;
const int max=(max1>n)?n:max1;
//MM_ERR(MMPR4(min1,max1,min,max))
for(int j=min; j<=max; ++j)
{
bool minus=(((n-j)&1)!=0);
const int b1=((twow+sum)>>1)-j;
const Coef dc=MyBi(n,j)*MyBi(m,b1);
if (minus) c-=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
else c+=dc; // MyBi(n,j)*MyBi(m,((twow+sum)>>1)-j);
//MM_ERR(MMPR4(j,c,b1,dc))

}
if ((m+n)==0){  MM_ERR(" zero input returns "<<MMPR4(n,m,c,twow))}
return c;

} // CmsnW
int SignExtend(const int x, const IdxTy b)
{
if (x==0) return 0 ;
if (x>0) return x>>b;
return (x>>b)|(~(~0)>>b);

}
// I hate writing like this if there will be rationals... 
Coef CmsnNorm(const IdxTy m, const IdxTy n ) { 
if ((n+m)==0) return 1;
if ((n&2)==0) return  ::pow(.5,n+m); 
else return  -::pow(.5,n+m); 
}
Coef MyBi(const int n, const int k)
{
const int k2=n-k;
int max=(k2>k)?k2:k;
if (max==0) max=1;
const int min=(k2<k)?k2:k;
Coef p=Coef(1);
for(int j=max; j<=k; ++j) p=p*j;
Coef d=Coef(1);
for(int j=2; j<=min; ++j) d=d*j;
return p/d;
}


}; //  mjm_numerical_expansions 

template <class Tr, class Tcoef=double>
class mjm_sparse_expressions 
{
 typedef mjm_sparse_expressions Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// note this could be rational or infinite integers,  make things simple 
typedef  Tcoef Coef;

typedef mjm_numerical_expansions<Tr,Coef> Expander;

typedef string_tokenizer Tokenizer;
typedef std::map<IdxTy,Coef> NomialValues;
typedef std::map<IdxTy,IdxTy> RefCounts;

public:
class special_case_flags
{
typedef  special_case_flags Myt;
typedef std::vector<IdxTy> Vars;
typedef std::vector<StrTy> VarNames;
public:
special_case_flags(const IdxTy code) : m_code(code) {}
IdxTy special_case() const { return m_code; } 
IdxTy code() const { return m_code; } 
int var(const IdxTy i) const { return m_vars[i]; } 
const StrTy  var_name(const IdxTy i) const { return m_var_names[i]; } 
Myt & push_var(const IdxTy i ) { m_vars.push_back(i); return *this; } 
Myt & push_var(const StrTy & i ) { m_var_names.push_back(i); return *this; } 
const IdxTy var_size() const { return m_vars.size();  }
const IdxTy names_size() const { return m_var_names.size();  }
enum {
TRIG_POLY_ZERO_PI,
TRIG_POLY_ZERO_2PI,
EOE
};
StrTy dump()
{
Ss ss;

return ss.str();
}
private:

IdxTy m_code;
VarNames m_var_names;
Vars m_vars;

}; // special_case_flags

typedef special_case_flags SpecParams;
private:
// this should use a string tokenizer but normally speed or size not 
// a factor, it is annoying to use strings ... 
class nomial_term
{

typedef nomial_term Myt; 
typedef  mjm_numerical_expansions<Tr, Coef> NumEx; 
public:
typedef std::map<IdxTy,int> NomialMap;
// this really needs ONLY a map ctor but the stupid collections
// IIRC need defaults...and so does new [] wtf
nomial_term(): m_index_hash(0) {  } 
nomial_term(const NomialMap & nm): m_index_hash(0)  {  m_terms=nm; } 
nomial_term(const NomialMap & nm, const IdxTy h ): m_index_hash(h)  {  m_terms=nm; } 
IdxTy hash() const { return m_index_hash; }
void zero_term( const IdxTy var ) 
 { ZeroTerm(*this,  var ); }  
 
int power(const IdxTy var) const
{
const auto & f=m_terms.find(var);
if (f==m_terms.end()) return 0;
return (*f).second;
}
// this too is stupid as the term map should be set once
// and const forever after... 
void rehash() const { Rehash(); }  
// for now just let us calculate it 
//IdxTy hash(const IdxTy h )  { m_index_hash=h;  return m_index_hash; }
bool operator==(const Myt & that) const  { return Equals(that); } 
// need alt with powers stored... 
Coef evaluate(const NomialValues & v) const 
{ return Evaluate(v); } 
StrTy dump(Tokenizer * st, const IdxTy flags) const 
{ return Dump(st,flags); } 
// this should be the other way around, returning a 
// properly constructed const Myt  and updating a coef... 
Coef evaluated(Myt & n, const NomialValues & v) const
{ return Evaluated(n,v); } 
void powers(Myt & n, const Myt & that, const int pthis, const int pthat) const
{ Powers(n, that, pthis, pthat) ; }  

// using a map of vars would eliminate temp terms of
// no interest... 
Coef diff_int(Myt & n, const IdxTy var, const IdxTy flags) const
{ return  DiffInt( n, var,  flags); } 
// this is at the term level now, the integration can create
// many terms but with differing arguments so need to evaluate as
// there is no function concept just vars
Coef trig_diff_int(Myt & n, const IdxTy varc, const IdxTy vars, const Coef & a, const Coef & b, const IdxTy flags)
{ return TrigDiffInt(n,varc, vars, a,  b,  flags); } 
// if possible, return single coef but now the single term 
// needs to be in a hokey array...  
//IdxTy ad_hoc(Myt ** n_p, Coef ** coefs_p,  const SpecParams & sp )
// use this sig when possible 
Myt ad_hoc( Coef & coef,   SpecParams * sp ) const
{return  AdHoc(  coef, sp ) ; } 



//t.expand(nt,var,(*jj).first);
void expand(Myt & n, const IdxTy var, const Myt & ti) const
{

Expand( n, var,  ti); //  const
}

private:

Myt AdHoc( Coef & coef,   SpecParams * sp ) const
{
switch (sp->code())
{

case SpecParams::TRIG_POLY_ZERO_PI: { return ZeroToPI(coef,sp,1); } 
case SpecParams::TRIG_POLY_ZERO_2PI: { return ZeroToPI(coef,sp,2); } 
default: MM_ERR(" bad code in AdHoc "<<MMPR2(dump(0,0),((*sp).dump())))
} // switch 
coef=Coef(1);
return *this; 
} //AdHoc
Myt ZeroToPI( Coef & c,  const SpecParams * sp, const IdxTy npi ) const 
{
Myt n=*this;
c=Coef(0);
const int varc=sp->var(0);
const int vars=sp->var(1);

ZeroTerm(n,varc);
ZeroTerm(n,vars);
const int pc = VarPo(varc);
const int ps = VarPo(vars);
NumEx numex;
// cos,sin
Coef norm=numex.cmsn_norm(pc,ps); 

//cmsn_w(const int twow, const IdxTy m, const IdxTy n )
Coef cdc=numex.cmsn_w(0,pc,ps);
// no longer supports rats... 
if (npi==1) c=cdc*M_PI;
else if (npi==2) c=cdc*(M_PI+M_PI);
int omega=0;
if (npi==1)
{
++omega;
Coef plus=numex.cmsn_w(omega,varc,vars);
Coef neg=numex.cmsn_w(-omega,varc,vars);
if (neg==(-plus)) 
{
c+=Coef(-2*plus); // normalization picks uip the sin denominator.
} // neg == -plus 
else if (neg!=plus) {
MM_ERR(" plus minus not right "<<MMPR4(plus,neg,omega,cdc)<<MMPR3(pc,ps,npi)) 
}// - != + 

}
if (npi>2)
{ MM_ERR(" can't handle npi too big "<<MMPR(npi))}

if (c!=0) c=c*norm;
return n;
}
const bool Bit(const IdxTy flags, const IdxTy b) const
{ return ((flags&(1<<b))!=0); } 
void Expand(Myt & n, const IdxTy var, const Myt & ti) const
{
//MM_ERR("xxxadf")
n.m_terms=m_terms;
//MM_ERR("fooxxxadf")
n.m_terms[var]=0;
//MM_ERR("adsfasxxxadf")
n.m_terms.erase(n.m_terms.find(var));
//MM_ERR("adcasdcxxxadf")
Power(n.m_terms,ti.m_terms,1);
//MM_ERR("adf")
//void Power(NomialMap & nn, const NomialMap & nx, const int p) const

}
void ZeroTerm(Myt & n, const IdxTy var ) const
{
n.m_terms[var]=0;
n.m_terms.erase(n.m_terms.find(var));
}

const int VarPo(const IdxTy var) const
{
const auto ii=m_terms.find(var);
const bool have= (ii!=m_terms.end());
const int px=have?(*ii).second:0;
return px;
}
Coef TrigDiffInt(Myt & n, const IdxTy varc, const IdxTy vars, const Coef & a, const Coef & b, const IdxTy flags)
{
const int pc = VarPo(varc);
const int ps = VarPo(vars);
n.m_terms=m_terms;
n.m_terms[varc]=0;
n.m_terms[vars]=0;
n.m_terms.erase(n.m_terms.find(varc));
n.m_terms.erase(n.m_terms.find(vars));
Coef c=0;

return c;
}

Coef DiffInt(Myt & n, const IdxTy var, const IdxTy flags) const
{
//const auto ii=m_terms.find(var);
//const bool have= (ii!=m_terms.end());
//const int px=have?(*ii).second:0;
const int px = VarPo(var);
//const bool diff=Bit(flags,1);
const IdxTy br=flags&255;
switch (br)
{
case 0:  // differentiate 
{
if (px==0) return Coef(0);
n.m_terms=m_terms;
n.m_terms[var]=px-1;
return Coef(px); 
}
case 1:  // integrate 
{
//if (px==0) return Coef(0);
if (px==(-1)) MM_ERR(" unable to integrate -1 "<<MMPR(flags)<<" "<<Dump(0,0))
n.m_terms=m_terms;
n.m_terms[var]=px+1;
// should return nan or something similar... 
return Coef(1)/Coef(px+1); 
}
default : MM_ERR(" unrecognized op "<<MMPR(flags)<<" "<<Dump(0,0))
}; // switch 

return Coef(0); 
} // DiffInt

void Powers(Myt & n, const Myt & that, const int pthis, const int pthat) const
{
Power(n,*this,pthis);
Power(n,that,pthat);

}
void Power(Myt & n, const Myt & x, const int p) const
{
Power(n.m_terms,x.m_terms,p);
//MM_LOOP(ii,x.m_terms) { 
//const IdxTy i=(*ii).first; 
//const int px=(*ii).second; 
//n.m_terms[i]+=p*px;
//}
}

//NomialMap m_terms;
void Power(NomialMap & nn, const NomialMap & nx, const int p) const
{
MM_LOOP(ii,nx) { 
const IdxTy i=(*ii).first; 
const int px=(*ii).second; 
nn[i]+=p*px;
}
}

Coef Evaluated(Myt & n, const NomialValues & v) const
{
//MM_LOOP(ii,m_terms) { MM_ERR("terms "<< MMPR2((*ii).first,(*ii).second)) }
//MM_LOOP(ii,v) { MM_ERR("vals "<< MMPR2((*ii).first,(*ii).second)) }
Coef c=Coef(1);
MM_LOOP(ii,m_terms)
{
const IdxTy var=(*ii).first;
int poww=(*ii).second;
if (poww==0) continue;
const auto jj=v.find(var);
if (jj==v.end()) {n.m_terms[(*ii).first]=(*ii).second;  continue; } 
const Coef & val=(*jj).second;
PowEval( c,  val, poww);
} // ii 
return c;
} // Evaluated

Coef Evaluate(const NomialValues & v) const 
{
Coef c=Coef(1);
// a constant is ok doh 
//if (m_terms.size()==0) return 0; 
//MM_LOOP(ii,m_terms) { MM_ERR("terms "<< MMPR2((*ii).first,(*ii).second)) }
//MM_LOOP(ii,v) { MM_ERR("vals "<< MMPR2((*ii).first,(*ii).second)) }
MM_LOOP(ii,m_terms)
{
const IdxTy var=(*ii).first;
// should zero be pruned? 
int poww=(*ii).second;
MM_ERR(MMPR2(var,poww))
if (poww==0) continue;
const auto jj=v.find(var);
if (jj==v.end()) return Coef(0);
const Coef & val=(*jj).second;
PowEval(c,val,poww);

}
MM_ERR(MMPR(c))
return c;
}
void PowEval(Coef & c, const Coef & val, int poww) const
{
// arrghhhh
if (poww>0) { while (poww>0) { c=c*val; --poww; } }
else {
const Coef vi=1/val;
while (poww<0) { c=c*vi; ++poww; }
//MM_ERR(MMPR(c))
//while (poww<0) { c=c/val; --poww; }
}



} // PowEval


StrTy Dump(Tokenizer * st, const IdxTy flags) const 
{
Ss ss;
if (st!=0) 
{ MM_LOOP(ii,m_terms) { ss<<(*st)((*ii).first)<<"^"<<(*ii).second; } } 
else
{
{ MM_LOOP(ii,m_terms) { ss<<" .no st. "<<((*ii).first)<<"^"<<(*ii).second; } } 

}
return ss.str();
}
bool Equals(const Myt & that) const 
{
return ( m_terms==that.m_terms);
}
// this should never be needed 
void Rehash() const
{
m_index_hash=0;
MM_LOOP(ii,m_terms) { m_index_hash+=(*ii).second<<((*ii).first&15); }  
}
// this really needs to be const.... 
NomialMap m_terms;
// doh 
mutable IdxTy m_index_hash;
}; // nomial_term

typedef nomial_term Term;

template <class Ty>
class term_heap
{
typedef Ty Term;
typedef std::vector<IdxTy> Hvec;
typedef std::map<IdxTy, Hvec> Hmap;
public:
IdxTy bad() { return ~0; } 
term_heap(){ Init(); }
~term_heap(){ Release(); }
// I guess this works ok 
const Term & operator()(const IdxTy n) { return m_heap[n]; }
// the look up returns references, these are not
// valid after a heap move doh,
bool refs_safe() const { return !m_safe_to_move; } 
void safe_to_move(const bool tf)  { m_safe_to_move=tf; } 
IdxTy find(const Term & t) { return Find(t); } 
StrTy dump(const IdxTy flags) { return  Dump( flags) ; } 
private:
IdxTy Find(const Term & t)
{
// index later
//for(IdxTy i=0; i<m_used; ++i) if (m_heap[i]==t) return i; 
IdxTy loc=FindOnly(t);
if (loc!=bad()) return loc;
return Alloc(t);
}
IdxTy Alloc(const Term & t)
{
// danger will robinson - the () look up returns references
// which are addresses, all the expands screw that up ... 
// the hysterisis was turned off for testing but now appears to work
if (m_used>(m_sz>>1) ) 
Expand(m_used+100);
if (m_used==m_sz)
{
MM_ERR(" term heap filled up will bomb now "<<MMPR3(m_used,m_sz,t.dump(0,0)))
}
m_heap[m_used]=t;
const IdxTy u=m_used;
auto & vv =m_index[t.hash()];
vv.push_back(u);
++m_used;
return u; 
}



IdxTy FindOnly(const Term & t)
{
// index later
t.rehash();
const auto & vv =m_index[t.hash()];
//for(IdxTy i=0; i<m_used; ++i) if (m_heap[i]==t) return i; 
for(IdxTy i=0; i<vv.size(); ++i) if (m_heap[vv[i]]==t) return vv[i]; 
return bad();
}

void Release()
{
delete [] m_heap;
m_sz=0;
m_used=0;

}
void New(const IdxTy n)
{
Release();
m_heap=new Term[n];
m_sz=n;
m_used=0;
m_index.clear();
}
void Expand(const IdxTy n)
{
if (!m_safe_to_move) return; 
if (n<m_sz) return;
Term * heap = new Term[n];
// in theory this should work for m_heap==0 
for(IdxTy i=0; i<m_used; ++i ) heap[i]=m_heap[i];
m_sz=n;
delete[] m_heap;
m_heap=heap;


}


void Init() 
{
m_heap=0;
m_sz=0;
m_used=0;
m_safe_to_move=true;
New(100);
}
StrTy Dump(const IdxTy flags)
{
Ss ss;
MM_LOOP(ii,m_index)
{
ss<<(*ii).first;
const auto & v=(*ii).second;
MM_LOOP(jj,v) ss<<" "<<(*jj);
ss<<CRLF;
}
return ss.str();
}
Term * m_heap;
IdxTy m_sz;
IdxTy m_used;
Hmap m_index;
bool m_safe_to_move;

}; // term_heap

typedef term_heap<Term>  TermHeap;

class multinomial_thing
{
typedef multinomial_thing Myt;
typedef nomial_term Term;
typedef std::vector<IdxTy> Terms; 
typedef std::vector<Coef> Coefs; 
typedef std::map<IdxTy , Coef> TermsMap;
typedef std::map<IdxTy, int > NomialVars;
public:
multinomial_thing( ): m_st(0),m_th(0) {}
multinomial_thing(Tokenizer * st, TermHeap * th ): m_st(st),m_th(th) 
{

}
Coef evaluate(const NomialValues & v ) { return Evaluate(v); }
// partial evaluation generating a new Myt
Myt evaluated(const NomialValues & v ) { return Evaluated(v); }
void add_term(const IdxTy tidx, const Coef & c) {AddTerm( tidx, c); } 
bool remove_term(const IdxTy tidx) {return RemoveTerm( tidx); } 

Myt diff_int( const IdxTy var, const IdxTy flags) { return  DiffInt(  var, flags); } 

// return a polynomial that has been integrated between points a and b with evaluation
// needed to overcome lack of "function" vars and multiple angles changing the 
// arguments 
Myt trig_diff_int( const IdxTy varc, const IdxTy vars, const Coef & a, const Coef & b, const IdxTy flags) 
{ 
return  TrigDiffInt(  varc,vars, flags); 

} 



StrTy dump(const IdxTy flags) const  { return Dump(flags); } 

void count_refs(RefCounts & rc) {  CountRefs(rc); } 
Myt operator+(const Myt & that) const  { return Add(that,0); }
Myt operator-(const Myt & that) const  { return Add(that,1); }
Myt operator*(const Myt & that) const  { return Times(that,0); }
Myt operator*(const Coef & c) const  { return Times(c,0); }
Myt operator=(const Myt & that) { return Assign(that,0); }
Myt substitute(const IdxTy var, const Myt & s,const IdxTy flags) 
{ return Substitute(var,s,flags); }
template <class Ty> 
void add_polynomial(const IdxTy vidx, const Ty & v,const IdxTy flags)
{ AddPolynomial(vidx, v,flags); }

Myt ad_hoc(  SpecParams * sp )
{ return AdHoc(sp ); } 

private:

Myt AdHoc(   SpecParams * sp )
{
Myt x(m_st,m_th);
MM_LOOP(ii,m_map) 
{
const IdxTy tidx=(*ii).first;
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue;
Coef cnew;
Term nt=(*m_th)(tidx).ad_hoc(cnew,sp);
if (cnew !=Coef(0)) x.add_term((*m_th).find(nt),cnew*ci);
} // ii 

return x; 
}

template <class Ty> void AddPolynomial(const IdxTy vidx, const Ty & v,const IdxTy flags )
{

MM_SZ_LOOP(i,v,sz)
{
NomialVars nv;
nv[vidx]=i;
Term t(nv);
const Coef cnew=Coef(v[i]);
add_term((*m_th).find(t),cnew);
}

} // AddPolynomial

bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// this attempts to hold references while adding
// things to the heap which may cause errors so the heap
// needs to be locked or refs re-evaluated after a find
Myt Substitute(const IdxTy var, const Myt & that, const IdxTy flags) { 

Myt x(m_st,m_th);
MM_LOOP(ii,m_map) 
{ 
const IdxTy tidx=(*ii).first;
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue;
//x.m_map[(*ii).first]+=(*ii).second; 
// if the term contains var to a negative power, this fails.
// if it is positive we need to have computed powers of the new polynomial...
// this reference is not valid after a term find unless
// we mark the heap as fixed, 
const Term & t=(*m_th)(tidx);
const int p=t.power(var);
if (p<0) 
{ MM_ERR(" negative power "<<MMPR2(((*m_st)(var)),p)<<" "<<t.dump(m_st,0)) } 
if (p==0)
{
// remove the dead power
//const Coef cold=x.m_map[tidx];
//x.m_map.erase(x.m_map.find(tidx));
x.m_map[tidx]+=ci;
//Term nt=t;
//nt.zero_term(var);
//x.add_term((*m_th).find(nt),cold);
continue;
}
//MM_ERR(MMPR2(tidx, t.dump(m_st,0)))
// for positive powers, this generates a lot of terms... 
Myt xtemp(m_st,m_th);
xtemp=that;
// this should probably use a temp hash manager 
for(IdxTy i=1; i<p; ++i) {
//MM_ERR(MMPR4(i,p,xtemp.dump(0),that.dump(0)))
// this operation destroys existing references unless the 
// heap move was disabled... 
xtemp=xtemp*that;
 } 
//MM_ERR("t after power " << MMPR2(tidx,t.dump(m_st,0)))
MM_LOOP(jj,xtemp.m_map)
{
const Coef cnew= ci*(*jj).second;
if (cnew==Coef(0)) continue;
Term nt;
// the multiply above and the find below have invalidated
// prior t refs if the heap moved 
const Term & t=(*m_th)(tidx);
const Term & told=(*m_th)((*jj).first);
//MM_ERR(MMPR2((*jj).first,told.dump(m_st,0)))
//MM_ERR("t again " << MMPR2(tidx,t.dump(m_st,0)))
//t.expand(nt,var,(*m_th)((*jj).first));
t.expand(nt,var,told);
// this find invalidates the old refeences 
x.add_term((*m_th).find(nt),cnew);
} // jj
} // ii  

return x; 

}


Myt Assign(const Myt & x,const IdxTy flags )
{
m_st=x.m_st;
m_th=x.m_th;
m_map=x.m_map;
return *this;
}
Myt Add(const Myt & that, const IdxTy flags)const { 
const bool sub=Bit(flags,0);
Myt x(m_st,m_th);
MM_LOOP(ii,m_map) { x.m_map[(*ii).first]+=(*ii).second; } 
if (sub) 
{MM_LOOP(ii,that.m_map) { x.m_map[(*ii).first]-=(*ii).second; }  } 
else { MM_LOOP(ii,that.m_map) { x.m_map[(*ii).first]+=(*ii).second; }} 
return x; 
}
Myt Times(const Myt & that, const IdxTy flags)const  { 
//const bool sub=Bit(flags,0);
Myt x(m_st,m_th);
MM_LOOP(ii,m_map) { 
//x.m_map[(*ii).first]+=(*ii).second; 
const IdxTy tidx=(*ii).first;
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue;
MM_LOOP(jj,that.m_map)
{
const IdxTy tidxj=(*jj).first;
const Coef & cj=(*jj).second;
if (cj==Coef(0)) continue;
Term t;
(*m_th)(tidx).powers(t,(*m_th)(tidxj),1,1);
// this "find" invalidates the prior references if the heap
// is moved, however we do not appear to have any 
const IdxTy fadd=(*m_th).find(t);
//MM_ERR(" adding T "<<MMPR4(tidx,tidxj,fadd,t.dump(m_st,0)))
//x.add_term((*m_th).find(t),cj*ci);
x.add_term(fadd,cj*ci);
} // jj 
} // ii

//if (sub) 
//{MM_LOOP(ii,that.m_map) { x.m_map[(*ii).first]-=(*ii).second; }  } 
//else { MM_LOOP(ii,that.m_map) { x.m_map[(*ii).first]+=(*ii).second; }} 

return x; 
}
Myt Times(const Coef & c, const IdxTy flags)const  { 
//const bool sub=Bit(flags,0);
Myt x(m_st,m_th);
MM_LOOP(ii,m_map) { 
x.m_map[(*ii).first]=(*ii).second*c; 
} // ii
return x; 
}

Myt TrigDiffInt( const IdxTy varc, const IdxTy vars, const Coef & a, const Coef & b, const IdxTy flags) 
{
Myt x(m_st,m_th);
MM_LOOP(ii,m_map)
{
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue; 
Term t;
Coef cnew=((*m_th)((*ii).first)).trig_diff_int(t,varc,vars,a,b,flags);
if(cnew!=Coef(0)) x.add_term((*m_th).find(t),cnew*ci);
}


return x;
}

Myt  DiffInt( const IdxTy var, const IdxTy flags)
{
Myt x(m_st,m_th);
MM_LOOP(ii,m_map)
{
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue; 
Term t;
Coef cnew=((*m_th)((*ii).first)).diff_int(t,var,flags);
if(cnew!=Coef(0)) x.add_term((*m_th).find(t),cnew*ci);
}
/*
MM_SZ_LOOP(i,m_terms,sz)
{
const Coef & ci=m_coefs[i];
if (ci==Coef(0)) continue; 
// this returns a term but that is not stored yet. 
Term t;
Coef cnew=((*m_th)(m_terms[i])).diff_int(t,var,flags);
//if(cnew!=Coef(0)) x.add_term(cnew*ci,(*m_th)(m_terms[i]).evaluated(v));
if(cnew!=Coef(0)) x.add_term((*m_th).find(t),cnew*ci);
//MM_ERR(MMPR3(i,ci,cnew));
}
*/

return x;
} // DiffInt

void AddTerm(const IdxTy tidx, const Coef & c)
{
m_map[tidx]+=c;
//m_terms.push_back(tidx); m_coefs.push_back(c);
}

bool RemoveTerm(const IdxTy tidx)
{
auto ii=m_map.find(tidx);
if (ii==m_map.end()) return false; 
m_map.erase(ii);
}

void CountRefs(RefCounts & rc)  
{
//MM_LOOP(ii,m_terms) { ++ rc[(*ii)]; } 
MM_LOOP(ii,m_map) { ++ rc[(*ii).first]; } 
}

Myt Evaluated(const NomialValues & v )
{
Myt x(m_st,m_th);
//Coef c=Coef(0);
MM_LOOP(ii,m_map)
{
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue; 
Term t;
Coef cnew=((*m_th)((*ii).first)).evaluated(t,v);
if(cnew!=Coef(0)) x.add_term((*m_th).find(t),cnew*ci);
}
/*
MM_SZ_LOOP(i,m_terms,sz)
{
const Coef & ci=m_coefs[i];
if (ci==Coef(0)) continue; 
// this returns a term but that is not stored yet. 
Term t;
Coef cnew=((*m_th)(m_terms[i])).evaluated(t,v);
//if(cnew!=Coef(0)) x.add_term(cnew*ci,(*m_th)(m_terms[i]).evaluated(v));
if(cnew!=Coef(0)) x.add_term((*m_th).find(t),cnew*ci);
//MM_ERR(MMPR3(i,ci,cnew));
}
*/

return x;
}

Coef Evaluate(const NomialValues & v )
{
Coef c=Coef(0);
MM_LOOP(ii,m_map)
{
const Coef & ci=(*ii).second;
if (ci==Coef(0)) continue; 
c+=ci*(*m_th)((*ii).first).evaluate(v);

}
/*
MM_SZ_LOOP(i,m_terms,sz)
{
const Coef & ci=m_coefs[i];
if (ci==Coef(0)) continue; 
c+=ci*(*m_th)(m_terms[i]).evaluate(v);
//MM_ERR(MMPR3(i,ci,c));
}
*/
return c;
}

StrTy Dump(const IdxTy flags) const 
{
Ss ss;
StrTy sep="+";
IdxTy j=0;
MM_LOOP(ii,m_map)
{
const Coef & c= (*ii).second;
if (c!=0) 
{
const IdxTy tidx=(*ii).first;
if (j!=0) ss<<sep;  ss<<c<<(*m_th)(tidx).dump(m_st,flags); ++j; } 

}
/*
MM_SZ_LOOP(i,m_terms,sz)
{
const Coef & c= m_coefs[i];
if (c!=0) {if (j!=0) ss<<sep;  ss<<c<<(*m_th)(m_terms[i]).dump(m_st,flags); ++j; } 

}
*/
return ss.str();
}

Tokenizer * m_st;
TermHeap * m_th;
//Terms m_terms;
//Coefs m_coefs;
TermsMap m_map;

}; // multinomial_thing

typedef multinomial_thing Nomials;

class nomial_group
{
//typedef multinomial_thing Multi;
typedef std::map<IdxTy, Nomials> CollMap;
typedef std::map<StrTy,Coef> NomialCharVars;
typedef std::map<IdxTy,Coef> NomialTokVars;
typedef std::map<IdxTy, int > NomialVars;
public:
//typedef std::map<StrTy, IdxTy> term_map;
typedef std::map<StrTy, int > term_map;
Nomials & multinomial(const StrTy & nm) { return Multinomial(nm.c_str()); } 
Nomials & multinomial(const char *  nm) { return Multinomial(nm); } 

template <class Ty> 
void add_polynomial(const char *nm, const char * var, const Ty & v,const IdxTy flags)
{ AddPolynomial(nm, var,  v,flags); }

void add_term(const char * nm, const term_map & tm, const Coef & c)
{ AddTerm(nm,  tm,c); }
bool remove_term(const char * nm, const term_map & tm)
{ return RemoveTerm(nm,  tm); }

void  add(const char * d, const char * s1, const char * s2 )
{ multinomial(d)=multinomial(s1)+multinomial(s2); } 
void  subtract(const char * d, const char * s1, const char * s2 )
{ multinomial(d)=multinomial(s1)-multinomial(s2); } 
void  multiply(const char * d, const char * s1, const char * s2 )
{ multinomial(d)=multinomial(s1)*multinomial(s2); } 
void  multiply(const char * d, const char * s1, const Coef & c )
{ multinomial(d)=multinomial(s1)*c; } 


// replace variable var in s with sv 
void  substitute(const char * d, const char * s, const char * var, const char * sv, const IdxTy flags )
{ Substitute(d, s,var, sv,flags ); } 

Coef evaluate(const char * nm, const NomialCharVars & vars)
{ return  Evaluate(nm,vars); }

void  evaluate_to(const char * d, const char * s, const NomialCharVars & v ) 
{ return EvaluateTo(d,s,v); }

void diff_int(const char *d , const char *s, const char *var, const IdxTy flags)
{
DiffInt(d , s, var,  flags);
}
// integrate a polynomial as if it were a trig polynomial
// and evaluate. Currently there is no way to handle functions and
// angles that change during an operation so this is the best I can do 
// although making variable into functions could make this work
// and return something with different arguments. 
void trig_diff_int(const char *d , const char *s, const char *varc, const char * vars, const Coef & a, const Coef & b, const IdxTy flags)
{ TrigDiffInt(d , s,varc, vars, a,  b,  flags); } 
//void TrigDiffInt(const char *d , const char *s, const char *varc, const char * vars, const Coef & a, const Coef & b, const IdxTy flags)

void  ad_hoc(const char * d, const char * s,    SpecParams * sp )
{  
//int var(const IdxTy i) const { return m_vars[i]; } 
//const StrTy  var_name(const IdxTy i) const { return m_var_names[i]; } 
//Myt & push_var(const IdxTy i ) { m_vars.push_back(i); return *this; } 
//Myt & push_var(const StrTy & i ) { m_var_names.push_back(i); return *this; } 
const IdxTy sz=sp->names_size();
for(IdxTy i=0; i<sz; ++i) { (*sp).push_var(m_st((*sp).var_name(i))); }

multinomial(d)=multinomial(s).ad_hoc(sp); 

} 
StrTy dump(const IdxTy flags) { return Dump(flags); } 
StrTy dump(const char * nm, const IdxTy flags) { return Dump(nm,flags); } 
void count_refs(RefCounts & rc) { CountRefs( rc) ; } 
StrTy dump_refs(const IdxTy flags) { return  DumpRefs( flags) ; } 
private:

// add a polynomial in variable v from a vector or similar object of coefficients
template <class Ty> void AddPolynomial(const char *nm, const char * var, const Ty & v,const IdxTy flags )
{
const IdxTy vidx=m_st(var);
multinomial(nm).add_polynomial(vidx,v,flags);

}


// replace variable var in s with sv 
void  Substitute(const char * d, const char * s, const char * var, const char * sv,const IdxTy flags )
{
const IdxTy vidx=m_st(var);
multinomial(d)=multinomial(s).substitute(vidx,multinomial(sv),flags);

}

void TrigDiffInt(const char *d , const char *s, const char *varc, const char * vars, const Coef & a, const Coef & b, const IdxTy flags)
{
multinomial(d)=multinomial(s).trig_diff_int(m_st(varc),m_st(vars),a,b,flags);
}
void DiffInt(const char *d , const char *s, const char *var, const IdxTy flags)
{
multinomial(d)=multinomial(s).diff_int(m_st(var),flags);
}
void  EvaluateTo(const char * d, const char * s, const NomialCharVars & vars ) 
{
NomialTokVars tv;
MM_LOOP(ii,vars) { tv[m_st((*ii).first)]=(*ii).second; } 
multinomial(d)=multinomial(s).evaluated(tv);
}

Coef Evaluate(const char * nm, const NomialCharVars & vars)
{
NomialTokVars tv;
MM_LOOP(ii,vars) { tv[m_st((*ii).first)]=(*ii).second; } 
return multinomial(nm).evaluate(tv);

}
void AddTerm(const char * nm, const term_map & tm, const Coef & c)
{
NomialVars nv;
MM_LOOP(ii,tm) { nv[m_st((*ii).first)]=(*ii).second; } 
Term t(nv);
IdxTy tidx=m_th.find(t);
multinomial(nm).add_term(tidx,c);
}
bool  RemoveTerm(const char * nm, const term_map & tm)
{
NomialVars nv;
MM_LOOP(ii,tm) { nv[m_st((*ii).first)]=(*ii).second; } 
Term t(nv);
IdxTy tidx=m_th.find(t);
return multinomial(nm).remove_term(tidx);
}



void CountRefs(RefCounts & rc)  
{
MM_LOOP(ii,m_map) {(*ii).second.count_refs(rc); } 
}
StrTy  DumpRefs(const IdxTy flags) {
Ss ss;
RefCounts rc;
CountRefs(rc);
MM_LOOP(ii,rc)
{
ss<<(*ii).first<<" "<<(m_th)((*ii).first).dump(&m_st,flags)
<<" "<<(*ii).second<<CRLF;
}
return ss.str();
} 

bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
StrTy Dump(const char * nm  , const IdxTy flags) {
Ss ss;
const auto ii=m_map.find(m_st(nm));
if (ii!=m_map.end())
{ ss<<m_st((*ii).first)<<" "<<(*ii).second.dump(0)<<CRLF;  }
else { ss<<nm<<" not found"<<CRLF; } 
return ss.str();
}
StrTy Dump(const IdxTy flags) {
Ss ss;
const bool dump_heap_index=!Bit(flags,0);
// return Dump(flags);
MM_LOOP(ii,m_map)
{
ss<<m_st((*ii).first)<<" "<<(*ii).second.dump(0)<<CRLF; 

}
if (dump_heap_index)
{
ss<<CRLF<<" heap index "<<CRLF;
ss<<(m_th).dump(flags);
}

return ss.str();
 } 
Nomials & Multinomial(const char *  nm) { 
const IdxTy idx=m_st(nm);
if (m_map.find(idx)==m_map.end()) m_map[idx]= Nomials(&m_st, &m_th);
return m_map[idx]; 
} 
// could get really clever and use different ones.. 
Tokenizer m_st;
TermHeap m_th;
CollMap m_map;

}; // nomial_group

typedef nomial_group MyMultiNomials;
public:
mjm_sparse_expressions() {}
~mjm_sparse_expressions() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; ss<<m_mn.dump(flags);  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
public:
 MyMultiNomials m_mn;
}; // mjm_sparse_expressions

//////////////////////////////////////////////

template <class Tr>
class mjm_sparse_expressions_map : public std::map<typename Tr::StrTy, mjm_sparse_expressions< Tr > >  
{
 typedef mjm_sparse_expressions_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_sparse_expressions< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_sparse_expressions_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_sparse_expressions_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SPARSE_EXPRESSIONS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SPARSE_EXPRESSIONS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef double D;
typedef mjm_sparse_expressions<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.m_mn.dump(cip.myatoi(cip.p1))) }
if (cmd=="refs") { MM_ERR(x.m_mn.dump_refs(0)) }
if (cmd=="add") { 
//std::map<StrTy, unsigned int > vv;
std::map<StrTy, int > vv;
const StrTy & nomial=cip.p1;
const D coef=atof(cip.p2.c_str());
IdxTy i=4;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=cip.myatoi(cip.words()[i].c_str());  i+=2; }
 x.m_mn.add_term(nomial.c_str(),vv,coef);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="eval") { 
std::map<StrTy, double > vv;
const StrTy & nomial=cip.p1;
//const D coef=atof(cip.p2.c_str());
IdxTy i=3;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=atof(cip.words()[i].c_str());  i+=2; }
MM_ERR(MMPR( (x.m_mn.evaluate(nomial.c_str(),vv))));
//MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="evaled") { 
std::map<StrTy, double > vv;
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
//const D coef=atof(cip.p2.c_str());
IdxTy i=4;
IdxTy iend=cip.words().size();
while ( i<iend) 
{ vv[cip.words()[i-1]]=atof(cip.words()[i].c_str());  i+=2; }
//MM_ERR(MMPR( (x.m_mn.evaluated(srcnomial.c_str(),vv))));
x.m_mn.evaluate_to(destnomial.c_str(),srcnomial.c_str(),vv);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="diffint") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & var=cip.wif(3);
const IdxTy flags =cip.myatoi(cip.wif(4));
//MM_ERR(MMPR( (x.m_mn.evaluated(srcnomial.c_str(),vv))));
x.m_mn.diff_int(destnomial.c_str(),srcnomial.c_str(),var.c_str(),flags);
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="+") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.add(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="-") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.subtract(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }
if (cmd=="*") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & src2nomial=cip.wif(3);
x.m_mn.multiply(destnomial.c_str(),srcnomial.c_str(),src2nomial.c_str());
MM_ERR(x.m_mn.dump(0))
 }

//void  substitute(const char * d, const char * s, const char * var, const char * sv, const IdxTy flags )
if (cmd=="sub") { 
const StrTy & destnomial=cip.p1;
const StrTy & srcnomial=cip.p2;
const StrTy & var=cip.wif(3);
const StrTy & src2nomial=cip.wif(4);
const IdxTy flags =cip.myatoi(cip.wif(5));
x.m_mn.substitute(destnomial.c_str(),srcnomial.c_str(),var.c_str(),src2nomial.c_str(),flags);
MM_ERR(x.m_mn.dump(0))
 }

//void diff_int(const char *d , const char *s, const char *var, const IdxTy flags)
if (cmd=="?") { 
std::ostream &  os=std::cout;
os<<" dump flags "<<CRLF;
os<<" refs "<<CRLF;
os<<" add nomial coef var val var val ...  "<<CRLF;
os<<" eval nomial var val var val ...  "<<CRLF;
os<<" evaled destnomial srcnomial var val var val ...  "<<CRLF;
os<<" diffint destnomial srcnomial var flags  "<<CRLF;
os<<" + destnomial srcnomial src2nomial  "<<CRLF;
os<<" - destnomial srcnomial src2nomial  "<<CRLF;
os<<" * destnomial srcnomial src2nomial  "<<CRLF;
os<<" sub destnomial srcnomial var exprnomial  "<<CRLF;
}

//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SPARSE_EXPRESSIONS_H__ 
