#ifndef MJM_FASTA_TO_SVG_H__
#define MJM_FASTA_TO_SVG_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_layout_info.h"
#include "mjm_strings.h"
#include "mjm_string_index.h"

#include "mjm_color_table.h"


#include "mjm_fasta_ii.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_svg_writer.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Sep  8 09:40:37 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_fasta_to_Svg   
// g++  -Wall -std=gnu++11 -DTEST_MJM_FASTA_TO_SVG -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_fasta_to_Svg.h  -o mjm_fasta_to_Svg.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_fasta_to_Svg("mjm_fasta_to_Svg"
, "  ");

template <class Tr>
class mjm_fasta_to_Svg 
{
 typedef mjm_fasta_to_Svg Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_fasta::fasta_file Fasta;
typedef Fasta::Ssb Ssb;
typedef std::map<StrTy, Fasta> FastaMap;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;

typedef mjm_canned_methods Canned;

typedef mjm_layout_info<Tr> LayoutInfo;

typedef mjm_svg_writer Sw;

public:
mjm_fasta_to_Svg() {}
~mjm_fasta_to_Svg() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
typedef LayoutInfo layout_info_type;
IdxTy write_svg( OsTy & os, const Fasta & fasta, const LayoutInfo & li,const IdxTy flags )
{return WriteSvg(os,fasta,li,flags);
}
IdxTy write_txt( OsTy & os, const Fasta & fasta, const LayoutInfo & li,const IdxTy flags )
{return WriteTxt(os,fasta,li,flags);
}

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

class laying_out_info
{
public:
typedef std::map<IdxTy, IdxTy> ActiveSet;
ActiveSet actives;

}; // laying_out_info 

class svg_output_class
{

public:
svg_output_class( OsTy & _os) : os(_os) {}
template <class Tl> IdxTy start(const Tl & li)
{
const IdxTy xs=li.total_x(); // 100;
const IdxTy ys=li.total_y(); // 100;
os<<sw.start_text(" test foo",xs,ys);
os<<sw.frame_text("#00808080",xs,ys);
MM_ERR(MMPR2(xs,ys))
return 0; 
} // start
//ot.write_names(li,la,posv);
template <class Tp,class Tl,class Ti >
IdxTy write_names(const Tl &loi, const Fasta & fasta,  const Ti & li, const Tp & posv)
{
auto & la=loi.actives;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
const StrTy & nm=fasta.name(seq);
const D x1=li.xname(seqp);
const D y1=li.yname(seqp);
const D nsz=li.szname(seqp);
const StrTy fcolor="red";
ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("start"),0);
} // ii 
return 0;
} // write_names



//ot.write_col(colstr,seqp,col);
template <class Tc, class Ts , class Tp, class Tl,class To  >
IdxTy write_col(const Tc & colstr,const Ts & schem,const Tp & posv,const To & loi, const Tl  & li ,const IdxTy col)
{
auto & la=loi.actives;
MM_ERR(MMPR4(__FUNCTION__,col,la.size(),colstr.size()))
if (la.size()>colstr.size()) return 0; 
IdxTy i=0;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
// gtext_text(const StrTy &text, const D& x, const D& y, const D & sz, const StrTy & color="#00ffffff", const StrTy & anchor="left",const D & angle=45) const
const D x1=li.x(seqp,col);
const D y1=li.y(seqp,col);
const D w=li.w(seqp,col);
const D h=li.h(seqp,col);
const D tsz=li.base_size(seqp,col);
const StrTy bcolor=schem[i].bg; // "black";
const StrTy fcolor=schem[i].fg; // "white";
//StrTy rect_text( const StrTy& x, const StrTy& y, const StrTy & w, const StrTy & h, const StrTy & color="#00ffffff") const
ssseq<<sw.rect_text(x1,y1,w,h,bcolor);
ssseq<<sw.gtext_text(colstr[i],x1+w/2,y1,tsz,fcolor,StrTy("middle"),0);
++i;
} // ii 
return 0; 
} // write_col

IdxTy fini()
{
os<<ssseq.str();
os<<ss.str();
os<<sw.end_text();
os<<CRLF;
return 0; 
} // fini

OsTy & os;
Sw sw;
Ss ssseq,ss;
}; // svg_output_class
//////////////////////////////////////////


class txt_output_class
{

public:
txt_output_class( OsTy & _os) : os(_os) {}
template <class Tl> IdxTy start(const Tl & li)
{
const IdxTy xs=li.total_x(); // 100;
const IdxTy ys=li.total_y(); // 100;
//os<<sw.start_text(" test foo",xs,ys);
//os<<sw.frame_text("#00808080",xs,ys);
MM_ERR(MMPR2(xs,ys))
return 0; 
} // start
//ot.write_names(li,la,posv);
template <class Tp,class Tl,class Ti >
IdxTy write_names(const Tl &loi, const Fasta & fasta,  const Ti & li, const Tp & posv)
{
auto & la=loi.actives;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
const StrTy & nm=fasta.name(seq);
const D x1=li.xname(seqp);
const D y1=li.yname(seqp);
const D nsz=li.szname(seqp);
const StrTy fcolor="red";
//ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("start"),0);
} // ii 
return 0;
} // write_names



//ot.write_col(colstr,seqp,col);
template <class Tc, class Ts , class Tp, class Tl,class To  >
IdxTy write_col(const Tc & colstr,const Ts & schem,const Tp & posv,const To & loi, const Tl  & li ,const IdxTy col)
{
typedef mjm_color_table CtTy;
const StrTy rest=CtTy::vt100("test","redb",0);
//printf("%s \n",rest.c_str());
MM_ERR(rest<<" red ")
auto & la=loi.actives;
MM_ERR(MMPR4(__FUNCTION__,col,la.size(),colstr.size()))
if (la.size()>colstr.size()) return 0; 
IdxTy i=0;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
// gtext_text(const StrTy &text, const D& x, const D& y, const D & sz, const StrTy & color="#00ffffff", const StrTy & anchor="left",const D & angle=45) const
const D x1=li.x(seqp,col);
const D y1=li.y(seqp,col);
const D w=li.w(seqp,col);
const D h=li.h(seqp,col);
const D tsz=li.base_size(seqp,col);
const StrTy bcolor=schem[i].bg; // "black";
const StrTy fcolor=schem[i].fg; // "white";
//StrTy rect_text( const StrTy& x, const StrTy& y, const StrTy & w, const StrTy & h, const StrTy & color="#00ffffff") const
//ssseq<<sw.rect_text(x1,y1,w,h,bcolor);
//ssseq<<sw.gtext_text(colstr[i],x1+w/2,y1,tsz,fcolor,StrTy("middle"),0);
++i;
} // ii 
return 0; 
} // write_col

IdxTy fini()
{
//os<<ssseq.str();
//os<<ss.str();
//os<<sw.end_text();
os<<CRLF;
return 0; 
} // fini

OsTy & os;
Ragged r;
//Sw sw;
//Ss ssseq,ss;


}; // txt_output_class


///////////////////////////////////////

class Schem
{
public:
StrTy bg,fg;
}; // Schem
template <class Ts, class Tc, class Ti> 
void ColScheme(Ts & schems,const Tc & colstr, const Ti & li)
{
std::map<StrTy, int > histo;
MM_LOOP(ii,colstr) { --histo[*ii]; }
std::map< int , std::vector<StrTy> > fm;
MM_LOOP(ii,histo) fm[(*ii).second].push_back((*ii).first); 
histo.clear();
IdxTy i=0; 
MM_LOOP(ii,fm) { MM_LOOP(jj,(*ii).second)  { histo[*jj]=i;   } ++i;      }
MM_LOOP(ii,colstr)
{
int idx=histo[*ii];
// all equal, otherwise 2 differs are tied for most porbably ... doh 
if (histo.size()==1) {idx=~0; }
Schem x;
// in the case of two sequences that differ they 
// tie so this is misleading...
MM_ERR(MMPR3(fm.size(),histo.size(),idx))
switch (idx)
{
case ~0  : { x.bg="blue"; x.fg="yellow";  break; } 
case 0  : { x.bg="yellow"; x.fg="blue";  break; } 
case 1  : { x.bg="red"; x.fg="green";  break; } 
case 2  : { x.bg="blue"; x.fg="red";  break; } 

default: x.bg="black"; x.fg="white"; 
} // switch 
schems.push_back(x);

} // ii 



} // ColScheme
IdxTy WriteTxt( OsTy & os, const Fasta & fasta, const LayoutInfo & _li,const IdxTy flags )
{ txt_output_class ot(os); return WriteSvg(ot,fasta,_li,flags); } 


IdxTy WriteSvg( OsTy & os, const Fasta & fasta, const LayoutInfo & _li,const IdxTy flags )
{ svg_output_class ot(os); return WriteSvg(ot,fasta,_li,flags); } 



template< class OtTy>
IdxTy WriteSvg( OtTy & ot, const Fasta & fasta, const LayoutInfo & _li,const IdxTy flags )
{
const bool fill_to_end=true;
// scan fasta file and do layout
LayoutInfo li=_li;
laying_out_info loi;
IdxTy sz=0;
for (IdxTy i=0; i<fasta.size(); ++i)
{
loi.actives[i]=1;
if ( fasta.seq(i).length()>sz) sz=fasta.seq(i).length();
}
li.nseq(loi.actives.size());
li.length(sz);
MM_ERR(MMPR2(loi.actives.size(),sz))
auto & la=loi.actives;
std::vector<IdxTy> posv(la.size()?(1+(*(--la.end())).first):0);
IdxTy i=0;
MM_LOOP(ii,la) { posv[(*ii).first]=i; ++i; }
li.calc();
//Ss ss;
ot.start(li);
ot.write_names(loi,fasta,li,posv);
IdxTy col=0;
//while (la.size())
IdxTy actives=la.size();
while (actives)
{
std::vector<IdxTy> dun;
std::vector<StrTy> colstr;
std::vector<Schem> schems;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
const char *   sseq=fasta.seq(seq).c_str();
//const char c=fasta.seq(seq).c_str()[col];
char c=((*ii).second)?sseq[col]:'.';
if (c==0) { --actives;  
if (actives==0) break; // TODO redundant with loop test 
dun.push_back(seq); 
if (!fill_to_end) continue; 
c='.';
}
Ss ss; ss<<c;
colstr.push_back(ss.str());
} // ii 

ColScheme(schems,colstr, li);

ot.write_col(colstr,schems,posv,loi,li,col);


//MM_LOOP(ii,dun) { la.erase(la.find(*ii)); }
MM_LOOP(ii,dun) {la[*ii]=0; }
++col;
} // loi.actives

ot.fini();

return 0;
} // WriteSvg



#if 0 
IdxTy WriteSvgOld( OsTy & os, const Fasta & fasta, const LayoutInfo & _li,const IdxTy flags )
{
const bool fill_to_end=true;
// scan fasta file and do layout
LayoutInfo li=_li;
laying_out_info loi;
IdxTy sz=0;
for (IdxTy i=0; i<fasta.size(); ++i)
{
loi.actives[i]=1;
if ( fasta.seq(i).length()>sz) sz=fasta.seq(i).length();
}
li.nseq(loi.actives.size());
li.length(sz);
MM_ERR(MMPR2(loi.actives.size(),sz))
auto & la=loi.actives;
std::vector<IdxTy> posv(la.size()?(1+(*(--la.end())).first):0);
IdxTy i=0;
MM_LOOP(ii,la) { posv[(*ii).first]=i; ++i; }
li.calc();
Sw sw;
Ss ss;
const IdxTy xs=li.total_x(); // 100;
const IdxTy ys=li.total_y(); // 100;
os<<sw.start_text(" test foo",xs,ys);
os<<sw.frame_text("#00808080",xs,ys);
MM_ERR(MMPR2(xs,ys))
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
const StrTy & nm=fasta.name(seq);
const D x1=li.xname(seqp);
const D y1=li.yname(seqp);
const D nsz=li.szname(seqp);
const StrTy fcolor="red";
ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("start"),0);

} // ii 

// may use temp streams and merge at end.. 
// write names
Ss ssseq;
// wriete each column at a time...
IdxTy col=0;
//while (la.size())
IdxTy actives=la.size();
while (actives)
{
std::vector<IdxTy> dun;
MM_LOOP(ii,la)
{
const IdxTy seq=(*ii).first;
const IdxTy seqp=posv[seq];
const char *   sseq=fasta.seq(seq).c_str();
//const char c=fasta.seq(seq).c_str()[col];
char c=((*ii).second)?sseq[col]:'.';
if (c==0) { --actives;  
if (actives==0) break; // TODO redundant with loop test 
dun.push_back(seq); 
if (!fill_to_end) continue; 
c='.';
}
Ss ss; ss<<c;
// gtext_text(const StrTy &text, const D& x, const D& y, const D & sz, const StrTy & color="#00ffffff", const StrTy & anchor="left",const D & angle=45) const
const D x1=li.x(seqp,col);
const D y1=li.y(seqp,col);
const D w=li.w(seqp,col);
const D h=li.h(seqp,col);
const D tsz=li.base_size(seqp,col);
const StrTy bcolor="black";
const StrTy fcolor="white";
//StrTy rect_text( const StrTy& x, const StrTy& y, const StrTy & w, const StrTy & h, const StrTy & color="#00ffffff") const
ssseq<<sw.rect_text(x1,y1,w,h,bcolor);
ssseq<<sw.gtext_text(ss.str(),x1+w/2,y1,tsz,fcolor,StrTy("middle"),0);
} // ii 

MM_LOOP(ii,dun) { la.erase(la.find(*ii)); }
MM_LOOP(ii,dun) {la[*ii]=0; }
++col;
} // loi.actives


os<<ssseq.str();
os<<ss.str();
os<<sw.end_text();
os<<CRLF;
return 0;
} // WriteSvgOld
#endif





enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


// MEMBERS



}; // mjm_fasta_to_Svg

//////////////////////////////////////////////

template <class Tr>
class mjm_fasta_to_Svg_map : public std::map<typename Tr::StrTy, mjm_fasta_to_Svg< Tr > >  
{
 typedef mjm_fasta_to_Svg_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_fasta_to_Svg< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_fasta_to_Svg_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_fasta_to_Svg_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FASTA_TO_SVG
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_fasta_to_Svg <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FASTA_TO_SVG "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_fasta_to_Svg<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="svg") { //MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }
//typedef LayoutInfo layout_info_type;
//IdxTy write_svg( OsTy & os, const Fasta & fasta, const LayoutInfo & li,const IdxTy flags )
typedef mjm_fasta::fasta_file Fasta;
typedef Myt::layout_info_type Li;
Li li;
Fasta f;
f.load(cip.p2);
std::ofstream os(cip.p1);
const IdxTy flags=atoi(cip.wif(3).c_str());
MM_ERR(MMPR4(cip.p1,cip.p2,flags,f.size()))
x.write_svg(os,f,li,flags);
continue;
} // svg
if (cmd=="txt") { 
typedef mjm_fasta::fasta_file Fasta;
typedef Myt::layout_info_type Li;
Li li;
Fasta f;
f.load(cip.p2);
std::ofstream os(cip.p1);
const IdxTy flags=atoi(cip.wif(3).c_str());
MM_ERR(MMPR4(cip.p1,cip.p2,flags,f.size()))
x.write_txt(os,f,li,flags);
} // txt 



} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FASTA_TO_SVG_H__ 
