#ifndef MJM_LAYOUT_INFO_H__
#define MJM_LAYOUT_INFO_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Sep  8 09:40:18 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_layout_info   
// g++  -Wall -std=gnu++11 -DTEST_MJM_LAYOUT_INFO -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_layout_info.h  -o mjm_layout_info.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_layout_info("mjm_layout_info"
, "  ");

#define U(x) if (p((QUOTE(x)))>0) x=p((QUOTE(x))); 
#define Q(x)  ( ((p(QUOTE(x)))>0)?p((QUOTE(x))):0) 

template <class Tr>
class mjm_layout_info 
{
 typedef mjm_layout_info Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;

typedef std::map<StrTy,D> Prop;
typedef std::map<StrTy,StrTy> Text;

//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_layout_info() {Init(); }
~mjm_layout_info() {}
void nseq(const IdxTy n ) { m_prop["nseq"]=n; } 
IdxTy nseq( )  { return  m_prop["nseq"]; } 
void length(const IdxTy n ) { m_prop["length"]=n; } 
IdxTy length() { return  m_prop["length"]; } 
void set(const StrTy & k, const D & v) { m_prop[k]=v; } 
D p(const StrTy & nm )  const
{
auto ii=m_prop.find(nm);
if ( ii==m_prop.end()) return -1;
return (*ii).second;
}
void calc() { Calculate(); } 

//const IdxTy xs=li.total_x(); // 100;
D total_x() const { return m_xs;}
D xmax() const { return m_xs-Q(m_rm);}
D xmin() const { return m_lm+Q(lname);}
D xm() const { return m_lm;}
//const IdxTy ys=li.total_y(); // 100;
D total_y() const { return m_ys;}
D ymax() const { return m_ys-Q(m_bm);}
D ymin() const { return m_tm;}
//const D x1=li.x(seq,col);

D xname(const IdxTy seq)const { return m_lm; }
//const D y1=li.y(seq,col);
D yname(const IdxTy seq)const  { return m_tm+m_tsm+m_ypitch*seq; }
D xpitch()const  { return m_xpitch; }
D ypitch()const  { return m_ypitch; }
D szname(const IdxTy seq)const  { return m_szname; }
D x(const IdxTy seq,const IdxTy col)const { return m_lm+m_lsm+m_xpitch*col; }
//const D y1=li.y(seq,col);
D y(const IdxTy seq,const IdxTy col)const  { return m_tm+m_tsm+m_ypitch*seq+m_ypitch/2; }


//const D w=li.w(seq,col);
D w(const IdxTy seq,const IdxTy col) const { return m_w; }
D h(const IdxTy seq,const IdxTy col) const { return m_h; }
//const D h=li.h(seq,col);
//const D tsz=li.base_size(seq,col);
D tsz(const IdxTy seq,const IdxTy col)const  { return m_tsz; }
D base_size(const IdxTy seq,const IdxTy col)const  { return m_bsz; }


StrTy dump(const IdxTy flags=0) const  { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0)const  {Ss ss;  
ss<<MMPR4( m_lm,m_lsm,m_xpitch, m_tm);
ss<<MMPR4(m_tsm,m_ypitch,m_w, m_h);
ss<<MMPR3(m_tsz,m_bsz,m_szname) ; // char block size 
MM_LOOP(ii,m_prop) { const StrTy & k=(*ii).first; const D & v=(*ii).second;   ss<<MMPR2(k,v); } 
MM_LOOP(ii,m_text) { const StrTy & k=(*ii).first; const StrTy & v=(*ii).second;   ss<<MMPR2(k,v); } 
return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

//cat xxx | sed -e 's/[ ;,.]/\n/g' | grep m_ | awk '{ x=x"\n"$0"=m_prop[\""$0"\"];";  y=y"\nm_prop[\""$0"\"]="$0";"; }END{print y ;   print x; }'
void From() { 
m_prop["m_xs"]=m_xs;
m_prop["m_ys"]=m_ys;
m_prop["m_lm"]=m_lm;
m_prop["m_lsm"]=m_lsm;
m_prop["m_xpitch"]=m_xpitch;
m_prop["m_tm"]=m_tm;
m_prop["m_tsm"]=m_tsm;
m_prop["m_ypitch"]=m_ypitch;
m_prop["m_w"]=m_w;
m_prop["m_h"]=m_h;
m_prop["m_tsz"]=m_tsz;
m_prop["m_bsz"]=m_bsz;
m_prop["m_szname"]=m_szname;
} // From
void To ()
{
m_xs=m_prop["m_xs"];
m_ys=m_prop["m_ys"];
m_lm=m_prop["m_lm"];
m_lsm=m_prop["m_lsm"];
m_xpitch=m_prop["m_xpitch"];
m_tm=m_prop["m_tm"];
m_tsm=m_prop["m_tsm"];
m_ypitch=m_prop["m_ypitch"];
m_w=m_prop["m_w"];
m_h=m_prop["m_h"];
m_tsz=m_prop["m_tsz"];
m_bsz=m_prop["m_bsz"];
m_szname=m_prop["m_szname"];
} // To


void Calculate()
{
//From();
IdxTy nseq=p("nseq");
IdxTy len=p("length");
U(m_xpitch);
U(m_ypitch);
U(m_tm);
U(m_lm);
U(m_lsm);
U(m_tsm);

m_xs=m_lm+m_lsm+m_xpitch*len+Q(m_rm)+Q(lname)+Q(rname);
m_ys=m_tm+m_tsm+m_ypitch*nseq+Q(m_bm);
//m_ys=100;
//m_lm=20;
//m_lsm=20;
//m_xpitch=2;
//m_tm=20;
//m_tsm=2;
//m_ypitch=2;
m_w=m_xpitch;
m_h=m_ypitch;
m_tsz=2;
m_bsz=2;
m_szname=1+m_ypitch/2;

From();
MM_ERR(MMPR(dump()))
} // Calculate
void Init()
{
m_prop["nseq"]=0;  
m_prop["length"]=0;  
m_prop["m_rm"]=100;  
m_prop["m_bm"]=100;  

m_xs=100;
m_ys=100;
m_lm=20;
m_lsm=20;
m_xpitch=2;
m_tm=20;
m_tsm=2;
m_ypitch=20;
m_w=2;
m_h=2;
m_tsz=2;
m_bsz=2;
m_szname=2;

From();

} // Init




// MEMBERS
Prop m_prop;
Text m_text;
D m_xs, m_ys; // total size 
// margins and pitch 
D m_lm,m_lsm,m_xpitch;
D m_tm,m_tsm,m_ypitch;
D m_w, m_h,m_tsz,m_bsz,m_szname; // char block size 


}; // mjm_layout_info

//////////////////////////////////////////////

template <class Tr>
class mjm_layout_info_map : public std::map<typename Tr::StrTy, mjm_layout_info< Tr > >  
{
 typedef mjm_layout_info_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_layout_info< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_layout_info_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_layout_info_map




////////////////////////////////////////////
#ifdef  TEST_MJM_LAYOUT_INFO
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_layout_info <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_LAYOUT_INFO "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_layout_info<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_LAYOUT_INFO_H__ 
