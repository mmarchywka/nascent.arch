#ifndef MJM_FLOORPLAN_POINTS_H__
#define MJM_FLOORPLAN_POINTS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_data_model_error_log.h"
#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_logic_base.h"
#include "mjm_strings.h"
#include "mjm_canned_methods.h"
#include "mjm_cli_ui.h"
#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri May  6 08:10:29 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_floorplan_points   
// g++  -Wall -std=gnu++11 -DTEST_MJM_FLOORPLAN_POINTS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_floorplan_points.h  -o mjm_floorplan_points.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_floorplan_points("mjm_floorplan_points"
, "  ");

template <class Tr>
class mjm_floorplan_points 
{
 typedef mjm_floorplan_points Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_ragged_table Ragged;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef mjm_canned_methods Canned;
typedef mjm_block_matrix<D> MyFloatBlock;

class _GridPoint
{
public:
_GridPoint() : x(0),y(0),r(0) {}
_GridPoint(const D& _x, const D& _y) : x(_x),y(_y),r(0) {}
_GridPoint(const D& _x, const D& _y,const D & _r) : x(_x),y(_y),r(_r) {}
D x,y;
D r;
}; // _GridPoint

typedef _GridPoint GridPoint;


class _GridRect
{
public:
_GridRect() : x(0),y(0),w(0),h(0),r(0) {Init();}
_GridRect(const D& _x, const D& _y) : x(_x),y(_y),w(0),h(0),r(0) {Init(); }
_GridRect(const D& _x, const D& _y,const D & _w,const D & _h) 
: x(_x),y(_y),w(_w),h(_h),r(0) {Init(); }
_GridRect(const GridPoint & p1, const GridPoint & p2)
:x(p1.x),y(p1.y),w(p2.x-p1.x),h(p2.y-p1.y),r(0) {Init(); }
_GridRect(const GridPoint & p1, const GridPoint & p2, const bool x)
:x(p1.x),y(p1.y),w(p2.x),h(p2.y),r(0) {Init(); }

void Init()
{
if (w<0) { x=x+w; w=-w; } 
if (h<0) { y=y+h; h=-h; } 
} // Init 

D x,y,w,h;
D r;
}; // _GridRect

typedef _GridRect GridRect;



typedef std::vector<GridPoint> GridPoints;

class _GridStats
{

public:
_GridStats() { Init(); }
D range(const IdxTy i) const
{
if (i==0) { return m_x_max-m_x_min;}
if (i==1) { return m_y_max-m_y_min;}
return 0;
} // range
D base(const IdxTy i) const
{
if (i==0) { return m_x_min;}
if (i==1) { return m_y_min;}
return 0;
} // base 

void point(const GridPoint & gp)
{
// can have separate calls for this ( stupid ) test doh..
if (m_n==0)
{
m_x_min=gp.x; m_x_max=m_x_min;
m_y_min=gp.y; m_y_max=m_y_min;
m_n=1;
return; 
}
if (m_x_min>gp.x) m_x_min=gp.x; 
if (m_x_max<gp.x) m_x_max=gp.x; 
if (m_y_min>gp.y) m_y_min=gp.y; 
if (m_y_max<gp.y) m_y_max=gp.y; 

++m_n;

} // point 
//with initial and addon calls, only needed if no data points added doh 
void Init()
{
m_n=0;
m_x_min=m_y_min=m_x_max=m_y_max=0;
} // Init

IdxTy m_n;
D m_x_min,m_y_min,m_x_max,m_y_max;
}; // _GridStats
typedef _GridStats GridStats;


class _UseGrid
{

public:

}; // _UseGrid


class _Usage
{
public:

}; // _Usage


typedef _Usage Usage;

typedef std::map<IdxTy, std::vector< Usage > > Umap;
typedef std::map<IdxTy,Umap> U2map;

class _CrowdingGrid
{
//typedef Usage Ue;
typedef D  Ve;

public:
_CrowdingGrid() { Init();}
~_CrowdingGrid() { Dtor();}
void point(const GridPoint & gp)
{

}
private:
void Dtor()
{
//delete [] p; 
delete [] v; 
}
void Init()
{
//p=0;
v=0;
}
//Ue * p;
U2map map;
Ve * v;
IdxTy m,n;
}; // _CrowdingGrid

typedef _CrowdingGrid CrowdingGrid;

typedef void Owner;
class _Deed
{


public:
_Deed(): m_owner(NULL) {}
_Deed(Owner * p, const GridRect & r):m_owner(p),m_plot(r) {}
Owner * m_owner;
GridRect m_plot;

}; // _Deed

typedef _Deed Deed;
typedef std::vector<Deed> Deeds;
typedef std::map<Owner *, Deeds> DeedMap;

typedef std::map<Owner *, GridStats> GridStatsMap;
public:
mjm_floorplan_points() {Init();}
~mjm_floorplan_points() { }
// reall just need to create a "deed" and record the owner... 
void bounds(const D & xs, const D & ys) { Bounds(xs,ys); } // bounds 
IdxTy locate( D & x, D & y,const IdxTy point,const D & w, const D & h, const IdxTy flags)
{
return Locate(x,y,point,w,h,flags);

}
IdxTy allocate(Owner * o, Owner * seller, const D & x, const D & y , const D & w, const D  & h, const IdxTy flags)
{ return Allocate(o,seller, x,y,w,h,flags); }


//_Xform(const D& x, const D & y, const D & max, const D & may):
template < class Tx>
IdxTy xform(Tx & xform, Owner * po, const IdxTy flags)
{ return Xform(xform,po,flags); } 

template < class Tx>
IdxTy add_points( const  Tx & p, Owner * op,  const IdxTy flags)
{ return AddPoints(p,op,flags); } 
template < class Tx>
IdxTy add_points( const  Tx & x, const Tx  & y, const IdxTy flags)
{ return AddPoints(x,y,flags); } 

template < class Tx,class Tz >
IdxTy add_points( const  Tx & x, const Tx  & y, const Tz & geo, const IdxTy flags)
{ return AddPoints(x,y,geo,flags); } 
IdxTy analyze(const IdxTy flags) { return Analyze(flags); } 

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
template < class Tx>
IdxTy AddPoints( const  Tx & x, const Tx  & y, const IdxTy flags)
{ 
MM_ERR(" no owner hing ... ")
auto ii=x.begin();
auto jj=y.begin();
while ((ii!=x.end())&&(jj!=y.end()))
{
const D & xp=(*ii);
const D & yp=(*jj);

GridPoint gp(xp,yp);
m_stats.point(gp);
m_points.push_back(gp);
++ii;
++jj;
} // ii jj

return 0;
}  // Addpoints
template < class Tx>
IdxTy AddPoints( const  Tx & p, Owner * op, const IdxTy flags)
{ 
auto &  stats=m_stats[op];
auto ii=p.begin();
while ((ii!=p.end()))
{
const D & xp=(*ii)[0];
const D & yp=(*ii)[1];

GridPoint gp(xp,yp);
stats.point(gp);
m_points.push_back(gp);
++ii;
} // ii jj

return 0;
}  // Addpoints


template < class Tx,class Tz >
IdxTy AddPoints( const  Tx & x, const Tx  & y, const Tz & geo, const IdxTy flags)
{ 
MM_ERR(" ignoring geo for now ")
return AddPoints(x,y,flags);
//return 0;
 }  // Addpoints

template < class Tx >
IdxTy xxxAddPoints( const  Tx & p, const IdxTy flags)
{ 
MM_ERR(" ignoring geo for now ")
return AddPoints(p,flags);
//return 0;
 }  // Addpoints



IdxTy Analyze(const IdxTy flags) { 
// find extents, done in stats on the fly 

// make grid

// find allocations 

return 0;
}
IdxTy Locate( D & x, D & y,const IdxTy point,const D & w, const D & h, const IdxTy flags)
{


return 0;

} // Locate
//_Xform(const D& x, const D & y, const D & max, const D & may):
template < class Tx>
IdxTy Xform(Tx & xform, Owner * po, const IdxTy flags)
{ 

D xs=m_xs; 
D ys=m_ys; 
D px=0;
D py=0;
auto  ii=m_deeds.find(po);
if ( ii==m_deeds.end())
{
MM_ERR(" nothing found for ownder ");
//return 0; 
}
else
{
Deed & dd=(*ii).second[0];
px=dd.m_plot.x;
py=dd.m_plot.y;
xs=dd.m_plot.w;
ys=dd.m_plot.h;

}
auto & stats=m_stats[po];
const D ax=xs/stats.range(0);
const D ay=ys/stats.range(1);
const D ofx=-px/ax+stats.base(0);
const D ofy=-py/ay+stats.base(1);
MM_ERR(MMPR4(ax,ay,ofx,ofy))
xform= Tx(ofx,ofy,ax,ay);
return 0; 
// return Xform(xform,po,flags); 


} 

IdxTy Allocate(Owner * o, Owner * seller, const D & x, const D & y , const D & w, const D  & h, const IdxTy flags)
{ 

Deed d(o,GridRect(x,y,w,h));

m_deeds[o].push_back(d);

return 0; 

 }



void Init()
{
m_n=0;
m_xs=0;
m_ys=0;

}
// sould be a "deed" recorded to "owner" frame
void Bounds(const D & xs, const D & ys) { 
m_xs=xs ; m_ys=ys; 
} // bounds 
// MEMBERS
D m_xs, m_ys;
D m_min_x,m_min_y,m_max_x,m_max_y;
IdxTy m_n;


MyFloatBlock m_v_grid;
//U2map m_usage;

GridPoints  m_points;
//GridStats m_stats;
GridStatsMap m_stats;
CrowdingGrid m_crowd;
DeedMap m_deeds;

}; // mjm_floorplan_points

//////////////////////////////////////////////

template <class Tr>
class mjm_floorplan_points_map : public std::map<typename Tr::StrTy, mjm_floorplan_points< Tr > >  
{
 typedef mjm_floorplan_points_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_floorplan_points< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_floorplan_points_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_floorplan_points_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FLOORPLAN_POINTS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_floorplan_points <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FLOORPLAN_POINTS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_floorplan_points<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FLOORPLAN_POINTS_H__ 
