#ifndef MJM_CROWD_REPULSION_H__
#define MJM_CROWD_REPULSION_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_strings.h"
#include "mjm_canned_methods.h"
#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_loo_parsing.h"
#include "mjm_block_matrix.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed May 18 05:03:19 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_crowd_repulsion   
// g++  -Wall -std=gnu++11 -DTEST_MJM_CROWD_REPULSION -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_crowd_repulsion.h  -o mjm_crowd_repulsion.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_crowd_repulsion("mjm_crowd_repulsion"
, "  ");

template <class Tr>
class mjm_crowd_repulsion 
{
 typedef mjm_crowd_repulsion Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_canned_methods Canned;
typedef mjm_logic_base VariableStore;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef mjm_tokenized_ragged_table TokRagged;
typedef std::map<StrTy, TokRagged> TokRaggedMap;
typedef mjm_loo_parsing<Tr> Loo;
typedef mjm_block_matrix<int> MyBlock;
class _io_spec
{

public:
typedef IdxTy Lo;
typedef std::vector<D> ScalesVector;
typedef std::vector<Lo> loc_vector;
typedef std::map<StrTy,Lo> LoMap;
_io_spec() { Init();}
void s_left(const IdxTy & f, const IdxTy & n)
{ for(IdxTy i=f; i<(n+f); ++i) { MM_ERR(MMPR3(i,f,n))  m_lo[Src(i-f)]=i; m_scales.push_back(1); }  m_lo["insize"]=n+f; }
void d_left(const IdxTy & f, const IdxTy & n)
{ for(IdxTy i=f; i<(n+f); ++i) m_lo[Dest(i-f)]=i; m_lo["outsize"]=(n+f); }
void d_orig(const IdxTy & f, const IdxTy & n)
{ for(IdxTy i=f; i<(n+f); ++i) m_lo[Orig(i-f)]=i; m_lo["outsize"]=(n+f); }
IdxTy insize() const { return Kv("insize"); } 
IdxTy outsize() const { return Kv("outsize"); } 
const ScalesVector & scales() const  { return m_scales; } 
IdxTy Loc(const IdxTy i, const IdxTy which) const
{ 
if (which ==0) return Kv(Src(i)); 
if (which ==2) return Kv(Orig(i)); 
return Kv(Dest(i)); 
} 
void sources(loc_vector & lv) const 
{ const IdxTy n=nSrc(); for(IdxTy i=0; i<n; ++i) lv.push_back(Loc(i,0)); } 
void dests(loc_vector & lv) const 
{ const IdxTy n=nSrc(); for(IdxTy i=0; i<n; ++i) lv.push_back(Loc(i,1)); } 

StrTy Src(const IdxTy i )const  { Ss ss; ss<<"s"<<i; return ss.str(); } 
StrTy Dest(const IdxTy i )const { Ss ss; ss<<"d"<<i; return ss.str(); } 
StrTy Orig(const IdxTy i )const { Ss ss; ss<<"o"<<i; return ss.str(); } 

IdxTy Kv(const StrTy & k) const { // MM_ERR(MMPR(k)) 
const auto ii=m_lo.find(k); if (ii==m_lo.end()) return ~0; 
return (*ii).second; }  
IdxTy nSrc() const { IdxTy i=0; while ( Kv(Src(i))!=~0U) ++i; return i; }
void d_left(const StrTy & s)
{
IdxTy i=0;
IdxTy j=0;
IdxTy n=nSrc();
const char * p=s.c_str();
while (*p)
{
while (true) { 
if (*p=='d') { d_left(i,n); i=i+n; break;}
if (*p=='o') { d_orig(i,n); i=i+n; break;}
break;
}// true 
++p;
} // p 
m_lo["outsize"]=i;
MM_ERR(MMPR2(m_lo["outsize"],i))

}
void Init() { // algo=0; 

} // Init 

void setup() {}
/*
void setup()
{
IdxTy m=0;
MM_LOOP(ii,win) { if ((*ii)>m) m=(*ii); } 
win=m;
m=0;
MM_LOOP(ii,wout) { if ((*ii)>m) m=(*ii); } 
wout=m;

}
loc_vector in,out;
*/
//IdxTy algo, win,wout;
StrTy dump() const
{
Ss ss;
//  easier to write a new 
Loo::Dump(ss,StrTy("m_lo"),m_lo,0);
Loo::Dump(ss,StrTy("m_scales"),m_scales,0);
return ss.str();
} // dump

LoMap m_lo;
ScalesVector m_scales;
}; // _io_spec
typedef _io_spec IOSpec;

///////////////////////////////

class _point_details
{

public:

typedef std::vector<D> Loc;
typedef std::vector<IdxTy> Lidx;
typedef std::vector<IdxTy> loc_vector;
typedef std::vector<IdxTy> Nays;
_point_details() { // MM_ERR(MMPR(dump()))
}
_point_details(const IdxTy n, const Line & l, const Lidx & idx) {Init(n,l,idx);}
void zed_v() { v=0; MM_LOOP(ii,dv) {(*ii)=0; } ; }
void Init(const IdxTy n, const Line & l, const Lidx & idx)//  {Init(l,idx);}
{
id=n;
MM_LOOP(ii,idx) {
	del.push_back(0);  
	D val=atof(l[(*ii)].c_str()); 
	orig.push_back(val); 
} 
curr=orig; dv=del;
v=0;
//MM_ERR(MMPR(dump()))
}
StrTy dump() const
{
Ss ss;
Loo::Dump(ss,StrTy("orig"),orig,0);
Loo::Dump(ss,StrTy("curr"),curr,0);
Loo::Dump(ss,StrTy("del"),del,0);
Loo::Dump(ss,StrTy("dv"),dv,0);
Loo::Dump(ss,StrTy("exact"),exact,0);
ss<<MMPR2(v,id);
return ss.str();
} 

Loc orig, curr, del,dv;
D v;
IdxTy id;
Nays near;
Nays exact;

}; // _point_details

typedef _point_details point_details;

typedef std::vector<point_details>  DetailVector;

///////////////////////////////

public:
typedef IOSpec io_spec_type;
mjm_crowd_repulsion() {}
~mjm_crowd_repulsion() {}
IdxTy disperse(const StrTy & fd, const StrTy & fs, const io_spec_type & ios, const IdxTy flags)
{
Ragged s,d;
s.load(fs);
IdxTy rc=disperse(d,s,ios,flags);
std::ofstream fos(fd);
fos<<d.dump_ssv();
return rc;
}
IdxTy disperse(Ragged & d, const Ragged & s, const io_spec_type & ios, const IdxTy flags)
{ return Disperse(d,s,ios,flags); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


template < class Tx>
IdxTy AddPoints( const  Tx & p, const IdxTy flags)
{
//auto &  stats=m_stats[op];
auto ii=p.begin();
while ((ii!=p.end()))
{
const D & xp=(*ii)[0];
const D & yp=(*ii)[1];

//GridPoint gp(xp,yp);
//stats.point(gp);
//m_points.push_back(gp);
++ii;
} // ii jj

return 0;
}  // Addpoints
IdxTy SetDest(Ragged & d, const Ragged & s, const io_spec_type & ios, const IdxTy flags)
{
const IdxTy osz=ios.outsize();
const IdxTy nsz=ios.insize();
const IdxTy ssz=s.size();
const IdxTy dsz=d.size();
MM_ERR(MMPR4(osz,nsz,dsz,ssz))
if (dsz>=ssz) return 0; // assume ok 
const IdxTy dif=ssz-dsz;
Line lzed(osz);
for(IdxTy i=0; i<dif; ++i) { d.add(lzed); } // i 
return 0;
} // SetDest
IdxTy LoadPoints(Ragged & d, const Ragged & s, const io_spec_type & ios, const IdxTy flags)
{
//const IdxTy osz=ios.outsize();
//const IdxTy nsz=ios.insize();
//const IdxTy ssz=s.size();
//const IdxTy dsz=d.size();
typename point_details::loc_vector lv;
ios.sources(lv);
MM_SZ_LOOP(i,s,ssz)
{
const Line & l=s[i];
point_details pd(i,l,lv );
pd.zed_v();
m_d.push_back(pd);

} // i 
// ASSFUICK CORREUPTIONCHECK UFF  
//MM_LOOP(ii,m_d) { MM_ERR((*ii).dump()) } // ii

return 0;
} // LoadPoints 
template <class Ty> 
IdxTy MinMax(Ty & minx, Ty & maxx, const IdxTy ncoords, const IdxTy flags)
{
const bool real_min=Bit(flags,0);
MM_SZ_LOOP(i,m_d,ssz)
{
 point_details  & pd=m_d[i];
for(IdxTy j=0; j<ncoords; ++j) 
{ 
 D &x=pd.curr[j];  
 D &xm=maxx[j];  
 D &xmi=minx[j];  
if (i==0) { xm=x; if ((x!=0)||real_min) xmi=x; continue;}
if ((x==0)&&!real_min) continue; // for log xform 
if (x>xm) xm=x;
if (x<xmi) xmi=x;
} // j 
//for(IdxTy j=0; j<lv.size(); ++j) { Ss ss;ss<< pd.curr[j]; l[lv[j]]=ss.str(); } // j 
//MM_ERR(MMPR(l.size()))
//for(IdxTy j=0; j<lv.size(); ++j) { Ss ss;ss<< pd.orig[j]; l[ios.Loc(j,2)]=ss.str(); } // j 
// Orig
} // i 
return 0;
} // MinMax

IdxTy XformPoints( const io_spec_type & ios, const IdxTy flags)
{
typedef typename point_details::loc_vector Lv;
Lv  lv;
//typename point_details::loc_vector lv;
ios.dests(lv);
const IdxTy ncoords=lv.size();
MM_ERR(MMPR(lv.size()))
std::vector<D>  minx(ncoords),maxx(ncoords);
for(IdxTy i=0; i<3; ++i) { IdxTy j=0; while (ios.Loc(j,i)!=~0U) { MM_ERR(MMPR3(i,j,ios.Loc(j,i))) ++j; } }
MinMax(minx,maxx,ncoords,0);

MM_SZ_LOOP(i,m_d,sszz)
{
 point_details  & pd=m_d[i];
for(IdxTy j=0; j<ncoords; ++j) 
{ 
 D &x=pd.curr[j];  
 if (x!=0) x=log(x);
 //else x=log(1e-3); // log(minx[j]/2);
 else x= log(2*minx[j]/3);
} // j 
pd.orig=pd.curr; // want to save real origs?
} // i 

return 0;
} // XformPoints 



// find potential and derivative replacing the distance tuerns in dr 
template<class Ty> 
D Potential(Ty & dr,  point_details & p1,  point_details & p2,  const Ty & scale, const  IdxTy flags)
{
D d=0;
// should use sum of 1/x for worse case thing.. 
const auto & x=p1.curr;
const auto & y=p2.curr;
const IdxTy sz=x.size();
// already done... doh need functor d and v etc fwiw 
Ty dv=dr;
for(IdxTy i=0; i<sz; ++i){dv[i]=0; dr[i]=x[i]-y[i];  d+= (dr[i]*dr[i])*scale[i]; } 
d=sqrt(d);
D v=0;
if (d!=0){ v=1.0/d;
D v3=v*v*v;
// scale? 
for(IdxTy i=0; i<sz; ++i){dv[i]=-(x[i]-y[i])*v3;
MM_ERR(MMPR4(i,x[i],y[i],v3)<<MMPR(dv[i]))
 } 
}
dr=dv;
return v;
} // Potential  



template<class Ty> 
D Distance(Ty & dr,  point_details & p1,  point_details & p2,  const Ty & scale, const  IdxTy flags)
{
D d=0;
// should use sum of 1/x for worse case thing.. 
const auto & x=p1.curr;
const auto & y=p2.curr;
const IdxTy sz=x.size();
for(IdxTy i=0; i<sz; ++i){dr[i]=x[i]-y[i];  d+= (dr[i]*dr[i])*scale[i]; } 
d=sqrt(d);
return d;
} // Distance

IdxTy SavePoints(Ragged & d, const Ragged & s, const io_spec_type & ios, const IdxTy flags)
{
//const IdxTy osz=ios.outsize();
//const IdxTy nsz=ios.insize();
//const IdxTy ssz=s.size();
//const IdxTy dsz=d.size();
typename point_details::loc_vector lv;
ios.dests(lv);
MM_ERR(MMPR(lv.size()))
for(IdxTy i=0; i<3; ++i)
{
IdxTy j=0;
while (ios.Loc(j,i)!=~0U) { MM_ERR(MMPR3(i,j,ios.Loc(j,i))) ++j; }

}
MM_SZ_LOOP(i,m_d,ssz)
{
Line & l=d[i];
const point_details  & pd=m_d[i];
//MM_ERR(MMPR(l.size()))
//point_details pd(i,l,lv );
//m_d.push_back(pd);
for(IdxTy j=0; j<lv.size(); ++j)
{ Ss ss;ss<< pd.curr[j]; l[lv[j]]=ss.str(); } // j 
//MM_ERR(MMPR(l.size()))
for(IdxTy j=0; j<lv.size(); ++j)
{ Ss ss;ss<< pd.orig[j]; l[ios.Loc(j,2)]=ss.str(); } // j 
for(IdxTy j=0; j<lv.size(); ++j) {Ss ss;  ss<< pd.dv[j]; l.push_back(ss.str()); } 
 {Ss ss;  ss<< pd.v; l.push_back(ss.str()); } 

// Orig
} // i 
return 0;
} // SavePoints 


IdxTy FindDistances(const io_spec_type & ios,  const IdxTy flags)
{
auto & v=m_d;
auto & scales=ios.scales();
auto dr=scales;
MM_LOOP(ii,v) {(*ii).zed_v(); } 
MM_SZ_LOOP(i,v,szi)
{
auto & pdi=v[i];
for(IdxTy j=i+1; j<szi; ++j)
{
auto & pdj=v[j];
D r=Distance(dr,pdi,pdj,scales,0);
// note dr changes from delta r to grad V... doh.. 
D V=Potential(dr,pdi,pdj,scales,0);
// now do something with it...
if (V==0)
{
pdi.exact.push_back(j);
pdj.exact.push_back(i);
}
MM_ERR(MMPR4(i,j,r,V)<<MMPR2(dr[0],dr[1]))
pdi.v+=V; pdj.v+=V;
for(IdxTy k=0; k<dr.size(); ++k ) { pdi.dv[k]+=dr[k]; pdj.dv[k]-=dr[k]; } 
} //j 
} // i 
return 0; 
} // FindDistances
// this works good except for exact degeneracies... 
// even not enough noise to split the overlaps...
IdxTy DispersePoints( const io_spec_type & ios, const IdxTy flags)
{

for (IdxTy k=0; k<20; ++k) { 

typename point_details::loc_vector lv;
FindDistances(ios,0);
ios.dests(lv);
const IdxTy ncoords=lv.size();
std::vector<D>  minx(ncoords),maxx(ncoords);
std::vector<D>  minl(ncoords),maxl(ncoords);
MinMax(minx,maxx,ncoords,1);
MM_SZ_LOOP(i,minx,szm)
{
D r=maxx[i]-minx[i];
D mini=minx[i]-.05*r;
D maxi=maxx[i]+.05*r;
minl[i]=(mini);
maxl[i]=(maxi); 

}
MM_SZ_LOOP(i,m_d,szi)
{
auto & pdi=m_d[i];
const IdxTy olaps=pdi.exact.size();
IdxTy lte;
while (lte<olaps)
{
if (pdi.exact[lte]>i) break;
++lte;
}
MM_ERR(MMPR3(i,olaps,lte))
// WTF scale  changed????
D vs=.02;
IdxTy fail=0;
while (true)
{
++fail;
if (fail>10)
{
for(IdxTy j=0; j<pdi.curr.size(); ++j) {
if ( pdi.curr[j]>(maxl[j])) { pdi.curr[j]=maxx[j]; }
if ( pdi.curr[j]<(minl[j])) { pdi.curr[j]=minx[j]; }
} // j 

 break;
}
// if olaps, spread them out a little to break degeneracy... 
std::vector<D> fixed=pdi.dv;
// the potential grad could still be zero, so then need a length scale... 
const IdxTy ns=pdi.curr.size();


// add an attractive potential to point
D vattr=0;
std::vector<D>  attr=fixed;
MM_LOOP(ii,attr) { (*ii)=0; }


for(IdxTy j=0; j<pdi.curr.size(); ++j) {
D dx=pdi.curr[j]-pdi.orig[j]; 
vattr+=dx*dx;
}
vattr=sqrt(vattr);
for(IdxTy j=0; j<pdi.curr.size(); ++j) {
D dx=pdi.curr[j]-pdi.orig[j]; 
vattr+=dx*dx;
}
// this is dumb, the potential should be [psotove [pwer
//D v3=0; // (vattr==0)?0:(1.0/(vattr*vattr*vattr));// v3
D v3=0*sqrt(vattr);// v3
for(IdxTy j=0; j<pdi.curr.size(); ++j) {
D dx=pdi.curr[j]-pdi.orig[j]; 
attr[j]=-dx*v3;
}


if ( olaps!=0)
{
// const auto &  this up ????????
// if the attr line is added there is no splitting???? 
const std::vector<D>   x=pdi.dv;
const std::vector<D> a=attr;
if (ns==1) { } // nothing for now... 
if (ns==2) {
const D theta=2*M_PI*D(lte)/D(olaps);
const D ct=cos(theta);
const D st=sin(theta);
fixed[0]=x[0]*ct+x[1]*st;
fixed[1]=x[1]*ct-x[0]*st;

attr[0]=a[0]*ct+a[1]*st;
attr[1]=a[1]*ct-a[0]*st;
} // 2


} // olaps




for(IdxTy j=0; j<pdi.curr.size(); ++j) {
//pdi.curr[j]=pdi.curr[j]-vs*pdi.dv[j]; 
pdi.curr[j]=pdi.curr[j]-vs*fixed[j]+0.1*attr[j]; 
} // j  
bool ok=true;
for(IdxTy j=0; j<ns; ++j) {
if ( pdi.curr[j]>(maxl[j])) { vs=vs*.75; ok=false; break; }
if ( pdi.curr[j]<(minl[j])) { vs=vs*.75; ok=false; break; }
} // j
if (ok) break;

} // true


} // i 
} //k 
return 0;
} // DispersePoints 

IdxTy DispersePointsGrid( const io_spec_type & ios, const IdxTy flags)
{
typedef typename point_details::loc_vector Lv;
Lv  lv;
ios.dests(lv);
const IdxTy ncoords=lv.size();
std::vector<D>  minx(ncoords),maxx(ncoords);
MinMax(minx,maxx,ncoords,1);
const int nx=5;
const int  ny=10;
const D a=D(nx)/(maxx[0]-minx[0]);
const D b=D(ny)/(maxx[1]-minx[1]);
MM_ERR(MMPR4(maxx[0],minx[0],maxx[1],minx[1]))


// initialize.. doh 
MyBlock block(nx,ny);
block.fillbyte(~0);
MM_SZ_LOOP(i,m_d,szi)
{
auto & pdi=m_d[i];
D bxd=a*(pdi.curr[0]-minx[0]);
D byd=b*(pdi.curr[1]-minx[1]);
int bx=bxd;
int by=byd;
MM_ERR(MMPR4(a,b,bxd,byd)<<MMPR2(bx,by))
//int bcx=a*(pdi.orig[0]-minx[0]);
//int bcy=b*(pdi.orig[1]-minx[1]);
if (bx<0) continue;
if (by<0) continue;
if (bx>=nx) continue;
if (by>=ny) continue;

const  int  f=block(bx,by);
if ( f==~0) { block(bx,by)=i;  continue;    } 
int bxnew=bx;
int bynew=by; 
int dir=1;
const bool bk=( by>(ny>>1)); 
if (bk)   dir=-1;
int del=1;
while (true)
{
bynew= by + dir*del;
MM_ERR(MMPR4(i,by,bynew,del)<<MMPR(dir))
if ((bynew>=ny) ||(bynew<0))
{
// only change y for now, putting in center isdumb anyway 
// off center better 
pdi.curr[0]=(D(bxnew)+.5)/a+minx[0]; 
pdi.curr[1]=(D(bynew)+.5)/b+minx[1];   
break;
}
int fnew=block(bxnew,bynew);
if (fnew==~0)
{
// eventually want to center.. 
//auto & pdif=m_d[f];
// off center looks better 
 pdi.curr[0]=(D(bxnew)+.5)/a+minx[0]; 
pdi.curr[1]=(D(bynew)+.5)/b+minx[1]; 
block(bxnew,bynew)=i;  
break;
} // ~0
const bool fwd= (dir==1);
dir=-dir;
if (fwd&&bk) del+=1;
else if (!fwd&&!bk) del+=1;
} // true 

/*

// this just centers it in the block 
//if ( f==~0) { pdi.curr[0]=(D(bx)+.5)/a+minx[0]; pdi.curr[1]=(D(by)+.5)/b+minx[1]; block(bx,by)=i; continue;    } 
{
int b2x=bx;
int b2y=by;
if ( b2y>(ny>>1)) ++b2y ; else --b2y;
// TODO this fails if ny is less than 2 or something.. 
//if ( b2y>=ny) b2y-=2;
//if ( b2y<0) b2y+=2;
if (b2y>=0) if (b2y<ny)
{
f=block(b2x,b2y);
MM_ERR(MMPR(f)<<MMPR4(a,b,b2x,b2y))
if ( f==~0) { pdi.curr[0]=(D(b2x)+.5)/a+minx[0]; pdi.curr[1]=(D(b2y)+.5)/b+minx[1]; block(b2x,b2y)=i; continue;    } 
}
else // out of bounds ok for now... 
{ pdi.curr[0]=(D(b2x)+.5)/a+minx[0]; pdi.curr[1]=(D(b2y)+.5)/b+minx[1];  continue;    } 

continue; // break; // just leave it there for now... 
} // allocated 
*/

} // i 

return 0;
} // DispersePointsGrid 




IdxTy Disperse(Ragged & d, const Ragged & s, const io_spec_type & ios, const IdxTy flags)
{
IdxTy rc=0;
MM_ERR(MMPR2(s.size(),ios.dump()))
// make d big enough for results
if (SetDest(d,s,ios,flags)) return 1;
// find collisions and near misses.  should hopefully be sparse
if (LoadPoints(d,s,ios,flags)) return 1;
MM_ERR(MMPR(m_d.size()))
if (XformPoints(ios,flags)) return 1;
MM_ERR(MMPR(m_d.size()))

if (!false&&DispersePoints(ios,flags)) return 1;

if (false) if (DispersePointsGrid(ios,flags)) return 1;

MM_ERR(" done dispersing") 
// re allocate 
if (SavePoints(d,s,ios,flags)) return 1;

return rc;
}// Disperse
// MEMBERS
DetailVector m_d;


}; // mjm_crowd_repulsion

//////////////////////////////////////////////

template <class Tr>
class mjm_crowd_repulsion_map : public std::map<typename Tr::StrTy, mjm_crowd_repulsion< Tr > >  
{
 typedef mjm_crowd_repulsion_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_crowd_repulsion< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_crowd_repulsion_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_crowd_repulsion_map




////////////////////////////////////////////
#ifdef  TEST_MJM_CROWD_REPULSION
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_crowd_repulsion <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_CROWD_REPULSION "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_crowd_repulsion<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="disperse") { 
Myt::io_spec_type ios;
//loc_vector in,out; IdxTy algo, win,wout;
const StrTy df=cip.p1;
const StrTy sf=cip.p2;
const IdxTy flags=0;
MM_ERR(MMPR4(df,sf,flags,cip.wif(3)))
ios.s_left(atoi(cip.wif(3).c_str()),2);
MM_ERR("sht ")
ios.d_left("donl");
MM_ERR("wtf  ")
ios.setup();
const IdxTy rc=x.disperse(df,sf,ios,flags);
MM_ERR(MMPR(rc)<<x.dump()) 

}
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_CROWD_REPULSION_H__ 
