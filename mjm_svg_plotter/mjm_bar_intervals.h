#ifndef MJM_BAR_INTERVALS_H__
#define MJM_BAR_INTERVALS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_loo_parsing.h"
#include "../string_seq/mjm_layout_info.h"
#include "mjm_strings.h"
#include "mjm_string_index.h"

#include "mjm_color_table.h"


#include "mjm_fasta_ii.h"
#include "mjm_pawnoff.h"
#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_svg_writer.h"
#include "mjm_cpp_regex.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Sep 24 19:39:37 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_bar_intervals   
// g++  -Wall -std=gnu++11 -DTEST_MJM_BAR_INTERVALS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_bar_intervals.h  -o mjm_bar_intervals.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_bar_intervals("mjm_bar_intervals"
, "  ");

template <class Tr>
class mjm_bar_intervals 
{
 typedef mjm_bar_intervals Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;

typedef mjm_canned_methods Canned;

typedef mjm_layout_info<Tr> LayoutInfo;

typedef mjm_svg_writer Sw;

typedef mjm_cpp_regex::stuff  Rx;
typedef Rx::Rx Regex;
typedef mjm_loo_parsing<Tr> Loo;
typedef std::vector<IdxTy> Locations; 

class _bin_desc_class
{
public:
typedef std::map<Line, IdxTy> SrcMap;
typedef std::vector<D> ValVec;
_bin_desc_class(): m_serial(0),m_hits(0) {}
void hit() { ++m_hits; } 
void location(const IdxTy cnt) { m_locations.push_back(cnt); } 
//b.hierarchy(l,nsamples);
void hierarchy(const Line & l, const IdxTy nsamples)
{ 
Line l2;
for(IdxTy i=nsamples; i<l.size(); ++i) {  l2.push_back(l[i]); }
++m_src[l2];
} // hierarchy

D val(const IdxTy n) const 
{ if (n>=m_vals.size()) return 0; return m_vals[n]; }

D add(const IdxTy n, const D & x)  
{ while (n>=m_vals.size()) m_vals.push_back(0); m_vals[n]+=x; return m_vals[n]; }

D start(const IdxTy n) const 
{ if (n>=m_start.size()) return 0; return m_start[n]; }

D start(const IdxTy n, const D & x)  
{ while (n>=m_start.size()) m_start.push_back(0); m_start[n]=x; return m_start[n]; }

const StrTy & name() const { return m_name; }
_bin_desc_class & name(const StrTy& x )  {m_name=x;  return *this; }
const IdxTy & serial() const { return m_serial; }
_bin_desc_class & serial(const IdxTy& x )  {m_serial=x;  return *this; }

void normalize( const ValVec & v ) { MM_SZ_LOOP(i,m_vals,vs) { if (m_vals[i]!=0) m_vals[i]/=v[i]; }}
StrTy dump() const
{
Ss ss;
ss<<MMPR3(m_name,m_serial,m_hits);
ss<<" vals ";
MM_LOOP(ii,m_vals) { ss<<(*ii)<<" "; }
ss<<" start "; MM_LOOP(ii,m_start) { ss<<(*ii)<<" "; }
ss<<" locations "; MM_LOOP(ii,m_locations) { ss<<(*ii)<<" "; }
//Loo::Dump(ss,"m_vals",m_vals,0);
//Loo::Dump(ss,"m_start",m_start,0);
return ss.str();
} // dump 
StrTy hit_keys(const StrTy & lbl ) const
{
Ss ss;
MM_LOOP(ii,m_src)
{
StrTy nm=name();
if (nm.length()==0) nm="WTF";
ss<<lbl<<" "<<nm<<" ";
const auto & v=(*ii).first;
const IdxTy n=(*ii).second;
MM_LOOP(jj,v) ss<<(*jj)<<" ";
ss<<n<<CRLF; 
}

return ss.str();
}// locations

void to_line(Line & l) const
{
l.clear();
MM_LOOP(ii,m_vals) { Ss ss; ss<<(*ii); l.push_back(ss.str()); }
{Ss ss; ss<<m_hits; l.push_back(ss.str()); }
l.push_back(m_name); // this will get quoted probably.. 
}// to_line
StrTy m_name;
IdxTy m_serial;
ValVec  m_vals;
IdxTy m_hits;
Locations m_locations;
SrcMap m_src;
// need to put in layout or something 
mutable ValVec m_start;
}; // _bin_desc_class;

typedef _bin_desc_class BinDesc;

class RR { public: RR(const Regex & x) :minusv(false), r(x) {} RR()  {} 
StrTy dump() const
{
Ss ss;
ss<<MMPR2(minusv,s);
return ss.str();
}
bool minusv;
Regex r,rall; StrTy s; 
};
typedef std::map<StrTy, BinDesc> BinVec;
class _bin_spec_class
{
typedef std::vector<RR>  FeatureBase;
class _Feature : public FeatureBase
{
typedef FeatureBase Super;
public:
_Feature() : Super(),  m_back(false) {}
void backward(const bool b) { m_back=b;}
bool backward() const  { return m_back;}

private:
bool m_back;

}; // _Feature
typedef _Feature Feature;
typedef std::vector<Feature> Features;
public:
// should isolte the spec from the ragged...
IdxTy feature(const Line & l, const IdxTy start, const IdxTy flags)
{
const bool back=Bit(flags,0);
IdxTy i=start;
Feature f;
f.backward(back);
while (i<l.size())
{
StrTy  x=l[i];
IdxTy rflags=0;
if (x=="!") { rflags|=1; ++i;
if (i<l.size()) x=l[i]; }
//if (x.c_str()[0]=='!') {rflags|=1; x=StrTy(x.c_str()+1); }
MM_ERR(" adding feature "<<MMPR2(x,l[i]))

f.push_back(RR(Rx::regex_case(x)));
if (rflags)
{
 ++i;  
if (rflags&1){  f.back().minusv=true;

if (i<l.size()){f.back().rall=Rx::regex_case(l[i]);
MM_ERR(" addinrg rall  "<<MMPR(l[i]))
}

} //minusv
} // rflags  
++i;
if (i<l.size()) { f.back().s=l[i]; }
MM_ERR(" added rfeature "<<MMPR2(f.size(),f.back().dump()))
++i;
} // i 
//MM_ERR(" added feature "<<MMPR(f.dump()]))

m_f.push_back(f);
return 0;
}
const StrTy & name (const StrTy & x ) { m_name=x;  return m_name; }
const StrTy & name () const { return m_name; }
bool matches(const Line & l) const
{
IdxTy start=0;
// foe each feature, all the regexs need to be there... 
MM_LOOP(ii,m_f)
{
const Feature & f=(*ii);
// a feature is a vector og regex all need to hit somewhere
IdxTy i=start;
bool has=true;
MM_LOOP(jj,f)
{
const Regex & r=(*jj).r;
while (!Rx::has(l[i].c_str(),r,0)) { ++i; if (i==l.size()){ has=false;  break;} }
//MM_ERR(MMPR(has))
if(!has )break;
} // jj 
// will want to rum over features though... 
// although user can save the keys
if (has) return true;
} // ii 
// unfortunately they all need to be ruled out and most
// will notbe hits. 
return false;
} // matches
/////////////////////////////////////////////////////////////////
// return the bin name made from the input strings
// and regex replace text. 
StrTy cat_old(const Line & l,const IdxTy nsamples ) const
{
StrTy hit="";
IdxTy start=nsamples;
// foe each feature, all the regexs need to be there... 
MM_LOOP(ii,m_f)
{
const Feature & f=(*ii);
const bool back=f.backward();
// a feature is a vector og regex all need to hit somewhere
IdxTy i=start;
StrTy total="";
bool has=true;
MM_LOOP(jj,f)
{
has=true;
// may be due to incrementing past last hit or l.len<=start :)
if (i>=l.size()){ has=false;  break;} 
const Regex & r=(*jj).r;
StrTy rr=(*jj).s;// if (rr.length()==0) rr="$&";
const bool minusv=(*jj).minusv;
//const bool sht=Rx::has(l[i].c_str(),r,0);
//MM_ERR(MMPR(sht))
//hit=Rx::first(l[i].c_str(),r,0);
//MM_ERR(MMPR(hit))
//while (hit.length()==0) { ++i; if (i==l.size()){ has=false;  break;} }
//while ((hit=Rx::first(l[i].c_str(),r,0)).length()==0) { ++i; if (i==l.size()){ has=false;  break;} }
if (minusv)
{
//while (!Rx::has(l[i].c_str(),r,0)) { ++i; if (i==l.size()){ has=false;  break;} }
while (Rx::has(l[back?(l.size()+start-1-i):i].c_str(),r,0)) 
{ 
const StrTy xxxx=l[back?(l.size()+start-1-i):i] ;
MM_ERR(" mins search "<<MMPR3(xxxx,back,i))
++i; if (i==l.size()){ has=false;  break;} }
if (has){
auto rall=(*jj).rall; //(Rx::regex(".*"));
 const StrTy src=l[back?(l.size()+start-1-i):i]; 
 //hit=std::regex_replace(l[back?(l.size()+start-1-i):i].c_str(),rall,rr,std::regex_constants::format_no_copy); 
 hit=std::regex_replace(src.c_str(),rall,rr,std::regex_constants::format_no_copy); 
MM_ERR(" hit minusv "<<MMPR4(i,src,hit,rr))
if (hit.length()==0) hit=src;
} // had 

} //minusv 

if (!minusv) {
// each feature in m_f must be found but there is no assureance s__ follows g__
// so allow only one regex per key level, advance on a hit too. 

//#error this fails when the hit generates no output... doh doh 
while ((hit=std::regex_replace(l[back?(l.size()+start-1-i):i].c_str(),r,rr,std::regex_constants::format_no_copy)).length()==0) 
{ ++i;if (back) {if (i==start){has=false; break;}     }  if (i==l.size()){ has=false;  break;} }
} // minusv

//while (!) { ++i; if (i==l.size()){ has=false;  break;} }
//MM_ERR(MMPR(has))
if(!has )break;
// this is ok, the ITS files are a bit odd. This needs an option
// to deal with missing x__ and short keys etc. 
else total+=" "+hit;
++i; // force next regex to test following key level after this hit, 
} // jj 
// will want to rum over features though... 
// although user can save the keys
if (has) return total;
} // ii 
// unfortunately they all need to be ruled out and most
// will notbe hits. 
return StrTy();
} //cat_old
 
/////////////////////////////////////////
StrTy cat(const Line & l,const IdxTy nsamples ) const
{
StrTy hit="";
IdxTy start=nsamples;
// foe each feature, all the regexs need to be there... 
MM_LOOP(ii,m_f)
{
const Feature & f=(*ii);
const bool back=f.backward();
// a feature is a vector og regex all need to hit somewhere
IdxTy i=start;
StrTy total="";
bool has=true;
MM_LOOP(jj,f)
{
has=true;
// may be due to incrementing past last hit or l.len<=start :)
if (i>=l.size()){ has=false;  break;} 
const Regex & r=(*jj).r;
const Regex&  rall=(*jj).rall; //(Rx::regex(".*"));
StrTy rr=(*jj).s;// if (rr.length()==0) rr="$&";
const bool minusv=(*jj).minusv;
while (true)
{
if (i>=l.size()){ has=false;  break; }
const IdxTy loc=back?(l.size()+start-1-i):i;
const StrTy & li=l[loc];
const bool ithas=(Rx::has(li.c_str(),r,0)) ;
const bool ok=(ithas&&!minusv) || ( minusv&&!ithas);
if (!ok) { ++i; continue; } // ok 
 hit=std::regex_replace(li.c_str(),minusv?rall:r,rr,std::regex_constants::format_no_copy); 
if (total.length()) total+=" ";
total+=hit;
++i; // force next regex to test following key level after this hit, 
break;
} // true
if (!has) break;
} // jj 
if (has) return total;
} // ii 
// unfortunately they all need to be ruled out and most
// will notbe hits. 
return StrTy();
} //cat
 

////////////////////////////////////////
StrTy m_name;
Features m_f;

}; // _bin_spec_class
typedef _bin_spec_class BinSpec;
typedef std::map<StrTy,BinSpec> BinSpecV;

public:
mjm_bar_intervals() {}
~mjm_bar_intervals() {}
// d is a data rag containing a header and columns of counts followed by
// hierarchial key. 
// These are organized on interval bars depennding on which keys
// match regexs in spec. The geometry of the output svg is
// described in li. 
IdxTy layout_interval_bars(const StrTy  & fn, const StrTy & df, const StrTy  & sf, const IdxTy flags)
{
MM_ERR(MMPR4(fn,df,sf,flags))
Ragged s,d;
LayoutInfo li;
std::ifstream sfs(sf);
std::ifstream dfs(df);
s.load(sfs);
d.load(dfs);
std::ofstream ofs(fn);
return layout_interval_bars(ofs,d,s,li,flags);
}
IdxTy classify_interval_bars(const StrTy  & fn, const StrTy & df, const StrTy  & sf, const IdxTy flags)
{
MM_ERR(MMPR4(fn,df,sf,flags))
Ragged s,d,res;
LayoutInfo li;
std::ifstream sfs(sf);
std::ifstream dfs(df);
s.load(sfs);
d.load(dfs);
IdxTy rc=classify_interval_bars(res,d,s,li,flags);
std::ofstream ofs(fn);
// should have a stream method doh 
ofs<<res.dump_ssv();
return rc;
}


IdxTy layout_interval_bars(OsTy & os, const Ragged & d, const Ragged & spec, const LayoutInfo & li, const IdxTy flags)
{ return LayoutIntervalBars(os,d,spec,li,flags); }

IdxTy classify_interval_bars(const Ragged & res, const Ragged & d, const Ragged & spec, const LayoutInfo & li, const IdxTy flags)
{ return ClassifyIntervalBars(res,d,spec,li,flags); }



StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
//////////////////////////////////////////////


class svg_output_class
{

public:
svg_output_class( OsTy & _os) : os(_os) {}
template <class Tl> IdxTy start(const Tl & li)
{
const IdxTy xs=li.total_x(); // 100;
const IdxTy ys=li.total_y(); // 100;
os<<sw.start_text(" test foo",xs,ys);
//os<<sw.frame_text("#00808080",xs,ys);
//  pdf convert  up bigger 
os<<sw.frame_text("#808080",xs,ys);
MM_ERR(MMPR2(xs,ys))
return 0; 
} // start
template <class Tl >
IdxTy write_samples(Tl &li, const Line  & hdr)
{
const IdxTy n=li.length();

for(IdxTy j=0; j<n; ++j)
{
const D yscale=li.ymax()-li.ymin();
const D x1=j*li.xpitch()+li.xmin();
const D y1= li.ymin()-40;// li.y(seqp,col);

D nsz=li.p("sample_text_sz"); // 10; // li.szname(seqp);
const StrTy fcolor="black";
 ss<<sw.gtext_text(hdr[j],x1,y1,nsz,fcolor,StrTy("start"),-45);
ss<<CRLF;
} // j 

return 0;
} // write_samples




//ot.write_names(li,la,posv);

template <class Tl >
IdxTy write_name( Tl &li, const StrTy & nm,  const IdxTy & posv,const StrTy fcolor="black")
{
const IdxTy nseq=li.nseq();
const D yscale=li.ymax()-li.ymin();
const D newpitch=2*yscale/nseq;
const bool right=(posv&1);
const D x1=right?li.xmax():li.xm();
MM_ERR(" writing name "<<MMPR4(nm,posv,right,x1))
//const D y1=li.ymin()+(posv>>1)*li.ypitch();
const D y1=li.ymin()+(posv>>1)*newpitch;
const D nsz=li.p("otu_text_sz"); // 10; // li.szname(seqp);
//const StrTy fcolor="black";
if (right) ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("end"),0);
else ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("start"),0);
ss<<CRLF;
return 0;
} // write_name

#if 1 
void write_connect(LayoutInfo& li, const IdxTy pos, const StrTy color)
{
const IdxTy n=li.length();
if (n<1) return ; 
const IdxTy nseq=li.nseq();
const D yscale=li.ymax()-li.ymin();
const D newpitch=2*yscale/nseq;
const bool right=(pos&1);
const D w= li.xpitch()/2; // li.w(seqp,col);
D x1=right?li.xmax():li.xm();
if (right) x1-=50; else x1+=50;
//const D y1=li.ymin()+(pos>>1)*li.ypitch();
const D y1=li.ymin()+(pos>>1)*newpitch;
const D x2=(right?(n-1):0)*li.xpitch()+li.xmin()+(right?w:0);
const D y2= li.ymin()+m_base[right?(n-1):0]*yscale;// li.y(seqp,col);
ss<<sw.line_text(x1,y1,x2,y2,color,2);
//const D x2=j*li.xpitch()+li.xmin();
//const D y2= li.ymin()+m_base[j]*li.ypitch()*20;// li.y(seqp,col);
//const D w= li.xpitch()/2; // li.w(seqp,col);
//const D h= v*li.ypitch()*20; // li.h(seqp,col);
for(IdxTy j=0; j<(n-1); ++j)
{
const D x1=j*li.xpitch()+li.xmin()+w;
const D y1= li.ymin()+m_base[j]*yscale;// li.y(seqp,col);
const D x2=(j+1)*li.xpitch()+li.xmin()+0*w;
const D y2= li.ymin()+m_base[j+1]*yscale;// li.y(seqp,col);

// StrTy line_text( const D& x0, const D& y0, const D & x1, const D & y1, const StrTy & color="#00ffffff",const D & sw=10, const D opaq=1.0) const

ss<<sw.line_text(x1,y1,x2,y2,color,2);
ss<<CRLF;


}

} // write_connect
#endif
//for(IdxTy j=9; j<b.m_vals.size(); ++j) soc.write_bar(li,pos,j,b.m_vals[j]);
IdxTy write_bar(LayoutInfo & li, const IdxTy pos, const IdxTy j, const StrTy & nm, const D & v)
{
// gtext_text(const StrTy &text, const D& x, const D& y, const D & sz, const StrTy & color="#00ffffff", const StrTy & anchor="left",const D & angle=45) const
while (m_base.size()<=j) m_base.push_back(0); 
while (m_base.size()<=li.length()) m_base.push_back(0); 
static std::map<IdxTy,StrTy> mcolor;
if (mcolor.size()==0)
{
mcolor[0]="black"; mcolor[1]="white"; mcolor[2]="red"; mcolor[3]="blue"; mcolor[4]="green";

}
const IdxTy col=pos%mcolor.size();
//const bool lr=(pos&1);
const D yscale=li.ymax()-li.ymin();
const D x1=j*li.xpitch()+li.xmin();
const D y1= li.ymin()+m_base[j]*yscale;// li.y(seqp,col);
const D w= li.xpitch()/2; // li.w(seqp,col);
const D h= v*yscale; // li.h(seqp,col);
//MM_ERR(MMPR4(j,li.xpitch(),m_base[j],v)<<MMPR4(x1,y1,w,h))
//const D tsz=li.base_size(seqp,col);
const StrTy bcolor=mcolor[col]; // lr?StrTy("black"):StrTy("white");// schem[i].bg; // "black";
if (j==0) write_connect(li,pos,bcolor); 
//const StrTy fcolor=lr?StrTy("white"):StrTy("black");// schem[i].bg; // "black";
//const StrTy fcolor=schem[i].fg; // "white";
//StrTy rect_text( const StrTy& x, const StrTy& y, const StrTy & w, const StrTy & h, const StrTy & color="#00ffffff") const
ssseq<<sw.rect_text(x1,y1,w,h,bcolor);
const D off=.3+.1*(pos%4);
if (h!=0) {
ssseq<<sw.vtextb_text(nm,x1+off*w, y1+.5*h,w/8,mcolor[(pos+1)%mcolor.size()]);
ssseq<<CRLF;
}
m_base[j]+=v;
//ssseq<<sw.gtext_text(colstr[i],x1+w/2,y1,tsz,fcolor,StrTy("middle"),0);
return 0;
} // write_col
IdxTy fini()
{
os<<ssseq.str();
os<<ss.str();
os<<sw.end_text();
os<<CRLF;
return 0;
} // fini
std::vector<D> m_base;
OsTy & os;
Sw sw;
Ss ssseq,ss;
}; // svg_output_class

////////////////////////////////////////////////////



class ssv_output_class
{

public:
ssv_output_class( OsTy & _os) : os(_os) {}
template <class Tl> IdxTy start(const Tl & li)
{
//const IdxTy xs=li.total_x(); // 100;
//const IdxTy ys=li.total_y(); // 100;
//os<<sw.start_text(" test foo",xs,ys);
//os<<sw.frame_text("#00808080",xs,ys);
//  pdf convert  up
//os<<sw.frame_text("#808080",xs,ys);
//MM_ERR(MMPR2(xs,ys))
return 0; 
} // start
template <class Tl >
IdxTy write_samples(Tl &li, const Line  & hdr)
{
const IdxTy n=li.length();
if (m_r.size()<1) m_r.add(Line(n+1));
for(IdxTy j=0; j<n; ++j)
{
m_r[0][j]=hdr[j];
//const D yscale=li.ymax()-li.ymin();
//const D x1=j*li.xpitch()+li.xmin();
//const D y1= li.ymin()-40;// li.y(seqp,col);

//D nsz=li.p("sample_text_sz"); // 10; // li.szname(seqp);
//const StrTy fcolor="black";
// ss<<sw.gtext_text(hdr[j],x1,y1,nsz,fcolor,StrTy("start"),-45);
//ss<<CRLF;
} // j 

return 0;
} // write_samples




//ot.write_names(li,la,posv);

template <class Tl >
IdxTy write_name( Tl &li, const StrTy & nm,  const IdxTy & posv,const StrTy fcolor="black")
{
IdxTy loc=posv+1;
const IdxTy n=li.length();
while (m_r.size()<=loc) m_r.add(Line(n+1)); 
Line & l=m_r[loc];
while (l.size()<=(n+1)) l.push_back(StrTy());
l[n]=nm;
//const IdxTy nseq=li.nseq();
//const D yscale=li.ymax()-li.ymin();
//const D newpitch=2*yscale/nseq;
//const bool right=(posv&1);
//const D x1=right?li.xmax():li.xm();
//MM_ERR(" writing name "<<MMPR4(nm,posv,right,x1))
//const D y1=li.ymin()+(posv>>1)*li.ypitch();
//const D y1=li.ymin()+(posv>>1)*newpitch;
//const D nsz=li.p("otu_text_sz"); // 10; // li.szname(seqp);
//const StrTy fcolor="black";
//if (right) ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("end"),0);
//else ss<<sw.gtext_text(nm,x1,y1,nsz,fcolor,StrTy("start"),0);
//ss<<CRLF;
return 0;
} // write_name

#if 1 
void write_connect(LayoutInfo& li, const IdxTy pos, const StrTy color)
{

} // write_connect
#endif
//for(IdxTy j=9; j<b.m_vals.size(); ++j) soc.write_bar(li,pos,j,b.m_vals[j]);
IdxTy write_bar(LayoutInfo & li, const IdxTy pos, const IdxTy j, const StrTy & nm, const D & v)
{
IdxTy loc=pos+1;
const IdxTy n=li.length();
while (m_r.size()<=loc) m_r.add(Line(n+1)); 
Line & l=m_r[loc];
while (l.size()<=(n+1)) l.push_back(StrTy());
Ss ss;
ss<<(v*100);
l[j]+=ss.str();
// gtext_text(const StrTy &text, const D& x, const D& y, const D & sz, const StrTy & color="#00ffffff", const StrTy & anchor="left",const D & angle=45) const
//while (m_base.size()<=j) m_base.push_back(0); 
//while (m_base.size()<=li.length()) m_base.push_back(0); 
//static std::map<IdxTy,StrTy> mcolor;
//if (mcolor.size()==0)
//{
//mcolor[0]="black"; mcolor[1]="white"; mcolor[2]="red"; mcolor[3]="blue"; mcolor[4]="green";

//}
//const IdxTy col=pos%mcolor.size();
//const bool lr=(pos&1);
//const D yscale=li.ymax()-li.ymin();
//const D x1=j*li.xpitch()+li.xmin();
//const D y1= li.ymin()+m_base[j]*yscale;// li.y(seqp,col);
//const D w= li.xpitch()/2; // li.w(seqp,col);
//const D h= v*yscale; // li.h(seqp,col);
//MM_ERR(MMPR4(j,li.xpitch(),m_base[j],v)<<MMPR4(x1,y1,w,h))
//const D tsz=li.base_size(seqp,col);
//const StrTy bcolor=mcolor[col]; // lr?StrTy("black"):StrTy("white");// schem[i].bg; // "black";
//if (j==0) write_connect(li,pos,bcolor); 
//const StrTy fcolor=lr?StrTy("white"):StrTy("black");// schem[i].bg; // "black";
//const StrTy fcolor=schem[i].fg; // "white";
//StrTy rect_text( const StrTy& x, const StrTy& y, const StrTy & w, const StrTy & h, const StrTy & color="#00ffffff") const
//ssseq<<sw.rect_text(x1,y1,w,h,bcolor);
//const D off=.3+.1*(pos%4);
//if (h!=0) {
//ssseq<<sw.vtextb_text(nm,x1+off*w, y1+.5*h,w/8,mcolor[(pos+1)%mcolor.size()]);
//ssseq<<CRLF;
//}
//m_base[j]+=v;
//ssseq<<sw.gtext_text(colstr[i],x1+w/2,y1,tsz,fcolor,StrTy("middle"),0);
return 0;
} // write_col
IdxTy fini()
{
//os<<ssseq.str();
//os<<ss.str();
os<<m_r.dump_ssv();
//os<<sw.end_text();
//os<<CRLF;
return 0;
} // fini
Ragged m_r;
std::vector<D> m_base;
OsTy & os;
//Sw sw;
Ss ssseq,ss;
}; // ssv_output_class



////////////////////////////////////////////////////





static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

IdxTy ClassifyIntervalBars(Ragged & res, const Ragged & d, const Ragged & spec, const LayoutInfo & _li, const IdxTy flags)
{
BinVec bv;
FindBins(bv,d,spec,flags);
//BinVecDump(res,bv,flags);
return 0;
}

IdxTy LayoutIntervalBars(OsTy & os, const Ragged & d, const Ragged & spec, const LayoutInfo & _li, const IdxTy flags)
{ 
const bool output_svg=Bit(flags,0);
const bool output_ssv=Bit(flags,1);
if (!( output_svg||output_ssv))
{
MM_ERR(" need at least one flag bit set now "<<MMPR3(flags,output_svg,output_ssv))
return ~0; 
}
LayoutInfo li=_li; // adaptive 
// should compile or index spec....
// first calculate the bins
BinVec bv;
if (d.size()==0)
{
MM_ERR(" data file size is zero "<<MMPR3(__FUNCTION__,d.size(),spec.size()))
return 0;
}
Line hdr;
const IdxTy nsamples=FindBins(hdr,bv,d,spec,flags);
li.nseq(bv.size());
li.length(nsamples);
li.set("m_xpitch",100);
li.set("lname",200);
li.set("rname",200);
li.set("m_ypitch",20);
li.set("m_tm",400); // needs to accomodate names at 45 tilt 
li.set("m_bm",200);
li.set("sample_text_sz",20); // 10; // li.szname(seqp);
li.set("otu_text_sz",20); // 10; // li.szname(seqp);

li.calc();
MM_ERR(MMPR(li.dump()))
if (output_svg)
{
svg_output_class soc(os);
WriteIntervalBars(soc,bv,li,hdr,flags);
}
if (output_ssv)
{
ssv_output_class soc(os);
//WriteIntervalBars(os,bv,li,hdr,flags);
WriteIntervalBars(soc,bv,li,hdr,flags);
}

return 0; 

} // LayoutIntervalBars
template <class Tv> void OrderBinVecVals( Tv & vec, const BinVec & bv, const IdxTy flags)
{
MM_LOOP(ii,bv) {vec.push_back((*ii).first); }

std::sort(vec.begin(), vec.end(), [&](const StrTy& a, const StrTy& b) { 
D x=0; MM_LOOP(ii,(*(bv.find(a))).second.m_vals) x+=(*ii);
D y=0; MM_LOOP(ii,(*(bv.find(b))).second.m_vals) y+=(*ii);
//D y=0; MM_LOOP(ii,bv[b].m_vals) y+=(*ii);
return x>y; });
const IdxTy sz=vec.size();
//const IdxTy sza=sz&(~1);
for(IdxTy i=0; i<(sz>>1); i+=2)
{
const StrTy a=vec[i];
const StrTy b=vec[sz-i-1];
vec[i]=b;
vec[sz-i-1]=a;
} 

} // OrderBinVecVals
template <class Tv> void OrderBinVecLocs( Tv & vec, const BinVec & bv, const IdxTy flags)
{
MM_LOOP(ii,bv) {vec.push_back((*ii).first); }

std::sort(vec.begin(), vec.end(), [&](const StrTy& a, const StrTy& b) { 
IdxTy x=~0; {  auto ii=bv.find(a); if (ii!=bv.end()) { const auto &  loa= (*ii).second.m_locations; if (loa.size()) x=loa[0];} }
IdxTy y=~0; { auto ii=bv.find(b); if (ii!=bv.end()) { const auto & loa= (*ii).second.m_locations; if (loa.size()) y=loa[0]; }}
 
//D x=0; MM_LOOP(ii,(*(bv.find(a))).second.m_vals) x+=(*ii);
//D y=0; MM_LOOP(ii,(*(bv.find(b))).second.m_vals) y+=(*ii);
//D y=0; MM_LOOP(ii,bv[b].m_vals) y+=(*ii);
return x>y; });
if (1)
{
const IdxTy sz=vec.size();
//const IdxTy sza=sz&(~1);
for(IdxTy i=0; i<(sz>>1); i+=2)
{
const StrTy a=vec[i];
const StrTy b=vec[sz-i-1];
vec[i]=b;
vec[sz-i-1]=a;
} 
}
} // OrderBinVecLocs

template < class Td, class Ts > void CheckedFind(Td & x, const Ts & ii)
{
// ii is checked before entry, 
const auto & src=(*ii).second.m_src; // begin();
const auto jj=src.begin();
if (jj==src.end()) return;
if (0==(*jj).first.size()) return ; 
x=(*jj).first; 
//{ x= (*((*ii).second.m_src.begin())).first;  }}

}
template <class Tv> void OrderBinVecHier( Tv & vec, const BinVec & bv, const IdxTy flags)
{
MM_LOOP(ii,bv) {vec.push_back((*ii).first); }

std::sort(vec.begin(), vec.end(), [&](const StrTy& a, const StrTy& b) { 
std::vector<StrTy> x,y;
//{auto ii=bv.find(a); if (ii!=bv.end()) { x= (*((*ii).second.m_src.begin())).first;  }}
{auto ii=bv.find(a); if (ii!=bv.end()) {CheckedFind(x,ii); }}
{auto ii=bv.find(b); if (ii!=bv.end()) {CheckedFind(y,ii); }}
//{auto ii=bv.find(b); if (ii!=bv.end()) { y= (*((*ii).second.m_src.begin())).first;  }}

return x>y; });
} // OrderBinVecHier



template <class Tv> void OrderBinVec( Tv & vec, const BinVec & bv, const IdxTy flags)
{
//MM_LOOP(ii,bv) {vec.push_back((*ii).first); }
//OrderBinVecVals(vec,bv,flags);
//OrderBinVecLocs(vec,bv,flags);
OrderBinVecHier(vec,bv,flags);

} // OrderBinVec
template <class Tsoc> 
IdxTy WriteIntervalBars(Tsoc & soc, const BinVec & bv, LayoutInfo & li, const Line & hdr, const IdxTy flags)
//IdxTy WriteIntervalBars(OsTy & os, const BinVec & bv, LayoutInfo & li, const Line & hdr, const IdxTy flags)
{
const bool color_phylum=true;
std::vector<StrTy> vec;
OrderBinVec(vec,bv,0);
//svg_output_class soc(os);
soc.start(li);
MM_ERR(MMPR(bv.size()))

soc.write_samples(li,hdr);
IdxTy pos=0;
StrTy phylum="";
std::vector<StrTy> colors;
colors.push_back("black");
colors.push_back("red");
colors.push_back("blue");
colors.push_back("white");
IdxTy cptr=0;
//MM_LOOP(ii,bv)
MM_LOOP(_ii,vec)
{
const auto ii=bv.find(*_ii);
//MM_ERR(MMPR2((*ii).first,(*ii).second.dump()))
//soc.write_bar();
//IdxTy write_bar(const Tc & colstr,const Ts & schem,const Tp & posv,const To & loi, const Tl  & li ,const IdxTy col)
const auto & b=(*ii).second;
MM_ERR(" hit_keyii "<<MMPR2(b.name(),(*ii).first))
MM_ERR(b.hit_keys(" hit_keys"));
if (b.name()!="__sum"){
// TODO should check for content but in reality has to be here.. 
//const StrTy phylumii=(*(b.m_src.begin())).second[0];
if (color_phylum) { 
std::vector<StrTy> v;
CheckedFind(v,ii);
StrTy phylumii=(v.size()>1)?v[1]:StrTy("");
MM_ERR(MMPR2(phylumii,phylum))
if (phylumii!=phylum) { phylum=phylumii; cptr=(cptr+1)%colors.size(); } 
}
soc.write_name(li,b.name(),pos,colors[cptr]);
for(IdxTy j=0; j<b.m_vals.size(); ++j) soc.write_bar(li,pos,j,b.name(),b.m_vals[j]);
}
++pos;
} // ii
//soc.write_names();
//template <class Tp,class Tl,class Ti >
//IdxTy write_names(const Tl &loi, const Fasta & fasta,  const Ti & li, const Tp & posv)

soc.fini();
return 0;
} // WriteIntervalBars



IdxTy WriteIntervalBarsOld(OsTy & os, const BinVec & bv, LayoutInfo & li, const Line & hdr, const IdxTy flags)
{
svg_output_class soc(os);
soc.start(li);
MM_ERR(MMPR(bv.size()))

soc.write_samples(li,hdr);
IdxTy pos=0;
MM_LOOP(ii,bv)
{
MM_ERR(MMPR2((*ii).first,(*ii).second.dump()))
//soc.write_bar();
//IdxTy write_bar(const Tc & colstr,const Ts & schem,const Tp & posv,const To & loi, const Tl  & li ,const IdxTy col)
const auto & b=(*ii).second;
if (b.name()!="__sum"){
soc.write_name(li,b.name(),pos);
for(IdxTy j=0; j<b.m_vals.size(); ++j) soc.write_bar(li,pos,j,b.name(),b.m_vals[j]);
}
++pos;
} // ii
//soc.write_names();
//template <class Tp,class Tl,class Ti >
//IdxTy write_names(const Tl &loi, const Fasta & fasta,  const Ti & li, const Tp & posv)

soc.fini();
return 0;
} // WriteIntervalBarsOld

IdxTy CompileBins( BinSpecV & bins, const Ragged & spec, const IdxTy flags)
{
MM_LOOP(ii,spec)
{
const Line & l=(*ii);
const IdxTy len=l.size();
if (len<2) continue;
if (l[0]=="bin") { bins[l[1]].feature(l,2,0);continue;  } 
if (l[0]=="rbin") { bins[l[1]].feature(l,2,1);continue;  } 

} // ii 
// dumb?
MM_LOOP(ii,bins) { (*ii).second.name((*ii).first); }
MM_ERR(MMPR(bins.size()))
return 0;
} // CompileBins
IdxTy EditSSV(Ragged & dtemp, const Ragged & d, const Ragged & spec, const IdxTy flags)
{
std::vector<IdxTy> cols;
std::vector<RR> samples;
Regex key;
bool found=false;
bool keyfound=false;
MM_LOOP(ii,spec)
{
const Line & l=(*ii);
const IdxTy len=l.size();
if (len<2) continue;
//while ((hit=std::regex_replace(l[i].c_str(),r,rr,std::regex_constants::format_no_copy)).length()==0) { ++i; if (i==l.size()){ has=false;  break;} }
if (l[0]=="samples") {found=true;  for(IdxTy i=1; i<len; ++i) 
{samples.push_back(RR(Rx::regex_case(l[i]))); 
++i;
if (i<len) samples.back().s=l[i];
++i;
}
}  // samples. 
// TODO FIXME this should then determine nsamples but it does not 
if (l[0]=="key") {keyfound=true; MM_ERR(MMPR3(keyfound,len,l[len-1]))  for(IdxTy i=1; i<len; ++i) key=((Rx::regex_case(l[i]))); }  // samples. 
} // ii 
// dumb?
 // just use the original, 
if (found==false) return 0;
const Line & hdr=d[0]; // size checked prior to entry 
IdxTy keypos=0;
//while (!Rx::has(l[i].c_str(),r,0)) { ++i; if (i==l.size()){ has=false;  break;} }
if( keyfound) {  MM_LOOP(ii,hdr) {if( Rx::has(*ii,key,0)) break; ++keypos; }  }
else keypos=hdr.size();
// reverse order so that samples appear in order of applicable rule
// this risks and allows dups... 
//for(IdxTy i=0; i<keypos; ++i )
//{ MM_LOOP(ii,samples) { if ( Rx::has(hdr[i],(*ii),0)) { cols.push_back(i); break; }} } // i 

MM_LOOP(ii,samples) { for(IdxTy i=0; i<keypos; ++i )
 { if ( Rx::has(hdr[i],(*ii).r,0)) { cols.push_back(i);  }} } // i 

const IdxTy nnsamp=cols.size();

for(IdxTy i=keypos; i<hdr.size(); ++i ) cols.push_back(i);
MM_LOOP(ii,d)
{
Line lnew;
const Line & l=(*ii);
const IdxTy len=l.size();
MM_LOOP(jj,cols){  if((*jj)<len)   lnew.push_back(l[*jj]); }
//IdxTy k=0; 
//for(IdxTy j=0; j<len; ++j)
//{
//if (k==cols.size()) break;
//if (j==cols[k]) { lnew.push_back(l[j]); ++k; }
//} // j 
D summa=0;
for(IdxTy i=0; i<nnsamp; ++i) summa+=atof(lnew[i].c_str());
if ((dtemp.size()==0)||(summa!=0)) dtemp.add(lnew);
} // ii 
// now fix dnew[0]
MM_LOOP(ii,dtemp[0])
{
if( keyfound) if( Rx::has(*ii,key,0)) break; 
//while ((hit=std::regex_replace(l[i].c_str(),r,rr,std::regex_constants::format_no_copy)).length()==0) { ++i; if (i==l.size()){ has=false;  break;} }
MM_LOOP(jj,samples) 
 { if ((*jj).s.length())if ( Rx::has((*ii),(*jj).r,0)) { (*ii)=std::regex_replace((*ii).c_str(),(*jj).r,(*jj).s);  }}  // i 
} // ii 


Ss ss;
MM_LOOP(ii,dtemp[0]) { ss<<(*ii)<<" "; } 
MM_ERR(" new header "<<MMPR(keypos)<<MMPR(dtemp[0].size())<< MMPR(ss.str()))
return ~0;
} // EditSSV

IdxTy FindBins(Line & _hdr, BinVec & bv, const Ragged & _d, const Ragged & spec, const IdxTy flags)
{
// each line in d needs to be checked against every regex set in spec
// as multiple bins can be filled 
// compile bin specs

BinSpecV bins;
CompileBins(bins,spec,flags);
const bool normalize=true;
const bool skip_header=true;
IdxTy nsamples=0;
IdxTy cnt=0;

Ragged dtemp;
IdxTy rce=EditSSV(dtemp,_d,spec,flags);
const Ragged & d=(rce==0)?_d:dtemp; 
// the input file is presumed to contain "orthogonal" samples
// so the sum is meaninful but the regex selected sub-sums
// may overlap etc. 
std::vector<D> sums(nsamples),other(nsamples);
std::map<IdxTy,IdxTy> matches_histo;
Line hdr;
if (d.size()){  hdr=d[0]; _hdr=d[0]; } 
MM_LOOP(ii,d)
{
const Line & l=(*ii);
const IdxTy len=l.size();
IdxTy matches=0;
// this first line should be the header, no use... 
if (nsamples==0)
{
if (cnt)
{
while (nsamples<len) { 
const char * p=l[nsamples].c_str();
char * end; 
const double ni=strtod(p,&end);
if ((ni!=0)||(end!=p)) ++nsamples;
//if ((*p=='0')||(atoi(*p)>0)) ++nsamples;
else break;
} // while
while (sums.size()<=nsamples) { sums.push_back(0); } 
while (other.size()<=nsamples) { other.push_back(0); } 
} // cnt
MM_ERR(MMPR3(nsamples,len,cnt))
} // nsamples==0
// convert the counts to floats

if (skip_header) if (cnt==0) { ++cnt; continue; } 
std::vector<D> delta(nsamples);
for(IdxTy i=0; i<nsamples; ++i) delta[i]=atof(l[i].c_str()); 
for(IdxTy i=0; i<nsamples; ++i) sums[i]+=delta[i]; 
// scan line for hits to each bin
MM_LOOP(jj,bins)
{
const BinSpec & bin=(*jj).second;
const StrTy cat=bin.cat(l,nsamples); 
//if (bin.matches(l))
if (cat.length())
{
++matches;
// for each match update the counts
const StrTy & n=bin.name();
auto & b=bv[cat];
b.name(n); // stupid repeates
b.name(cat); // stupid repeates
b.hit(); 
b.location(cnt);
b.hierarchy(l,nsamples);
// just update all of them sofar...???
for(IdxTy i=0; i<nsamples; ++i) b.add(i,delta[i]); 

} // matches
} // jj 
++matches_histo[matches];
if ( matches==0) { 
bv["__other"].name("__other");
bv["__other"].location(cnt);  
bv["__other"].hierarchy(l,nsamples);  
for(IdxTy i=0; i<nsamples; ++i) other[i]+=delta[i];  }
++cnt;
} // ii 
// options to normalize the counts 
// or just add to bin vector 
{ Ss ss; ss<<CRLF;  ss<<" matches ";  MM_LOOP(ii,matches_histo) {IdxTy n=(*ii).first; IdxTy hist=(*ii).second; ss<<MMPR2(n,hist)<<" "; } MM_ERR(ss.str());  }
{ Ss ss;  ss<<CRLF;
 for(IdxTy i=0; i<nsamples; ++i){StrTy hi=(i<hdr.size())?hdr[i]:""; D f=(sums[i]==0)?0:(other[i]/sums[i]);    ss<<MMPR4(i, hi, other[i], sums[i] ); ss<<MMPR(f)<<CRLF;  }
MM_ERR(ss.str())
 }
bv["__other"].name("__other");

 for(IdxTy i=0; i<nsamples; ++i){bv["__other"].add(i,other[i]); }

MM_LOOP(ii,bv) { MM_ERR((*ii).second.dump()); }
if (normalize)
{
MM_LOOP(ii,bv) { (*ii).second.normalize(sums); }


} // normalize




bv["__sum"].name("__sum");
 for(IdxTy i=0; i<nsamples; ++i){ bv["__sum"].add(i,sums[i]); }


return nsamples;
} // FindBins


// MEMBERS



}; // mjm_bar_intervals

//////////////////////////////////////////////

template <class Tr>
class mjm_bar_intervals_map : public std::map<typename Tr::StrTy, mjm_bar_intervals< Tr > >  
{
 typedef mjm_bar_intervals_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_bar_intervals< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_bar_intervals_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_bar_intervals_map




////////////////////////////////////////////
#ifdef  TEST_MJM_BAR_INTERVALS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_bar_intervals <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_BAR_INTERVALS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_bar_intervals<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//IdxTy layout_interval_bars(const StrTy  & fn, const StrTy & df, const StrTy  & sf, const IdxTy flags)
else if (cmd=="layout") { x.layout_interval_bars(cip.p1,cip.p2,cip.wif(3),atoi(cip.wif(4).c_str())); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_BAR_INTERVALS_H__ 
