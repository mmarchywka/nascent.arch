#ifndef MJM_PLOTTER_BASICS_H__
#define MJM_PLOTTER_BASICS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

//#include "mjm_floorplan_points.h"
#include "mjm_crowd_repulsion.h"
#include "mjm_data_model_error_log.h"
#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_logic_base.h"
#include "mjm_strings.h"

#include "mjm_canned_methods.h"
#include "mjm_svg_plotter_base.h"


#include "mjm_cli_ui.h"

#include "mjm_tokenized_collections.h"

#include "mjm_canned_methods.h"
// add day number to notes 
#include "mjm_calendar.h"
#include "mjm_strings.h"
#include "mjm_svg_writer.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat Apr 30 19:10:56 EDT 2022
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_svg_plotter_basics   
// g++  -Wall -std=gnu++11 -DTEST_MJM_PLOTTER_BASICS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_svg_plotter_basics.h  -o mjm_svg_plotter_basics.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_svg_plotter_basics("mjm_svg_plotter_basics"
, "  ");
///////////////////////////////////////////////////////////////////////////
template <class Tr>
class mjm_svg_plotter_frame : public mjm_svg_plotter_base<Tr>
{
 typedef mjm_svg_plotter_frame Myt;
 typedef mjm_svg_plotter_base<Tr> Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef typename Super::Ragged Ragged;
typedef typename Ragged::Line  Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef mjm_canned_methods Canned;
typedef mjm_svg_writer Sw;
enum  {DEFS=Super::DEFS,BODY=Super::BODY,POST=Super::POST};
public:
// floating point equality is not assured 
//typedef D Zidx;
typedef IdxTy Zidx;
typedef std::map<D,IdxTy> Zmap;
// a component can have multiple Z-levels, traversal is
// potential mess ... 
typedef typename Super::_Point Point;
typedef typename Super::Points Points;
typedef typename Super::Values Values;
typedef typename Super::Zord Zord;
typedef typename Super::params_type params_type;
//typedef mjm_floorplan_points<Tr> FloorPlan;
typedef typename Super::FloorPlan FloorPlan;

public:
// I guess these could be virtual, don't emember ctor order on hierarchy.. 
mjm_svg_plotter_frame(): Super() {
MM_ERR(" ctor adscascas ")

Init();}
virtual ~mjm_svg_plotter_frame() {Dtor();}
virtual void make_layout( FloorPlan & fp ) {MakeLayout(fp); }
IdxTy ctor(const Ragged & r, const StrTy & type, const StrTy & nm, params_type & pt, const IdxTy flags) 
{
// no call super? 
MM_ERR("  ctor fasdfasdf")
return 0;
} // ctor 

// at least override this... 

//virtual IdxTy write_self_svg(OsTy & os, Sw & sw, Myt * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 

virtual IdxTy write_self_svg(OsTy & os, Sw & sw, Super * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 
{
// this confuses the  read
if (false) {
Ss ss; 
ss<<"first component here  ... "<< MM_MARKF<<" ";
ss<<MMPR3(Super::m_rtti,Super::m_name,Super::m_type)<<MMPR2(zord.dump(),pass);
 os<<sw.comment_text(ss);
os<<CRLF;
}
//
if (pass==DEFS)
{
// floorplan here?
FloorPlan & fp=Super::m_fp;
fp.bounds(m_xs,m_ys);
// needs to have a kid lol.
auto kp=(*(Super::m_kids.begin())).second[0];
fp.allocate(kp,  this,m_xs/4,m_ys/4,m_xs/2,m_ys/2,0);
make_layout(fp);
if (m_use_old_header)
{
//ow.bounds(x,y,lc.m_level_sz);
os<<sw.start_text(" test foo",m_xs,m_ys);
//os<<sw.frame_text("#00808080",xs,ys);
os<<sw.frame_text(m_bg_color,m_xs,m_ys);
os<<CRLF;
}
else
{

os<<sw.r_start_text(" test foo",m_xs,m_ys,m_u);
os<<CRLF;
}
os<<"<defs>"<<CRLF; 
} // DEFS

// <rect x="0" y="0" width="504" height="504" style="fill:rgb(100%,100%,100%);fill-opacity:1;stroke:none;"/>
if (pass==BODY)
{
// this now takes strings... 
os<<sw.rect_text(0,0,m_xs,m_ys,m_bg_color);
os<<CRLF;

} // BODY 

return 0; 

} // write_self_svg
virtual IdxTy write_self_end_svg(OsTy & os, Sw & sw, Super * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 
{

Ss ss;
ss<<""<< MM_MARKF<<" ";
// "Super" is wtf 
ss<<MMPR3(Super::m_rtti,Super::m_name,Super::m_type)<<MMPR2(zord.dump(),pass);
 os<<sw.comment_text(ss);
os<<CRLF;

if (pass==DEFS){  os<<"</defs>"<<CRLF;  }
if (pass==POST){  os<<"</svg>"<<CRLF;  }

return 0;

} // write_self_end_svg




#if 0 
template <class Ty,class Tv > void setup(Ty & d, const Tv & def, const StrTy & nm, ReadWriteMap&  rwm,const IdxTy flags=0)
{

//m_title="Set a title" ; rwm.get("title",m_title);
//m_title="Set a title" ; rwm.get("title",m_title);
d=def; rwm.get(nm,d);
return 0; 
} //setup 

#endif

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:
//bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
//typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

//enum { MAP_MU=0 , MU_SZ};
//mutable MutexVector m_mutex_vector;
//void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
//void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// this is in _frame 
virtual void MakeLayout(FloorPlan & fp )
{
/// m_fp
 auto  kids=Super::m_kids;
Zord zord;
auto ii=kids.begin();
while (ii!=kids.end())
{
if ((*ii).first==zord.z())
{
MM_LOOP(jj,(*ii).second ){ 

// (*jj)->write_svg(os,sw,root,zord,pass,flags); 
(*jj)->make_layout(fp); 
}
++ii;
if  (ii!=kids.end()) zord.next((*ii).first);
break;
} // ==

++ii;
} // ii 





} // MakeLayout

void Init()
{
Super::m_rtti="frame";
m_xs=2000;
m_ys=2000;
m_u="px";
m_use_old_header=false;
m_bg_color="#ffffff";
MM_ERR(" vcrit adlkj fusht ")
} // Init
void Dtor()
{
Super::Dtor();
//ClearMap();

} // Dtor 

// MEMBERS
//Zmap m_zmap;
IdxTy m_xs,m_ys;
StrTy m_u,m_bg_color;
bool m_use_old_header;

}; // mjm_svg_plotter_frame

//////////////////////////////////////////////

template <class Tr>
class mjm_svg_plotter_scatter_label : public mjm_svg_plotter_base<Tr>
{
 typedef mjm_svg_plotter_scatter_label Myt;
 typedef mjm_svg_plotter_base<Tr> Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef typename Super::Ragged Ragged;
typedef typename Ragged::Line  Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef mjm_canned_methods Canned;
typedef mjm_svg_writer Sw;
enum  {DEFS=Super::DEFS,BODY=Super::BODY,POST=Super::POST};
typedef std::vector<StrTy> Colors;
typedef std::vector<StrTy> Symbols;
typedef std::vector<StrTy> Annotations;
//typedef mjm_floorplan_points<Tr> FloorPlan;
typedef typename Super::FloorPlan FloorPlan;

public:
// floating point equality is not assured 
//typedef D Zidx;
typedef IdxTy Zidx;
typedef std::map<D,IdxTy> Zmap;
// a component can have multiple Z-levels, traversal is
// potential mess ... 
typedef typename Super::_Point Point;
typedef typename Super::_Xform Xform;
typedef typename Super::Points Points;
typedef typename Super::Values Values;
typedef typename Super::Zord Zord;
typedef typename Super::params_type params_type;
public:
// I guess these could be virtual, don't emember ctor order on hierarchy.. 
mjm_svg_plotter_scatter_label(): Super(),m_fp(Super::m_fp)  {
MM_ERR(" ctor adscascas ")

Init();}
virtual ~mjm_svg_plotter_scatter_label() {Dtor();}
virtual void make_layout(FloorPlan &fp) {MakeLayout(fp); }
// someone need to pick x,y,col,annotate etc
IdxTy ctor(const Ragged & r, const StrTy & type, const StrTy & nm, params_type & pt, const IdxTy flags) 
{
//MM_ERR(" ctor fasdfasdf")
MM_ERR(" laoding scatter lable "<<MMPR(r.size()))
LoadData(r,type,nm,pt,flags);



return 0;
} // ctor 

// at least override this... 

//virtual IdxTy write_self_svg(OsTy & os, Sw & sw, Myt * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 

/* 


<symbol overflow="visible" id="glyph1-1">
<path style="stroke:none;" d="M -3.015625 -3.546875 L -4.015625 -3.546875 L -4.015625 -0.40625 L -2.875 -0.40625 L -2.875 -3.546875 Z M -3.015625 -3.546875 "/>
</symbol>
<symbol overflow="visible" id="glyph1-2">
<path style="stroke:none;" d="M -6.140625 -6.265625 C -7.578125 -6.265625 -8.765625 -5.015625 -8.765625 -3.40625 C -8.765625 -1.671875 -7.75 -0.515625 -5.5625 -0.453125 L -5.5625 -1.78125 C -7.109375 -1.875 -7.578125 -2.328125 -7.578125 -3.375 C -7.578125 -4.328125 -7.03125 -4.90625 -6.125 -4.90625 C -5.453125 -4.90625 -4.96875 -4.546875 -4.53125 -3.796875 L -3.90625 -2.6875 C -2.90625 -0.90625 -2 -0.359375 0 -0.25 L 0 -6.203125 L -1.3125 -6.203125 L -1.3125 -1.75 C -1.875 -1.84375 -2.21875 -2.1875 -2.828125 -3.234375 L -3.484375 -4.421875 C -4.109375 -5.609375 -5.09375 -6.265625 -6.140625 -6.265625 Z M -6.140625 -6.265625 "/>
</symbol>



<g style="fill:rgb(0%,0%,0%);fill-opacity:1;">
  <use xlink:href="#glyph0-1" x="56.023438" y="456.256836"/>
  <use xlink:href="#glyph0-2" x="60.019531" y="456.256836"/>
</g>
<g style="fill:rgb(0%,0%,0%);fill-opa
*/

virtual IdxTy write_self_svg(OsTy & os, Sw & sw, Super * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 
{
FloorPlan & fp=root->fp();
// this confuses the  read
if (false) {
Ss ss; 
ss<<"first component here  ... "<< MM_MARKF<<" ";
ss<<MMPR3(Super::m_rtti,Super::m_name,Super::m_type)<<MMPR2(zord.dump(),pass);
 os<<sw.comment_text(ss);
os<<CRLF;
}
MM_ERR(MMPR3(Super::m_rtti,Super::m_name,Super::m_type)<<MMPR2(zord.dump(),pass));

if (pass==DEFS)
{
//if (m_use_old_header)
{
//ow.bounds(x,y,lc.m_level_sz);
//os<<sw.start_text(" test foo",m_xs,m_ys);
//os<<sw.frame_text("#00808080",xs,ys);
//os<<sw.frame_text(m_bg_color,m_xs,m_ys);
os<<"<symbol overflow=\"visible\" id=\"df1\">";
//os<<"<circle cx=\"0\" cy=\"0\" r=\"2\" fill=\"red\"/>";
os<<"<circle cx=\"0\" cy=\"0\" r=\"2\" />";
os<<"</symbol>";
os<<CRLF;
}
} // DEFS

// <rect x="0" y="0" width="504" height="504" style="fill:rgb(100%,100%,100%);fill-opacity:1;stroke:none;"/>
if (pass==BODY)
{
// this now takes strings... 
//os<<sw.rect_text(0,0,m_xs,m_ys,m_bg_color);
//os<<CRLF;
MM_ERR(" body "<<MMPR(m_points.size()))
//Xform xf(10,10,-70,-70);
Xform &  xf = m_xform; // (10,10,-70,-70);
MM_SZ_LOOP( i,m_points,sz)
{
Point z=xf.xform(m_points[i]);
const StrTy x=z.str(0);
const StrTy y=z.str(1);
const StrTy f=m_colors[i];
//  os<<"<use xlink:href=\"#df1\" x=\""<<x<<"\" y=\""<<y<<"\" fill=\""<<f<<"\" />";
os<<"<circle cx=\""<<x<<"\" cy=\""<<y<<"\" r=\""<<m_base_size<<"\" fill=\""<<f<<"\"/>";
os<<CRLF;
const StrTy t=m_anno[i];
const D tlen=D(15)*D(.125)*D((unsigned int )t.length());
const D tsz=3;
os<<sw.htext_box_text(m_anno[i],z.d(0),z.d(1),tsz,tlen,"green","middle");
//os<<sw.shade_rect_text(z.d(0)-tlen/2,z.d(1),tlen,sz,"black",.3);
os<<sw.some_shape_text("box",z.d(0)-tlen/2,z.d(1)-tsz,tlen,tsz,"red","none",1);
os<<CRLF;
} // i 

} // BODY 

return 0; 

} // write_self_svg
virtual IdxTy write_self_end_svg(OsTy & os, Sw & sw, Super * root, Zord & zord, const IdxTy pass,const IdxTy flags) // const 
{

Ss ss;
ss<<""<< MM_MARKF<<" ";
// "Super" is wtf 
ss<<MMPR3(Super::m_rtti,Super::m_name,Super::m_type)<<MMPR2(zord.dump(),pass);
 os<<sw.comment_text(ss);
os<<CRLF;

//if (pass==DEFS){  os<<"</defs>"<<CRLF;  }
//if (pass==POST){  os<<"</svg>"<<CRLF;  }

return 0;

} // write_self_end_svg




#if 0 
template <class Ty,class Tv > void setup(Ty & d, const Tv & def, const StrTy & nm, ReadWriteMap&  rwm,const IdxTy flags=0)
{

//m_title="Set a title" ; rwm.get("title",m_title);
//m_title="Set a title" ; rwm.get("title",m_title);
d=def; rwm.get(nm,d);
return 0; 
} //setup 

#endif

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
protected:
//bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
//typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

IdxTy LoadData(const Ragged & r, const StrTy & type, const StrTy & nm, params_type & pt, const IdxTy flags) 
{
IdxTy szmin=m_x_col;
if (m_y_col>szmin) szmin=m_y_col;
if (m_sym_col>szmin) szmin=m_sym_col;
if (m_col_col>szmin) szmin=m_col_col;
if (m_lbl_col>szmin) szmin=m_lbl_col;
MM_ERR(MMPR2(szmin,m_lbl_col)<< MMPR4(m_x_col,m_y_col,m_sym_col,m_col_col))
MM_LOOP(ii,r)
{
const Line & l=(*ii);
const IdxTy len=l.size();
MM_ERR(MMPR(len))
if (len<=szmin) continue;
m_points.push_back(Point(l[m_x_col],l[m_y_col]));
m_colors.push_back(l[m_col_col]);
m_symbols.push_back(l[m_sym_col]);
m_anno.push_back(l[m_lbl_col]);



} // ii 
MM_ERR(MMPR(m_points.size()))
return 0;
} // LoadData

virtual void MakeLayout(FloorPlan &fp) {
MM_ERR(MMPR2(__FUNCTION__,Super::m_rtti))

//MakeLayout(fp); 
fp.add_points(m_points,this, 0);
// now setup m_xform
fp.xform(m_xform,this,0);


} // MakeLayout

//MM_ERR("ctor fasdfasdf")
//enum { MAP_MU=0 , MU_SZ};
//mutable MutexVector m_mutex_vector;
//void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
//void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Init()
{
Super::m_rtti="scatter_label";
m_x_col=0;
m_y_col=1;
m_col_col=2;
m_sym_col=4;
m_lbl_col=5;
m_base_size=2;
//m_ano_col=5;
//m_xs=2000;
//m_ys=2000;
//m_u="px";
//m_use_old_header=false;
//m_bg_color="#ffffff";
//MM_ERR(" vcrit adlkj ")
} // Init
void Dtor()
{
Super::Dtor();
//ClearMap();

} // Dtor 

// MEMBERS
IdxTy m_x_col,m_y_col,m_sym_col,m_col_col,m_lbl_col;
D m_base_size;
Points m_points;
Colors m_colors;
Symbols m_symbols;
Annotations m_anno;
// Super now... 
FloorPlan&  m_fp;
Xform m_xform;
//Zmap m_zmap;
//IdxTy m_xs,m_ys;
//StrTy m_u,m_bg_color;
//bool m_use_old_header;

}; // mjm_svg_plotter_scatter_label




////////////////////////////////////////////
#ifdef  TEST_MJM_PLOTTER_BASICS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_svg_plotter_basics <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_PLOTTER_BASICS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_svg_plotter_basics<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_PLOTTER_BASICS_H__ 
