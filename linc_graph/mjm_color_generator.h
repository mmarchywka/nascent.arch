#ifndef MJM_COLOR_GENERATOR_H__
#define MJM_COLOR_GENERATOR_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"



// Tue May 21 18:33:48 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_color_generator   
// g++ -std=gnu++11 -DTEST_MJM_COLOR_GENERATOR -I. -I../../mjm/hlib -gdwarf-3 -O0  -x c++ mjm_color_generator.h  -lpthread

template <class Tr>
class mjm_color_generator 
{
 typedef mjm_color_generator Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;

public:


static IdxTy next() { return Next(); }

StrTy next_contrast() { return NextContrast(); } 
void combo( StrTy & color, IdxTy & thick) { Combo(color,thick); }

private:




typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};


static MutexVector & mv() 
{
static MutexVector mvv = MutexVector(MU_SZ);
return mvv;
}
static IdxTy Next()
{
EnterSerial(MAP_MU);
static IdxTy n=0;
++n;
IdxTy m=n;
ExitSerial(MAP_MU);
return m;
}

static const char *  Lut()
{
EnterSerial(MAP_MU);
static const char * c="0123456789ABCDEF"; 
ExitSerial(MAP_MU);
return &c[0];
}
void ch(Ss & ss, const IdxTy c, const IdxTy n) { ss<<Lut()[((c>>(n<<2))&15)]; }
void Hex(Ss & ss, char c) { ch(ss,c,1); ch(ss,c,0); }

void State(Ss & ss, IdxTy s) 
{
switch (s)
{
case 0 : { ss<<"00"; break; }
case 1 : { ss<<"3F"; break; }
case 2 : { ss<<"7F"; break; }
case 3 : { ss<<"FF"; break; }
default: MM_ERR(" bad case "<<MMPR2(s,ss.str())) 
}
} // State

void EnterSerial(const IdxTy i)const  {  mv().enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  mv().exit_serial(i ); }
IdxTy Seq() { return m_seq&63; } 
void Init()
{
m_seq=0;
}
StrTy NextContrast() { 
do { ++m_seq; } 
while (Seq()==0) ;
IdxTy idx=Seq();
Ss ss;
ss<<"#";
IdxTy sr=Bx(idx,0,3);
IdxTy sg=Bx(idx,1,5);
IdxTy sb=Bx(idx,2,4);
State(ss,sr);
State(ss,sg);
State(ss,sb);
 
return ss.str(); 
} 
IdxTy Bx(const IdxTy f, const IdxTy b1, const IdxTy b2)
{
bool t1=((f&(1<<b1))==0);
bool t2=((f&(1<<b2))==0);
return (t1?1:0)+(t2?2:0);
}

void Combo( StrTy & color, IdxTy & thick) { 
const IdxTy i=Next();

}

IdxTy m_seq;


}; // mjm_color_generator
#ifdef  TEST_MJM_COLOR_GENERATOR
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 

int main(int argc,char **args)
{
typedef mjm_color_generator<Tr>  Myt;
//Myt x(argc,args);
Myt x;
//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_COLOR_GENERATOR_H__ 
