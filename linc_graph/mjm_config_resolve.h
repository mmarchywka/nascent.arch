#ifndef MJM_CONFIG_RESOLVE_H__
#define MJM_CONFIG_RESOLVE_H__

#include "mjm_globals.h"
#include "mjm_data_model_error_log.h"
#include "mjm_strings.h"
#include "mjm_cli_ui.h"
#include "mjm_collections.h"

#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>
                                 
// Fri May 17 05:18:29 EDT 2019
// generated by -classhdr mjm_config_resolve  

/*
Try to create a net configuration based on various
sources making commands consistent at each leve.
Default, Config file, command line options each offering same
capabilities and ability to negate earlier selections.
This then means either removing earlier commands from the
net result or insuring each setting has an inverse that
can be applied before executing some function. 

Most of this is based on key-value pairs read from a file or
command line or configuration classes so generally it can 
collate. However details change between sources. 

Generally logic_base and Ragged are used for creating a configuration
prior to executing anything. logic_base is purely a map  although
Ragged is evaluated in order of the lines and may have multiple entries
pure key with values more likely to need parsing. In theory the Ragged
could support line delete but probably better to provide for each key
to have an inverse key then multi value values can be each undone. 


*/



template <class Tr>
class mjm_config_resolve 
{
protected:
 typedef mjm_config_resolve Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;

// need header for this
typedef string_tokenizer St;


typedef mjm_ragged_table Ragged;
typedef std::map<StrTy, Ragged> RaggedMap;


typedef std::map<StrTy, StrTy> Map;
typedef std::map<StrTy, Map> MapMap;
typedef std::vector<StrTy> VectorTy;
typedef std::map<StrTy, VectorTy> VectorMap;
typedef VectorMap::const_iterator VMiter;
class value_entry
{
public:

StrTy m_key;
StrTy m_value;
StrTy m_src;

};// value_entry
typedef value_entry Ve;
typedef std::map<StrTy, Ve> VeMap;
typedef std::map<StrTy, VeMap> VeMapMap;
typedef std::vector<Ve> VeVectorTy;
typedef std::map<StrTy, VeVectorTy> VeVectorMap;

private:
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};


public:
// in order of precedence, defaults first then highest priority last. 
void add( const Map& m, const StrTy & n="") { Add(m,n);}

// this needs to attempt to reconstuct the input value from parsed things, 
void add( const Ragged& r, const StrTy & n="") { Add(r,n);}

// just copy the map for later resolution
void copy( const Map& m, const StrTy & n) { m_maps[n]=m;}

StrTy operator[](const StrTy & k ) const { return Resolve(k); } 
bool exists(const StrTy & k ) const { return m_net.find(k)!=m_net.end(); } 

const VectorTy&  operator()(const StrTy & k ) const { return Find(k); } 
IdxTy size(const StrTy & k ) const { return Find(k).size(); } 

// just get the overall composite
Map resolved() const { return Resolved(); } 
// appends config fields to the Ragged presumed to be after
// program defaults but before command line options in precedence.
void resolved(Ragged & r ) { Resolved(r); } 
Map def_config_cmd( const Map & def, const Map & config, const Map & cmd)
{ add(def); add(config); add(cmd); return resolved(); }



Map def_config_cmd( const Map & def, const Ragged  & config, const Map & cmd)
{ add(def); add(config); add(cmd); return resolved(); }


void clear() { Clear(); } 
private:

void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

void Init()
{
m_mutex_vector = MutexVector(MU_SZ);
}
void Add( const Map& m, const StrTy & n) { 
MM_LOOP(ii,m)
{
const StrTy & k = (*ii).first;
const StrTy & v = (*ii).second;

m_net[k].push_back(v);
}
} // Add
void Add( const Ragged& m, const StrTy & n) { 
MM_SZ_LOOP(i,m,sz)
{
const Ragged::Line & line=m.line(i);
const StrTy & k = ""; // (*ii).first;
const StrTy & v = ""; // (*ii).second;

m_net[k].push_back(v);
}
} // Add



// while ref would be nice just do this for now 
StrTy Resolve(const StrTy & k ) const
{
VMiter  ii=m_net.find(k);
if (ii!=m_net.end())
{
// entries must have at least one element, no [] access allowd now. 
return (*ii).second.back();
} // end
return ""; 
} // Resolve
Map Resolved() const
{
Map m;
MM_LOOP(ii,m_net) { m[(*ii).first]=(*ii).second.back(); } // ii 

return m;
} // Resolved
// appends config fields to the Ragged presumed to be after
// program defaults but before command line options in precedence.
// This is an ordered set of instructions. Prepend the defaults
// and append the command line 
void Resolved(Ragged & r ) 
{ 


} 



const VectorTy&  Find(const StrTy & k ) const
{
VMiter  ii=m_net.find(k);
if (ii==m_net.end()) return m_empty;
return (*ii).second;
}
void Clear() 
{
m_net.clear();
m_maps.clear();
m_details.clear();


}

VectorMap m_net; 
MapMap m_maps;
VeVectorMap m_details;
VectorTy m_empty;
mutable MutexVector m_mutex_vector;

}; // mjm_config_resolve


template <class Tlogic, class Tr>
class mjm_logic_resolve: public  mjm_config_resolve<Tr>
{
typedef mjm_config_resolve<Tr> Super;
typedef typename Super::Ragged Ragged;
public:

Tlogic & flp_def() { return m_flp_def;}
Tlogic & flp() { return m_flp;}
private:

Tlogic m_flp_def, m_flp;
// this allows for meaningful parse to be different depending on source
// maps made from this should reflect only the latest entries. 
Ragged m_history;

}; // mjm_logic_resolve

#endif // MJM_CONFIG_RESOLVE_H__ 
