#ifndef MJM_RAG_SPLITTER_H__
#define MJM_RAG_SPLITTER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_collections.h"
// probably want config resolver here NOT rule list 
#include "mjm_rule_list.h"
#include "mjm_misc_parse.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun May 26 20:09:42 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_rag_splitter   
// g++ -std=gnu++11 -DTEST_MJM_RAG_SPLITTER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_rag_splitter.h  -lpthread

template <class Tr>
class mjm_rag_splitter 
{
 typedef mjm_rag_splitter Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_rule_list<Tr> RuleList;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map< StrTy , Ragged> RagMap;
typedef typename RagMap::iterator Itor;
public:
mjm_rag_splitter():m_idx(0) {}
~mjm_rag_splitter() {}
// original intent, this is the key field which is split according
// to rule list
void field(const IdxTy i) { m_idx=i; } 
// rule name, expression, value
void add_rule( const Line & line ) {m_rules.add(line); } 

// split the parameter r according to previously set criteria.
// the result is a collection of raggeds for user to iterate over
void split(const Ragged & s) { Split(s); }
// create a new Ragged for each unique name in names with elements
// as selected. This is very vebose and slow but ok for these 
// small files. 
void split(const Ragged & s, const Ragged & names) { Split(s,names); } 
// Names contains a name in first column followed by a clumn range 
// for the Ragged with that name . 
void split_columns(const Ragged & s, const Ragged & names) { SplitColumns(s,names); } 
// taking first column in all and a max of nd following data 
void split_columns(const Ragged & s, const IdxTy nd,const IdxTy flags ) { SplitColumns(s,nd,flags); } 
Itor begin() { return m_rags.begin();}
Itor end() { return m_rags.end();}
void clear_map() { m_rags.clear(); }

typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:

void Split(const Ragged & s) { 
auto ii=s.begin();
auto ie=s.end();
while(ii!=ie)
{
const Line x=(*ii);
const IdxTy sz=x.size();
if ( m_idx>=sz){ ++ii;  continue; }
StrTy key=x[m_idx];
const StrTy rule_name="";
// this should probably use the config resolver NOT the rule_list
m_rules.apply(key,rule_name,key);
m_rags[key].add(x);

++ii;
}


} // Split
void Split(const Ragged & s, const Ragged & names) 
{ 
// Split(s,names); 

} 
//void SplitColumns(const Ragged & s, const Ragged & names)  {}
//void SplitColumns(const Ragged & s, const IdxTy nd)  {}
// #if 0
void SplitColumns(const Ragged & s, const IdxTy nd, const IdxTy flags) 
{
typedef Ragged::Line Line;
Ragged names;
const IdxTy nc=s.maxcol();
MM_ERR(" start split col "<<MMPR2(nd,nc))
if (nd<1){ m_rags[""]=s; return; } 
//const int nparts=((nc-1)+nd-1)/nd;
const int nparts=((nc-1)+nd-1)/nd;
MM_ERR(" start split col "<<MMPR3(nparts,nd,nc))
if (nparts<2) {m_rags[""]=s; return; } 
MM_ERR(MMPR3(nc,nparts,nd))
for(IdxTy i=0; i<nparts; ++i)
{
Line line(2);
{Ss ss; ss<<i; line[0]=ss.str(); } 
// doh the name column is separate 
const IdxTy start=1+(i*nd);
//const IdxTy start=0+(i*nd);
IdxTy finish=start+nd-1;
if (finish>=nc) finish=nc-1; 
{Ss ss; ss<<"0,"<<start<<"-"<<finish; line[1]=ss.str(); } 
//{Ss ss; ss<<""<<start<<"-"<<finish; line[1]=ss.str(); } 
MM_ERR(MMPR2(line[0],line[1]))
names.add(line);
}

SplitColumns(s,names,flags);
}
const bool Bit(const IdxTy f, const IdxTy b) { return ((f&(1<<b))!=0); } 
//#if 0 
void SplitColumns(const Ragged & s, const Ragged & names, const IdxTy flags ) 
{ 
typedef mjm_misc_parse<Tr> Ranger;
typedef Ragged::Line Line;
typedef std::vector<IdxTy> Cols;
typedef std::map<StrTy,Cols> ColsMap;
ColsMap m;
Ranger rng;
const bool apply_header_kluge=Bit(flags,0);
const IdxTy nc=s.maxcol();
MM_LOOP(ii,names)
{
const Line & l=(*ii);
const IdxTy sz=l.size();
if (sz<2) continue;
const StrTy & n=l[0];
const StrTy & s=l[1];
//rng.eval_int_set(m,s,0,nc);
if ( rng.evaluate_range(m[n],s))
{ // append to the end 
if (m[n].size()==0) continue; 
while ( m[n].back()<nc) { m[n].push_back(m[n].back()+1); } 
} // rng 
} // ii

// the destination rags are named in the first columen of names
// and their size is determined by range in second column and
// size of s. 
auto ii=s.begin();
auto ie=s.end();
IdxTy kluge=0;
while(ii!=ie)
{
++kluge;
const Line&  line=(*ii);
const IdxTy szl=line.size();
MM_LOOP(jj,m)
{
const Cols & x=(*jj).second;
{ Ss ss; MM_LOOP(ii,x) ss<<" "<<(*ii); ss<<CRLF; MM_ERR("cols "<<MMPR(ss.str())) }
const IdxTy sz=x.size();
if (sz==0) continue;
const StrTy key=(*jj).first;
//const IdxTy szl=x.back();
// the new line should have one entry for each requested 
Line y(sz); //  
//for(IdxTy iii=0; iii<sz; ++iii) y[iii]="";
// need not be in order so can't break on test fail 
MM_SZ_LOOP(k,x,szk)  {IdxTy pe=x[k]; 
const bool hkluge=apply_header_kluge&&(kluge==1);
if ( hkluge) --pe;  // zero maps to big positive 
if ( pe<szl) {  y[hkluge?(k-1):k]= line[pe];}   } 
m_rags[key].add(y);
if (kluge==1) 
{ 
Ss ss; 
for(IdxTy iii=0; iii<sz; ++iii) ss<<MMPR(y[iii]); 
for(IdxTy iii=0; iii<szl; ++iii) ss<<MMPR(line[iii]); 

MM_ERR(MMPR(ss.str()))
}

} // jj 
//const IdxTy sz=x.size();
//if ( m_idx>=sz){ ++ii;  continue; }
//StrTy key=x[m_idx];
// this should probably use the config resolver NOT the rule_list
//const StrTy rule_name="";
//m_rules.apply(key,rule_name,key);
//m_rags[key].add(x);

++ii;
}

} // SplitColumns  



StrTy Dump(const IdxTy flags=0) {Ss ss; 
MM_LOOP(ii,m_rags) { ss<<MMPR2((*ii).first, (*ii).second.size())<<CRLF; }

 return ss.str(); }

RagMap m_rags;
RuleList m_rules;
IdxTy m_idx;

}; // mjm_rag_splitter

//////////////////////////////////////////////

template <class Tr>
class mjm_rag_splitter_map : public std::map<typename Tr::StrTy, mjm_rag_splitter< Tr > >  
{
 typedef mjm_rag_splitter_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_rag_splitter< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_rag_splitter_map() {}
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_rag_splitter_map




////////////////////////////////////////////
#ifdef  TEST_MJM_RAG_SPLITTER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;
#include "mjm_canned_methods.h"
typedef mjm_canned_methods Canned;

 int myatoi(const StrTy & s )  { return myatoi(s.c_str()); }
 int myatoi(const char * c)  { return ::strtol(c,0,0); }


class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam  Cip;
template <class Trm>
static void cmd_read_ragged(Cip & cip , LocalVar & lv, Trm & rm  )
//static void cmd_read_ragged(Cip & cip , LocalVar & lv, RaggedMap & rm  ) 
{
const StrTy cmd=cip.cmd();
const StrTy name=cip.p1;
const StrTy fn=cip.p2;
const IdxTy flags=myatoi(cip.wif(3).c_str());
const bool load_string=(cmd=="string-ragged");
const bool load_parsed=((flags&1)==0);
const bool tabsep=((flags&2)!=0);
const bool ignore_hash=((flags&4)!=0);
const bool debug=((flags&8)!=0);
const bool csv=((flags&16)!=0);
const bool pdftext=((flags&32)!=0);
const bool lsv=((flags&64)!=0);
//MM_ERR(" cmd_read_ragged from "<<fn<<" to "<<name<<" flags "<<flags)
MM_ERR(" cmd_read_ragged from "<<MMPR4(cmd,fn,name,flags)<<MMPR3(debug,csv,pdftext)<<MMPR4(load_string, load_parsed,tabsep,ignore_hash))
typename Trm::mapped_type  & r=rm[name];
//Ragged & r=rm[name];
r.sep(" ");
if (tabsep) r.sep("\t");
if (csv) r.sep(",");
if (lsv) r.sep("|");
if (ignore_hash) r.ignore_hash(ignore_hash);
if (pdftext) r.pdf_columns();
if (load_string) r.load_from_string(fn,debug);
else
if (load_parsed) r.load(fn,debug);
else r.load_lines(fn,debug);
MM_ERR(MMPR2(r.size(),name))
}



int main(int argc,char **args)
{
typedef mjm_rag_splitter<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
LocalVar  lv ;
typedef mjm_ragged_table Ragged;
std::map<StrTy, Ragged> rmap;
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="quit") break;
CommandInterpretterParam  cip(li);
if (cmd=="read") {  
//Canned::cmd_read_ragged( cip ,  lv, rmap  ) ; 
cmd_read_ragged( cip ,  lv, rmap  ) ; 
MM_LOOP(ii,rmap) { MM_MSG((*ii).first<<" "<<(*ii).second.size()) } 
continue; }

if (cmd=="split") {  
const StrTy & nm=cip.p1;
const StrTy & rm=cip.p2;
const IdxTy f=myatoi(cip.wif(3).c_str());
MM_MSG(MMPR3(nm,rm,f))
x.field(f);
x.split(rmap[nm]);
continue; }

if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_RAG_SPLITTER_H__ 
