#ifndef MJM_COEFFICIENTS_H__
#define MJM_COEFFICIENTS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri May 24 05:22:46 EDT 2019
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_coefficients   
// g++ -std=gnu++11 -DTEST_MJM_COEFFICIENTS -I. -I../../mjm/hlib -I../../mjm/num/ -gdwarf-3 -O0  -x c++ mjm_coefficients.h  -lpthread -lreadline

template <class Tr>
class mjm_coefficients 
{
 typedef mjm_coefficients Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef int Int;
// typedef typename Tr::MyBlock  MyBlock;
typedef std::map<Int, D> Coefs;
typedef typename Coefs::const_iterator Itor;
typedef std::vector<StrTy> Line;

// still have not found a place to put this crap 
static int myatoi(const StrTy & s )  { return myatoi(s.c_str()); }
static int myatoi(const char * c)  { return ::strtol(c,0,0); }

public:
mjm_coefficients() { }
mjm_coefficients(const Line & w, const IdxTy n ) {Load(w,n);   }
~mjm_coefficients() {  }
void clear() { m_coefs.clear(); } 
void add(const Int n, const D & v) { m_coefs[n]+=v; } 
void normalize() { Normalize();}
void shift(const Int n ) { Shift(n);}
Itor begin() const { return m_coefs.begin(); } 
Itor end() const { return m_coefs.end(); } 
StrTy dump( const IdxTy flags=0) { return Dump(flags); } 
StrTy name() const { return m_name; } 
StrTy name(const StrTy & n) const {m_name=n;  return m_name; } 
void load(const Line & w,const IdxTy n) { Load(w,n); } 
template <class Tx, class Ty> void load_lines(Tx & rbegin, Ty & rend, const IdxTy n ) {load_lines(rbegin,rend,n); } 
private:
void Init()
{
}
D Atof(const StrTy & s) const { return ::atof(s.c_str()); }
bool Bit(const IdxTy flags, const IdxTy b) { return (0!=(flags&(1<<b))); } 
void Load(const Line & w, const IdxTy n ) 
{ 
IdxTy state=0;
Int pos=0;
Int var=0;
D c=0;
IdxTy flags=0;
const IdxTy sz=w.size();
for(IdxTy i=n; i<sz; ++i)
{
const StrTy & t=w[i];
if (t=="normalize") {  flags|=1;  }
else if (t=="uniform") {  m_coefs=uniform(pos); state=0;  }
else if (t=="trailing") {  m_coefs=trailing(pos); state=0;  }
else if (t=="shift") { var=pos;  flags|=2; state=0;  }
else if (t=="triangle") {  m_coefs=triangle(pos,false); state=0;  }
else if (t=="saw") {  m_coefs=triangle(pos,!false); state=0;  }
else 
{
if (state==0)  { pos=myatoi(t); state=1; }
else if (state==1)  { c=Atof(t); m_coefs[pos]=c;  state=0; }

} // coef 
} // i 
if (Bit(flags,0)) Normalize();
if (Bit(flags,1)) Shift(var);

} // Load 
template <class Tx, class Ty> void LoadLines(Tx & rbegin, Ty & rend, const IdxTy n ) 
{
Tx ii=rbegin;
while (ii!=rend) { Load((*ii),n); } 
} 

Coefs uniform(const IdxTy n)
{MM_ERR(" uniform "<<MMPR(n))
 Coefs m; for (Int i=0; i<=n; ++i)  {
m[i]=1; m[-i]=1;
MM_ERR("uniform "<<MMPR2(i,m[i])) 
 } return m; }
Coefs trailing(const IdxTy n)
{ Coefs m; for (Int i=0; i<=n; ++i)  { m[i]=1; } return m; }


Coefs triangle(const IdxTy n, const bool causal)
{
Coefs m;
for (Int i=0; i<n; ++i)  { D c= D(n-i)/D(n+1); if ( !causal) m[-i]=c; m[i]=c; } 
return m;
}
StrTy Dump( const IdxTy flags)
{
Ss ss;
Dump(ss,flags);
return ss.str();
}
void Dump(Ss & ss, const IdxTy flags)
{
ss<<name()<<CRLF;
D sum=0;
MM_LOOP(ii,m_coefs)
{
const Int n=(*ii).first;
const D c=(*ii).second;
sum+=c;
ss<<MMPR4(n,c,sum,m_coefs.size())<<CRLF;
} // ii 

} // Dump 

void Shift(const Int n )
{
Coefs x; 
MM_LOOP(ii,m_coefs) { const Int nn=(*ii).first; x[nn+n]=(*ii).second; }
m_coefs=x;
}


void Normalize()
{
D sum=0;
MM_LOOP(ii,m_coefs) { sum+=(*ii).second; }
if (sum==0) { MM_ERR(" zero sum "<<MMPR2(name(),m_coefs.size())) return ; } 
MM_LOOP(ii,m_coefs) { (*ii).second/=sum; }
}

Coefs m_coefs;
StrTy m_name;

}; // mjm_coefficients

//////////////////////////////////////////////

template <class Tr>
class mjm_coefficients_map : public std::map<typename Tr::StrTy, mjm_coefficients< Tr > >  
{
 typedef mjm_coefficients_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_coefficients< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_coefficients_map() {}



StrTy dump(const IdxTy flags=0) { return Dump(flags); } 

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0) 
{ 
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

} 


}; // mjm_coefficients_map




////////////////////////////////////////////
#ifdef  TEST_MJM_COEFFICIENTS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 

#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

class tester {
typedef mjm_cli_ui<tester> Cli;
public:
 void cli_cmd( Cli::list_type & choices,  const char * frag)
{
/*const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
*/
}

 void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

 }; // tester
typedef mjm_cli_ui<tester> Cli;

int main(int argc,char **args)
{
typedef mjm_coefficients<Tr>  Myt;
//Myt x(argc,args);
Myt x;
//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin); 
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }  
else if (cmd=="load") { x.load(li.words(),1); }  
else if (cmd=="clear") { x.clear(); }  


} // nextok


return 0;
}

#endif // main

#endif // MJM_COEFFICIENTS_H__ 
