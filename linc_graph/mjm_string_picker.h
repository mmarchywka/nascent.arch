#ifndef MJM_STRING_PICKER_H__
#define MJM_STRING_PICKER_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include <string>
#include <sstream>
#include <iostream>
#include <map>
#include <vector>

#define MJM_HAVE_REGEX
#ifdef MJM_HAVE_REGEX
#include <regex>
#endif



// Tue May 21 13:38:11 EDT 2019
// generated by -classhdr mjm_string_picker  

// g++ -std=gnu++11 -DTEST_mjm_string_picker -I. -I../../mjm/hlib -gdwarf-3 -O0  -x c++ mjm_string_picker.h  -lpthread



template <class Tr>
class mjm_string_picker 
{
 typedef mjm_string_picker Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
// typedef typename Tr::MyBlock  MyBlock;
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
typedef std::map<StrTy, IdxTy> Hits;
typedef std::vector<StrTy> Sorder;
typedef typename Hits::iterator HiItor;
typedef typename Hits::const_iterator HiCItor;
typedef std::map<StrTy, IdxTy> Exacts;
typedef std::map<StrTy, IdxTy> Stems;
typedef std::map<StrTy, StrTy> LUT;



public:
mjm_string_picker() : m_selecting(false),m_max_reject_cache(100) {}
void clear_hits() { m_hits.clear(); } 
void clear_criteria() { ClearCriteria(); } 

HiCItor begin()const { return m_hits.begin(); } 
HiCItor end()const { return m_hits.end(); } 
HiItor begin() { return m_hits.begin(); } 
HiItor end() { return m_hits.end(); } 
IdxTy size()const { return m_hits.size(); } 
const StrTy & key_name(const StrTy & k) { return m_base[k]; }
void key_name(const StrTy & k,const StrTy & v) { m_base[k]=v; }

// add criteria, regex can default to true if regex is available... 
void add(const StrTy & s, const bool accept=true, const bool regex=false) { Add(s,accept,regex); }
void reject(const StrTy & s, const bool regex=false) { Add(s,false,regex); }
void accpet(const StrTy & s, const bool regex=false) { Add(s,!false,regex); }
bool selecting() const { return m_selecting; } 
// determine if word is in the accepted hits list but do
// not modify lists.  
bool found(const StrTy & s) 
{ // MM_ERR(MMPR2(s,Found(s)))  
return Found(s); } 

// if word matches criteria, add to hits list return true;
bool test(const StrTy & s) 
{ bool x= Test(s); // MM_ERR(MMPR3(s,Test(s),s))  
return x;  } 

private:
enum { MAP_MU=~0 , MU_SZ};

mutable MutexVector m_mutex_vector;


void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }

void Init()
{
m_mutex_vector = MutexVector(MU_SZ);
}
void ClearCriteria( )
{
m_include.clear();
m_exclude.clear();
m_ex_include.clear();
m_ex_exclude.clear();
m_selecting=false;
}
void bools(IdxTy & br, const bool b) { br=(br<<1) | (b?1:0); }
void Add(const StrTy & s, const bool accept=true, const bool regex=false) 
{  
IdxTy br=0;
bools(br,accept);
bools(br,regex);
Add(s,br);
}
void Add(const StrTy & s, const IdxTy m)
{
m_selecting=true;
switch (m) { 
case 0:{ Add(m_exclude,s); break; } 
case 1:{ Add(m_ex_exclude,s); break; } 
case 2:{ Add(m_include,s); break; } 
case 3:{ Add(m_ex_include,s); break; } 

default:{ MM_ERR(" bad switch "<<MMPR(m)) }
} // switch
//MM_ERR(MMPR2(s,m)<<MMPR4(m_exclude.size(),m_ex_exclude.size(),m_include.size(),m_ex_include.size()))
} // Add
void Add( Exacts&  m, const StrTy & s) { ++m[s]; }

bool Found(const StrTy & s) { return ( m_hits.find(s)!=m_hits.end());  }
bool Rejected(const StrTy & s) { return ( m_rejected.find(s)!=m_rejected.end());  }

bool Test(const StrTy & s)
{
// this is easier than the other criteria 
if (!m_selecting)  { AddHit(s);  return !false; } 
if (Found(s)) { AddHit(s);  return !false; } 
if (Rejected(s)) {  return false; } 
IdxTy br=0;
bools(br,Hitex(s,m_ex_include));
bools(br,Hit(s,m_include));
bools(br,Hitex(s,m_ex_exclude));
bools(br,Hit(s,m_exclude));
if ((br&3)==0) //return false;
if ((br&12)!=0) { AddHit(s);  return !false; } 
++m_rejected[s];
// this saves time but could waste memory on some data 
// proably ok size cache. 
if (m_rejected.size()>m_max_reject_cache) m_rejected.clear();
return false;
}
void AddHit(const StrTy & s ) { ++m_hits[s]; } 
bool Hit( const StrTy & s, const  Exacts & e) { return (e.find(s)!=e.end()); }
bool Hitex( const StrTy & s, const  Exacts & e) { 
MM_LOOP(ii,e)
{
std::regex rgx((*ii).first.c_str());
if ( std::regex_search(s.c_str(),rgx)) return true;

}
return false; 
}

bool m_selecting; 
IdxTy m_max_reject_cache;
Hits m_hits,m_rejected;
Exacts m_include, m_exclude;
Stems m_ex_include, m_ex_exclude; 
Sorder m_order;
LUT m_base;
}; // mjm_string_picker
#ifdef  TEST_mjm_string_picker

class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs; 
// typedef typename Tr::MyBlock  MyBlock;
}; // 
int main(int argc,char **args)
{
typedef mjm_string_picker<Tr>  Myt;
//Myt x(argc,args);
Myt x;
//if (!x.done()) x.command_mode();
//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // mjm_string_picker 
